<?xml version="1.0"?>
<doc>
  <assembly>
    <name>NuGet.Build.Tasks.Pack</name>
  </assembly>
  <members>
    <member name="M:NuGet.Shared.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="M:NuGet.Shared.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.HashCodeCombiner.GetHashCode``2(``0,``1)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
      <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
    </member>
    <member name="M:NuGet.Shared.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
    </member>
    <member name="T:NuGet.Build.MSBuildLogger">
      <summary>
            TaskLoggingHelper -&gt; ILogger
            </summary>
    </member>
    <member name="M:NuGet.Build.MSBuildLogger.LogForNonMono(NuGet.Common.INuGetLogMessage)">
      <summary>
            Log using with metadata for non mono platforms.
            </summary>
    </member>
    <member name="M:NuGet.Build.MSBuildLogger.LogForMono(NuGet.Common.ILogMessage)">
      <summary>
            Log using basic methods to avoid missing methods on mono.
            </summary>
    </member>
    <member name="T:NuGet.Build.Tasks.GetProjectTargetFrameworksTask">
      <summary>
            Determine the project's targetframework(s) based
            on the available properties.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.GetProjectTargetFrameworksTask.ProjectPath">
      <summary>
            Full path to the msbuild project.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.GetProjectTargetFrameworksTask.TargetFrameworkMoniker">
      <summary>
            Optional TargetFrameworkMoniker property value.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.GetProjectTargetFrameworksTask.TargetPlatformIdentifier">
      <summary>
            Optional TargetPlatformIdentifier property value.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.GetProjectTargetFrameworksTask.TargetPlatformMinVersion">
      <summary>
            Optional TargetPlatformMinVersion property value.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.GetProjectTargetFrameworksTask.TargetPlatformVersion">
      <summary>
            Optional TargetPlatformVersion property value.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.GetProjectTargetFrameworksTask.TargetFrameworks">
      <summary>
            Optional TargetFrameworks property value.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.GetProjectTargetFrameworksTask.TargetFramework">
      <summary>
            Optional TargetFrameworks property value.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.GetProjectTargetFrameworksTask.ProjectTargetFrameworks">
      <summary>
            ; delimited list of target frameworks for the project.
            </summary>
    </member>
    <member name="T:NuGet.Build.Tasks.Pack.MSBuildTaskItem">
      <summary>
            TaskItem wrapper
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.GetPackOutputItemsTask.OutputPackItems">
      <summary>
            Output items
            </summary>
    </member>
    <member name="T:NuGet.Build.Tasks.Pack.GetProjectReferencesFromAssetsFileTask">
      <summary>
            Gets a list of project references from the assets file
            This list is then later traversed to determine the version
            of the project reference during pack.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.GetProjectReferencesFromAssetsFileTask.ProjectReferences">
      <summary>
            Output items
            </summary>
    </member>
    <member name="T:NuGet.Build.Tasks.Pack.IPackTaskLogic">
      <summary>
            The logic for converting the set of pack MSBuild task parameters to a fully initialized package builder. The
            set of parameters provided to the MSBuild pask task is <see cref="T:NuGet.Build.Tasks.Pack.IPackTaskRequest`1" />. This interface
            allows the logic of the pack task to be seperated from the MSBuild-specific types. The motivation is
            testability.
            </summary>
    </member>
    <member name="M:NuGet.Build.Tasks.Pack.IPackTaskLogic.GetPackArgs(NuGet.Build.Tasks.Pack.IPackTaskRequest{NuGet.Commands.IMSBuildItem})">
      <summary>
            Initialize the pack args from the pack task request.
            </summary>
    </member>
    <member name="M:NuGet.Build.Tasks.Pack.IPackTaskLogic.GetPackageBuilder(NuGet.Build.Tasks.Pack.IPackTaskRequest{NuGet.Commands.IMSBuildItem})">
      <summary>
            Initialize the package builder from the pack task request.
            </summary>
    </member>
    <member name="M:NuGet.Build.Tasks.Pack.IPackTaskLogic.GetPackCommandRunner(NuGet.Build.Tasks.Pack.IPackTaskRequest{NuGet.Commands.IMSBuildItem},NuGet.Commands.PackArgs,NuGet.Packaging.PackageBuilder)">
      <summary>
            Initialize the pack command runner from the pack task request and the output of
            <see cref="M:NuGet.Build.Tasks.Pack.IPackTaskLogic.GetPackArgs(NuGet.Build.Tasks.Pack.IPackTaskRequest{NuGet.Commands.IMSBuildItem})" /> and
            <see cref="M:NuGet.Build.Tasks.Pack.IPackTaskLogic.GetPackageBuilder(NuGet.Build.Tasks.Pack.IPackTaskRequest{NuGet.Commands.IMSBuildItem})" />.
            </summary>
    </member>
    <member name="M:NuGet.Build.Tasks.Pack.IPackTaskLogic.BuildPackage(NuGet.Commands.PackCommandRunner)">
      <summary>
            Build the package. This method actually writes the .nupkg to disk.
            </summary>
    </member>
    <member name="T:NuGet.Build.Tasks.Pack.IPackTaskRequest`1">
      <summary>
            All of the properties provided by MSBuild to execute pack.
            </summary>
      <typeparam name="TItem">
            The item type. This will either be <see cref="T:Microsoft.Build.Framework.ITaskItem" /> or a <see cref="T:NuGet.Commands.IMSBuildItem" />.
            </typeparam>
    </member>
    <member name="M:NuGet.Build.Tasks.Pack.PackTask.GetRequest">
      <summary>
            This method does two important things:
            1. Normalizes string parameters, trimming whitespace and coalescing empty strings to null.
            2. Wrap <see cref="T:Microsoft.Build.Framework.ITaskItem" /> instances to facility unit testing.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.PackTask.PackTaskLogic">
      <summary>
            This property is only used for testing.
            </summary>
    </member>
    <member name="T:NuGet.Build.Tasks.Pack.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.AssetsFileDoesNotHaveValidPackageSpec">
      <summary>
              Looks up a localized string similar to The assets file found does not contain a valid package spec. Try restoring the project again. The location of the assets file is {0}..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.AssetsFileNotFound">
      <summary>
              Looks up a localized string similar to The assets file produced by restore does not exist. Try restoring the project again. The expected location of the assets file is {0}..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.Error_FileNotFound">
      <summary>
              Looks up a localized string similar to The file '{0}' to be packed was not found on disk..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.InvalidMinClientVersion">
      <summary>
              Looks up a localized string similar to MinClientVersion string specified '{0}' is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.InvalidNuspecProperties">
      <summary>
              Looks up a localized string similar to NuspecProperties should be in the form of "key1=value1;key2=value2"..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.InvalidPackageReferenceVersion">
      <summary>
              Looks up a localized string similar to PackageReference {0} needs to have a valid version..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.InvalidPackageVersion">
      <summary>
              Looks up a localized string similar to PackageVersion string specified '{0}' is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.InvalidTargetFramework">
      <summary>
              Looks up a localized string similar to Invalid target framework for the file '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.IsPackableFalseError">
      <summary>
              Looks up a localized string similar to Cannot generate a package from a project which has IsPackable property set to false..
            </summary>
    </member>
    <member name="P:NuGet.Build.Tasks.Pack.Strings.NoPackItemProvided">
      <summary>
              Looks up a localized string similar to No project was provided to the PackTask..
            </summary>
    </member>
    <member name="T:Microsoft.AspNet.FileProviders.IDirectoryContents">
      <summary>
            Represents a directory's content in the file provider.
            </summary>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IDirectoryContents.Exists">
      <summary>
            True if a directory was located at the given path.
            </summary>
    </member>
    <member name="T:Microsoft.AspNet.FileProviders.IFileInfo">
      <summary>
            Represents a file in the given file provider.
            </summary>
    </member>
    <member name="M:Microsoft.AspNet.FileProviders.IFileInfo.CreateReadStream">
      <summary>
            Return file contents as readonly stream. Caller should dispose stream when complete.
            </summary>
      <returns>The file stream</returns>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IFileInfo.Exists">
      <summary>
            True if resource exists in the underlying storage system.
            </summary>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IFileInfo.Length">
      <summary>
            The length of the file in bytes, or -1 for a directory or non-existing files.
            </summary>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IFileInfo.PhysicalPath">
      <summary>
            The path to the file, including the file name. Return null if the file is not directly accessible.
            </summary>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IFileInfo.Name">
      <summary>
            The name of the file or directory, not including any path.
            </summary>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IFileInfo.LastModified">
      <summary>
            When the file was last modified
            </summary>
    </member>
    <member name="P:Microsoft.AspNet.FileProviders.IFileInfo.IsDirectory">
      <summary>
            True for the case TryGetDirectoryContents has enumerated a sub-directory
            </summary>
    </member>
    <member name="T:Microsoft.AspNet.FileProviders.IFileProvider">
      <summary>
            A read-only file provider abstraction.
            </summary>
    </member>
    <member name="M:Microsoft.AspNet.FileProviders.IFileProvider.GetFileInfo(System.String)">
      <summary>
            Locate a file at the given path.
            </summary>
      <param name="subpath">Relative path that identifies the file.</param>
      <returns>The file information. Caller must check Exists property.</returns>
    </member>
    <member name="M:Microsoft.AspNet.FileProviders.IFileProvider.GetDirectoryContents(System.String)">
      <summary>
            Enumerate a directory at the given path, if any.
            </summary>
      <param name="subpath">Relative path that identifies the directory.</param>
      <returns>Returns the contents of the directory.</returns>
    </member>
    <member name="M:Microsoft.AspNet.FileProviders.IFileProvider.Watch(System.String)">
      <summary>
            Creates a <see cref="T:Microsoft.Extensions.Primitives.IChangeToken" /> for the specified <paramref name="filter" />.
            </summary>
      <param name="filter">Filter string used to determine what files or folders to monitor. Example: **/*.cs, *.*, subFolder/**/*.cshtml.</param>
      <returns>An <see cref="T:Microsoft.Extensions.Primitives.IChangeToken" /> that is notified when a file matching <paramref name="filter" /> is added, modified or deleted.</returns>
    </member>
    <member name="T:Microsoft.AspNet.FileProviders.NotFoundFileInfo">
      <summary>
            Represents a non-existing file.
            </summary>
    </member>
    <member name="T:Microsoft.Extensions.Primitives.IChangeToken">
      <summary>
            Propagates notifications that a change has occured.
            </summary>
    </member>
    <member name="M:Microsoft.Extensions.Primitives.IChangeToken.RegisterChangeCallback(System.Action{System.Object},System.Object)">
      <summary>
            Registers for a callback that will be invoked when the entry has changed.
            <see cref="P:Microsoft.Extensions.Primitives.IChangeToken.HasChanged" /> MUST be set before the callback is invoked.
            </summary>
      <param name="callback">The <see cref="!:Action&lt;object&gt;" /> to invoke.</param>
      <param name="state">State to be passed into the callback.</param>
      <returns>An <see cref="T:System.IDisposable" /> that is used to unregister the callback.</returns>
    </member>
    <member name="P:Microsoft.Extensions.Primitives.IChangeToken.HasChanged">
      <summary>
            Gets a value that indicates if a change has occured.
            </summary>
    </member>
    <member name="P:Microsoft.Extensions.Primitives.IChangeToken.ActiveChangeCallbacks">
      <summary>
            Indicates if this token will pro-actively raise callbacks. Callbacks are still guaranteed to fire, eventually.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Commands330599.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Commands330599.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Commands330599.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Commands330599.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Commands330599.HashCodeCombiner.GetHashCode``2(``0,``1)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Commands330599.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Commands330599.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
      <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
    </member>
    <member name="M:NuGet.Shared.NuGet.Commands330599.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
    </member>
    <member name="T:NuGet.Commands.DeleteRunner">
      <summary>
            Shared code to run the "delete" command from the command line projects
            </summary>
    </member>
    <member name="T:NuGet.Commands.LocalsCommandRunner">
      <summary>
            Command Runner used to run the business logic for nuget locals command
            </summary>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ExecuteCommand(NuGet.Commands.LocalsArgs)">
      <summary>
            Executes the logic for nuget locals command.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ListLocalResource(NuGet.Commands.LocalsCommandRunner.LocalResourceName,NuGet.Commands.LocalsArgs)">
      <summary>
            Lists out the cache location(s) path.
            </summary>
      <param name="localResourceName">Cache resource to be listed</param>
      <throws>Thorws <code>ArgumentException</code> if the specified resource name does not match a known cache type.</throws>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.PrintLocalResourcePath(System.String,System.String,NuGet.Commands.LocalsArgs)">
      <summary>
            Prints the specified local resource path.
            </summary>
      <param name="resourceName"> Specified resource name</param>
      <param name="path"> Path for the specified resource</param>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ClearLocalResource(NuGet.Commands.LocalsCommandRunner.LocalResourceName,NuGet.Commands.LocalsArgs)">
      <summary>
            Clears the specified cache location(s).
            </summary>
      <param name="localResourceName">
      </param>
      <throws>Thorws <code>ArgumentException</code> if the specified resource name does not match a known cache type.</throws>
      <returns>
        <code>True</code> if the operation was successful; otherwise <code>false</code>.</returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ClearNuGetPluginsCache(NuGet.Commands.LocalsArgs)">
      <summary>
            Clears the NuGet plugins cache.
            </summary>
      <returns>
        <code>True</code> if the operation was successful; otherwise <code>false</code>.</returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ClearNuGetGlobalPackagesFolder(NuGet.Commands.LocalsArgs)">
      <summary>
            Clears the global NuGet packages cache.
            </summary>
      <returns>
        <code>True</code> if the operation was successful; otherwise <code>false</code>.</returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ClearNuGetHttpCache(NuGet.Commands.LocalsArgs)">
      <summary>
            Clears the NuGet v3 HTTP cache.
            </summary>
      <returns>
        <code>True</code> if the operation was successful; otherwise <code>false</code>.</returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ClearNuGetTempFolder(NuGet.Commands.LocalsArgs)">
      <summary>
            Clears the temp folder cache.
            </summary>
      <returns>
        <code>True</code> if the operation was successful; otherwise <code>false</code>.</returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.GetLocalResourceName(System.String)">
      <summary>
            Identifies the specified resource name to be cleared.
            </summary>
      <param name="localResourceName">specified resource name</param>
      <returns>Returns <code>LocalResourceName</code> indicating the local resource name specified.</returns>
    </member>
    <member name="M:NuGet.Commands.LocalsCommandRunner.ClearCacheDirectory(System.String,NuGet.Commands.LocalsArgs)">
      <summary>
            Recursively deletes the specified directory tree.
            </summary>
      <param name="folderPath">Specified directory to be deleted</param>
      <returns>
        <code>True</code> if the operation was successful; otherwise <code>false</code>.</returns>
    </member>
    <member name="M:NuGet.Commands.PackCommandRunner.WriteResolvedNuSpecToPackageOutputDirectory(NuGet.Packaging.PackageBuilder)">
      <summary>
            Writes the resolved NuSpec file to the package output directory.
            </summary>
      <param name="builder">The package builder</param>
    </member>
    <member name="M:NuGet.Commands.PackCommandRunner.WriteSHA512PackageHash(NuGet.Packaging.PackageBuilder)">
      <summary>
            Writes the sha512 package hash file to the package output directory
            </summary>
      <param name="builder">The package builder</param>
    </member>
    <member name="T:NuGet.Commands.PushRunner">
      <summary>
            Shared code to run the "push" command from the command line projects
            </summary>
    </member>
    <member name="T:NuGet.Commands.ListCommandRunner">
      <summary>
            Command Runner used to run the business logic for nuget list command
            </summary>
    </member>
    <member name="M:NuGet.Commands.ListCommandRunner.ExecuteCommand(NuGet.Commands.ListArgs)">
      <summary>
            Executes the logic for nuget list command.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NuGet.Commands.OutputLibFile.FinalOutputPath">
      <summary>
            This is the final output path of the assembly on disk as set by msbuild.
            </summary>
    </member>
    <member name="P:NuGet.Commands.OutputLibFile.TargetPath">
      <summary>
            This denotes the TargetPath as set by msbuild. Usually this is just the file name, but for satellite DLLs,
            this is Culture\filename.
             </summary>
    </member>
    <member name="P:NuGet.Commands.OutputLibFile.TargetFramework">
      <summary>
            This is the target framework for which this assembly was built.
            </summary>
    </member>
    <member name="M:NuGet.Commands.PackCollectorLogger.UpgradeWarningToErrorIfNeeded(NuGet.Common.ILogMessage)">
      <summary>
            This method upgrades the warning to an error if the project wide warning properties have set the code in WarningsAsErrors or
            set TreatWarningsAsErrors to true
            </summary>
      <param name="message">ILogMessage to be logged as an error or warning.</param>
      <returns>bool indicating if the message should be suppressed.</returns>
    </member>
    <member name="M:NuGet.Commands.PackCollectorLogger.DisplayMessage(NuGet.Common.ILogMessage)">
      <summary>
            Decides if the log should be passed to the inner logger.
            </summary>
      <param name="message">ILogMessage to be logged.</param>
      <returns>bool indicating if this message should be logged.</returns>
    </member>
    <member name="M:NuGet.Commands.CompatibilityChecker.GetErrorMessage(NuGet.Common.NuGetLogCode,NuGet.Commands.CompatibilityIssue,NuGet.Commands.RestoreTargetGraph)">
      <summary>
            Create an error message for the given issue.
            </summary>
    </member>
    <member name="M:NuGet.Commands.CompatibilityChecker.HasCompatibleAssets(NuGet.ProjectModel.LockFileTargetLibrary)">
      <summary>
            Check if the library contains assets.
            </summary>
    </member>
    <member name="M:NuGet.Commands.CompatibilityIssue.FormatMessage(System.String,System.String,System.String)">
      <summary>
            Build a incompatible error message for either a package or project
            </summary>
    </member>
    <member name="M:NuGet.Commands.ContentFileUtils.GetContentGroupsForFramework(NuGet.ProjectModel.LockFileTargetLibrary,NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.ContentModel.ContentItemGroup})">
      <summary>
            Get all content groups that have the nearest TxM
            </summary>
    </member>
    <member name="M:NuGet.Commands.ContentFileUtils.GetContentFileGroup(NuGet.Frameworks.NuGetFramework,NuGet.Packaging.NuspecReader,System.Collections.Generic.List{NuGet.ContentModel.ContentItemGroup})">
      <summary>
            Apply build actions from the nuspec to items from the contentFiles folder.
            </summary>
    </member>
    <member name="M:NuGet.Commands.ContentFileUtils.CreateEmptyItem">
      <summary>
            Create an empty lock file item for any/any
            </summary>
    </member>
    <member name="T:NuGet.Commands.VirtualFileProvider">
      <summary>
            A virtual file system based on a list of strings from ContentModel.
            </summary>
    </member>
    <member name="T:NuGet.Commands.DiagnosticUtility">
      <summary>
            Warning and error logging helpers.
            </summary>
    </member>
    <member name="M:NuGet.Commands.DiagnosticUtility.FormatIdentity(NuGet.LibraryModel.LibraryIdentity)">
      <summary>
            Format an id and include the version only if it exists.
            Ignore versions for projects.
            </summary>
    </member>
    <member name="M:NuGet.Commands.DiagnosticUtility.FormatDependency(System.String,NuGet.Versioning.VersionRange)">
      <summary>
            Format an id and include the range only if it has bounds.
            </summary>
    </member>
    <member name="M:NuGet.Commands.DiagnosticUtility.FormatExpectedIdentity(System.String,NuGet.Versioning.VersionRange)">
      <summary>
            Format an id and include the lower bound only if it has one.
            </summary>
    </member>
    <member name="M:NuGet.Commands.DiagnosticUtility.FormatGraphName(NuGet.Commands.RestoreTargetGraph)">
      <summary>
            Format a graph name with an optional RID.
            </summary>
    </member>
    <member name="M:NuGet.Commands.DiagnosticUtility.GetMultiLineMessage(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Format a message as:
            
            First line
              - second
              - third
            </summary>
    </member>
    <member name="M:NuGet.Commands.DiagnosticUtility.MergeOnTargetGraph(System.Collections.Generic.IEnumerable{NuGet.Common.RestoreLogMessage})">
      <summary>
            Merge messages with the same code and message, combining the target graphs.
            </summary>
    </member>
    <member name="T:NuGet.Commands.IndexedRestoreTargetGraph">
      <summary>
            Contains a RestoreTargetGraph with the flattened graph indexed on id.
            </summary>
    </member>
    <member name="M:NuGet.Commands.IndexedRestoreTargetGraph.GetItemById(System.String)">
      <summary>
            Returns the item or null if the id does not exist.
            </summary>
    </member>
    <member name="M:NuGet.Commands.IndexedRestoreTargetGraph.GetItemById(System.String,NuGet.LibraryModel.LibraryType)">
      <summary>
            Returns the item or null if the id does not exist or does not match the type.
            </summary>
    </member>
    <member name="M:NuGet.Commands.IndexedRestoreTargetGraph.HasErrors(System.String)">
      <summary>
            True if an id has a conflict or cycle error associated with it.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IndexedRestoreTargetGraph.Graph">
      <summary>
            RestoreTargetGraph
            </summary>
    </member>
    <member name="T:NuGet.Commands.UnexpectedDependencyMessages">
      <summary>
            Log warnings for packages that did not resolve to the minimum version of the dependency range.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnexpectedDependencyMessages.LogAsync(System.Collections.Generic.IEnumerable{NuGet.Commands.IRestoreTargetGraph},NuGet.ProjectModel.PackageSpec,NuGet.Common.ILogger)">
      <summary>
            Log warnings for all project issues related to unexpected dependencies.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnexpectedDependencyMessages.GetMissingLowerBounds(System.Collections.Generic.IEnumerable{NuGet.Commands.IRestoreTargetGraph},System.Collections.Generic.ISet{System.String})">
      <summary>
            Get warnings for packages that have dependencies on non-existant versions of packages
            and also for packages with ranges that have missing minimum versions.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnexpectedDependencyMessages.GetMissingLowerBoundMessage(NuGet.Commands.ResolvedDependencyKey,System.String[])">
      <summary>
            Get warning message for missing minimum dependencies.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnexpectedDependencyMessages.GetBumpedUpDependencies(System.Collections.Generic.List{NuGet.Commands.IndexedRestoreTargetGraph},NuGet.ProjectModel.PackageSpec,System.Collections.Generic.ISet{System.String})">
      <summary>
            Warn for dependencies that have been bumped up.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnexpectedDependencyMessages.GetProjectDependenciesMissingLowerBounds(NuGet.ProjectModel.PackageSpec)">
      <summary>
            Warn for project dependencies that do not include a lower bound on the version range.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnexpectedDependencyMessages.DependencyRangeHasMissingExactMatch(NuGet.Commands.ResolvedDependencyKey)">
      <summary>
            True if the dependency version range has a min version that matches the resolved version.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnexpectedDependencyMessages.HasMissingLowerBound(NuGet.Versioning.VersionRange)">
      <summary>
            True if the range has an obtainable version for the lower bound.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnexpectedDependencyMessages.GetDependenciesAboveUpperBounds(System.Collections.Generic.List{NuGet.Commands.IndexedRestoreTargetGraph},NuGet.Common.ILogger)">
      <summary>
            Log upgrade warnings from the graphs.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnexpectedDependencyMessages.GetDependencyTargetGraphs(NuGet.ProjectModel.PackageSpec,NuGet.LibraryModel.LibraryDependency)">
      <summary>
            Create target graph names for each framework the dependency exists under.
            </summary>
    </member>
    <member name="T:NuGet.Commands.UnresolvedMessages">
      <summary>
            Log errors for packages and projects that were missing.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnresolvedMessages.LogAsync(System.Collections.Generic.IEnumerable{NuGet.Commands.IRestoreTargetGraph},NuGet.DependencyResolver.RemoteWalkContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Log errors for missing dependencies.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnresolvedMessages.GetMessageAsync(NuGet.Commands.IRestoreTargetGraph,NuGet.LibraryModel.LibraryRange,NuGet.DependencyResolver.RemoteWalkContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Create a specific error message for the unresolved dependency.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnresolvedMessages.HasPrereleaseVersionsOnly(NuGet.Versioning.VersionRange,System.Collections.Generic.IEnumerable{NuGet.Versioning.NuGetVersion})">
      <summary>
            True if no stable versions satisfy the range 
            but a pre-release version is found.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnresolvedMessages.IsPrereleaseAllowed(NuGet.Versioning.VersionRange)">
      <summary>
            True if the range allows pre-release versions.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnresolvedMessages.FormatSourceInfo(System.Collections.Generic.KeyValuePair{NuGet.Configuration.PackageSource,System.Collections.Generic.SortedSet{NuGet.Versioning.NuGetVersion}},NuGet.Versioning.VersionRange)">
      <summary>
            Found 2839 version(s) in nuget-build [ Nearest version: 1.0.0-beta ]
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnresolvedMessages.GetSourceInfosForIdAsync(System.String,NuGet.Versioning.VersionRange,NuGet.DependencyResolver.RemoteWalkContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Get the complete set of source info for a package id.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnresolvedMessages.GetSourceInfoForIdAsync(NuGet.DependencyResolver.IRemoteDependencyProvider,System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Find all package versions from a source.
            </summary>
    </member>
    <member name="M:NuGet.Commands.UnresolvedMessages.GetBestMatch(System.Collections.Generic.SortedSet{NuGet.Versioning.NuGetVersion},NuGet.Versioning.VersionRange)">
      <summary>
            Find the best match on the feed.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreResult.LockFilePath">
      <summary>
            Gets the path that the lock file will be written to.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreResult.LockFile">
      <summary>
            Gets the lock file that was generated during the restore or, in the case of a locked lock file,
            was used to determine the packages to install during the restore.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreResult.PreviousLockFile">
      <summary>
            The existing lock file. This is null if no lock file was provided on the <see cref="T:NuGet.Commands.RestoreRequest" />.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreResult.MSBuildOutputFiles">
      <summary>
            Props and targets files to be written to disk.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreTargetGraph.RuntimeIdentifier">
      <summary>
            Gets the runtime identifier used during the restore operation on this graph
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreTargetGraph.Framework">
      <summary>
            Gets the <see cref="T:NuGet.Frameworks.NuGetFramework" /> used during the restore operation on this graph
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreTargetGraph.Conventions">
      <summary>
            Gets the <see cref="T:NuGet.Client.ManagedCodeConventions" /> used to resolve assets from packages in this graph
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreTargetGraph.RuntimeGraph">
      <summary>
            Gets the <see cref="P:NuGet.Commands.IRestoreTargetGraph.RuntimeGraph" /> that defines runtimes and their relationships for this graph
            </summary>
    </member>
    <member name="P:NuGet.Commands.IRestoreTargetGraph.Graphs">
      <summary>
            Gets the resolved dependency graph
            </summary>
    </member>
    <member name="T:NuGet.Commands.LockFileBuilderCache">
      <summary>
            Cache objects used for building the lock file.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileBuilderCache.GetSelectionCriteria(NuGet.Commands.RestoreTargetGraph,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Get ordered selection criteria.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileBuilderCache.GetContentItems(NuGet.ProjectModel.LockFileLibrary,NuGet.Repositories.LocalPackageInfo)">
      <summary>
            Get a ContentItemCollection of the package files.
            </summary>
      <remarks>Library is optional.</remarks>
    </member>
    <member name="T:NuGet.Commands.PackageSpecificWarningProperties">
      <summary>
            Contains Package specific properties for Warnings.
            </summary>
    </member>
    <member name="M:NuGet.Commands.PackageSpecificWarningProperties.CreatePackageSpecificWarningProperties(NuGet.ProjectModel.PackageSpec)">
      <summary>
            Extracts PackageSpecific WarningProperties from a PackageSpec
            </summary>
      <param name="packageSpec">PackageSpec containing the Dependencies with WarningProperties</param>
      <returns>PackageSpecific WarningProperties extracted from a PackageSpec</returns>
    </member>
    <member name="M:NuGet.Commands.PackageSpecificWarningProperties.CreatePackageSpecificWarningProperties(NuGet.ProjectModel.PackageSpec,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Extracts PackageSpecific WarningProperties from a PackageSpec for a specific NuGetFramework
            </summary>
      <param name="packageSpec">PackageSpec containing the Dependencies with WarningProperties</param>
      <param name="framework">NuGetFramework for which the properties should be assessed.</param>
      <returns>PackageSpecific WarningProperties extracted from a PackageSpec for a specific NuGetFramework</returns>
    </member>
    <member name="M:NuGet.Commands.PackageSpecificWarningProperties.Add(NuGet.Common.NuGetLogCode,System.String,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Adds a NuGetLogCode into the NoWarn Set for the specified library Id and target graph.
            </summary>
      <param name="code">NuGetLogCode for which no warning should be thrown.</param>
      <param name="libraryId">Library for which no warning should be thrown.</param>
      <param name="framework">Target graph for which no warning should be thrown.</param>
    </member>
    <member name="M:NuGet.Commands.PackageSpecificWarningProperties.AddRangeOfCodes(System.Collections.Generic.IEnumerable{NuGet.Common.NuGetLogCode},System.String,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Adds a list of NuGetLogCode into the NoWarn Set for the specified library Id and target graph.
            </summary>
      <param name="codes">IEnumerable of NuGetLogCode for which no warning should be thrown.</param>
      <param name="libraryId">Library for which no warning should be thrown.</param>
      <param name="framework">Target graph for which no warning should be thrown.</param>
    </member>
    <member name="M:NuGet.Commands.PackageSpecificWarningProperties.AddRangeOfFrameworks(NuGet.Common.NuGetLogCode,System.String,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Adds a list of NuGetLogCode into the NoWarn Set for the specified library Id and target graph.
            </summary>
      <param name="code">NuGetLogCode for which no warning should be thrown.</param>
      <param name="libraryId">Library for which no warning should be thrown.</param>
      <param name="frameworks">IEnumerable of Target graph for which no warning should be thrown.</param>
    </member>
    <member name="M:NuGet.Commands.PackageSpecificWarningProperties.Contains(NuGet.Common.NuGetLogCode,System.String,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Checks if a NugetLogCode is part of the NoWarn list for the specified library Id and target graph.
            </summary>
      <param name="code">NugetLogCode to be checked.</param>
      <param name="libraryId">library Id to be checked.</param>
      <param name="framework">target graph to be checked.</param>
      <returns>True iff the NugetLogCode is part of the NoWarn list for the specified libraryId and Target Graph.</returns>
    </member>
    <member name="P:NuGet.Commands.PackageSpecificWarningProperties.Properties">
      <summary>
            Contains Package specific No warn properties.
            NuGetLogCode -&gt; LibraryId -&gt; Set of Frameworks.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreCollectorLogger.ApplyRestoreInputs(NuGet.ProjectModel.PackageSpec)">
      <summary>
            Stores a reference to PackageSpec for the project from the restore request.
            This are used to generate the warning properties for the project.
            </summary>
      <param name="projectSpec">PackageSpec to be stored for reference.</param>
    </member>
    <member name="M:NuGet.Commands.RestoreCollectorLogger.ApplyRestoreOutput(System.Collections.Generic.IEnumerable{NuGet.Commands.RestoreTargetGraph})">
      <summary>
            Stores a reference to RestoreTargetGraphs from the restore output.
            These graphs are used to generate the transitive warning properties.
            </summary>
      <param name="restoreTargetGraphs">RestoreTargetGraphs to be stored for reference.</param>
    </member>
    <member name="M:NuGet.Commands.RestoreCollectorLogger.#ctor(NuGet.Common.ILogger,NuGet.Common.LogLevel,System.Boolean)">
      <summary>
            Initializes an instance of the <see cref="T:NuGet.Commands.RestoreCollectorLogger" />, while still
            delegating all log messages to the inner logger.
            </summary>
      <param name="innerLogger">The inner logger used to delegate the logging.</param>
      <param name="verbosity">Minimum verbosity below which no logs will be passed to the inner logger.</param>
      <param name="hideWarningsAndErrors">If this is true, then errors and warnings will not be passed to inner logger.</param>
    </member>
    <member name="M:NuGet.Commands.RestoreCollectorLogger.#ctor(NuGet.Common.ILogger,System.Boolean)">
      <summary>
            Initializes an instance of the <see cref="T:NuGet.Commands.RestoreCollectorLogger" />, while still
            delegating all log messages to the inner logger.
            </summary>
      <param name="innerLogger">The inner logger used to delegate the logging.</param>
      <param name="hideWarningsAndErrors">If this is false, then errors and warnings will not be passed to inner logger.</param>
    </member>
    <member name="M:NuGet.Commands.RestoreCollectorLogger.#ctor(NuGet.Common.ILogger,NuGet.Common.LogLevel)">
      <summary>
            Initializes an instance of the <see cref="T:NuGet.Commands.RestoreCollectorLogger" />, while still
            delegating all log messages to the inner logger.
            </summary>
      <param name="innerLogger">The inner logger used to delegate the logging.</param>
      <param name="verbosity">Minimum verbosity below which no logs will be passed to the inner logger.</param>
    </member>
    <member name="M:NuGet.Commands.RestoreCollectorLogger.#ctor(NuGet.Common.ILogger)">
      <summary>
            Initializes an instance of the <see cref="T:NuGet.Commands.RestoreCollectorLogger" />, while still
            delegating all log messages to the inner logger.
            </summary>
      <param name="innerLogger">The inner logger used to delegate the logging.</param>
    </member>
    <member name="M:NuGet.Commands.RestoreCollectorLogger.DisplayMessage(NuGet.Common.IRestoreLogMessage)">
      <summary>
            Decides if the log should be passed to the inner logger.
            </summary>
      <param name="message">IRestoreLogMessage to be logged.</param>
      <returns>bool indicating if this message should be logged.</returns>
    </member>
    <member name="M:NuGet.Commands.RestoreCollectorLogger.IsWarningSuppressed(NuGet.Common.IRestoreLogMessage)">
      <summary>
            This method checks if at least one of the warning properties collections is not null and it suppresses the warning.
            </summary>
      <param name="message">IRestoreLogMessage to be logged.</param>
      <returns>bool indicating if the message should be suppressed.</returns>
    </member>
    <member name="M:NuGet.Commands.RestoreCollectorLogger.UpgradeWarningToErrorIfNeeded(NuGet.Common.IRestoreLogMessage)">
      <summary>
            This method upgrades the warning to an error if the project wide warning properties have set the code in WarningsAsErrors or
            set TreatWarningsAsErrors to true
            </summary>
      <param name="message">IRestoreLogMessage to be logged as an error or warning.</param>
      <returns>bool indicating if the message should be suppressed.</returns>
    </member>
    <member name="T:NuGet.Commands.TransitiveNoWarnUtils.DependencyNode">
      <summary>
            A simple node class to hold the outgoing dependency edge during the graph walk.
            </summary>
    </member>
    <member name="T:NuGet.Commands.TransitiveNoWarnUtils.LookUpNode">
      <summary>
            A simple node class to hold the outgoing dependency edges for a quick look up.
            </summary>
    </member>
    <member name="T:NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties">
      <summary>
            A class to hold minimal version of project wide nowarn and package specific no warn for a project.
            </summary>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties.IsSubSetOf(NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties)">
      <summary>
            True if the given set is a subset of this set, or equal to it.
            </summary>
      <remarks>Null is considered an empty set, and will return true.</remarks>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.CreateTransitiveWarningPropertiesCollection(System.Collections.Generic.IEnumerable{NuGet.Commands.RestoreTargetGraph},NuGet.ProjectModel.PackageSpec)">
      <summary>
            Creates a PackageSpecificWarningProperties for a project generated by traversing the dependency graph.
            </summary>
      <param name="targetGraphs">Parent project restore target graphs.</param>
      <param name="parentProjectSpec">PackageSpec of the parent project.</param>
      <returns>WarningPropertiesCollection with the project frameworks and the transitive package specific no warn properties.</returns>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.ExtractTransitiveNoWarnProperties(NuGet.Commands.RestoreTargetGraph,System.String,System.Collections.Generic.HashSet{NuGet.Common.NuGetLogCode},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.HashSet{NuGet.Common.NuGetLogCode}},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.Dictionary{NuGet.Frameworks.NuGetFramework,NuGet.Commands.WarningPropertiesCollection}})">
      <summary>
            Traverses a Dependency grpah starting from the parent project in BF style.
            </summary>
      <param name="targetGraph">Parent project restore target graph.</param>
      <param name="parentProjectName">File path of the parent project.</param>
      <param name="parentProjectWideNoWarn">Project Wide NoWarn properties of the parent project.</param>
      <param name="parentPackageSpecificNoWarn">Package Specific NoWarn properties of the parent project.</param>
      <returns>PackageSpecificWarningProperties containing all the NoWarn's for each package seen in the graph accumulated while traversing the graph.</returns>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.AddToSeen(System.Collections.Generic.Dictionary{System.String,NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties},NuGet.Commands.TransitiveNoWarnUtils.DependencyNode)">
      <summary>
            Add to the seen list for tracking.
            </summary>
      <returns>True if the node should be walked</returns>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.ExtractPathNoWarnProperties(NuGet.Commands.TransitiveNoWarnUtils.NodeWarningProperties,System.String)">
      <summary>
            Extracts the no warn  codes for a libraryId from the warning properties at the node in the graph.
            </summary>
      <param name="nodeWarningProperties">warning properties at the node in the graph.</param>
      <param name="libraryId">libraryId for which the no warn codes have to be extracted.</param>
      <returns>HashSet of NuGetLogCodes containing the no warn codes for the libraryId.</returns>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.MergeCodes(System.Collections.Generic.HashSet{NuGet.Common.NuGetLogCode},System.Collections.Generic.HashSet{NuGet.Common.NuGetLogCode})">
      <summary>
            Merge 2 WarningProperties objects.
            This method will combine the warning properties from both the collections.
            </summary>
      <param name="first">First Object to be merged.</param>
      <param name="second">Second Object to be merged.</param>
      <returns>Returns a WarningProperties with the combined warning properties.
            Returns the reference to one of the inputs if the other input is Null.
            Returns a Null if both the input properties are Null. </returns>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.MergePackageSpecificNoWarn(System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.HashSet{NuGet.Common.NuGetLogCode}},System.Collections.Generic.Dictionary{System.String,System.Collections.Generic.HashSet{NuGet.Common.NuGetLogCode}})">
      <summary>
            Merge 2 PackageSpecific NoWarns.
            This method will combine the warning properties from both the collections.
            </summary>
      <param name="first">First Object to be merged.</param>
      <param name="second">Second Object to be merged.</param>
      <returns>Returns a PackageSpecificWarningProperties with the combined warning properties.
            Will return the reference to one of the inputs if the other input is Null.
            Returns a Null if both the input properties are Null. </returns>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.MergePackageSpecificWarningProperties(NuGet.Commands.PackageSpecificWarningProperties,NuGet.Commands.PackageSpecificWarningProperties)">
      <summary>
            Merge 2 PackageSpecificWarningProperties objects.
            This method will combine the warning properties from both the collections.
            </summary>
      <param name="first">First Object to be merged.</param>
      <param name="second">Second Object to be merged.</param>
      <returns>Returns a PackageSpecificWarningProperties with the combined warning properties.
            Will return the reference to one of the inputs if the other input is Null.
            Returns a Null if both the input properties are Null. </returns>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.TryMergeNullObjects``1(``0,``0,``0@)">
      <summary>
            Try to merge 2 objects if one or both of them are null.
            </summary>
      <param name="first">First Object to be merged.</param>
      <param name="second">Second Object to be merged.</param>
      <param name="merged">Out Merged Object.</param>
      <returns>Returns true if atleast one of the objects was Null. 
            If none of them is null then the returns false, indicating that the merge failed.</returns>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.IsProject(NuGet.LibraryModel.LibraryDependencyTarget)">
      <summary>
            Checks if a LibraryDependencyTarget is a project.
            </summary>
      <param name="type">LibraryDependencyTarget to be checked.</param>
      <returns>True if a LibraryDependencyTarget is Project or ExternalProject.</returns>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.IsProject(NuGet.LibraryModel.LibraryType)">
      <summary>
            Checks if a LibraryType is a project.
            </summary>
      <param name="type">LibraryType to be checked.</param>
      <returns>True if a LibraryType is Project or ExternalProject.</returns>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.ExtractPackageSpecificNoWarnPerFramework(NuGet.Commands.PackageSpecificWarningProperties)">
      <summary>
            Indexes a PackageSpecificWarningProperties collection on framework.
            </summary>
      <param name="packageSpecificWarningProperties">PackageSpecificWarningProperties to be converted.</param>
      <returns>New dictionary containing the data of a PackageSpecificWarningProperties collection on framework.</returns>
    </member>
    <member name="M:NuGet.Commands.TransitiveNoWarnUtils.ExtractPackageSpecificNoWarnForFramework(NuGet.Commands.PackageSpecificWarningProperties,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Indexes a PackageSpecificWarningProperties collection on framework.
            </summary>
      <param name="packageSpecificWarningProperties">PackageSpecificWarningProperties to be converted.</param>
      <returns>New dictionary containing the data of a PackageSpecificWarningProperties collection on framework.</returns>
    </member>
    <member name="T:NuGet.Commands.WarningPropertiesCollection">
      <summary>
            Class to hold ProjectWide and PackageSpecific WarningProperties.
            </summary>
    </member>
    <member name="M:NuGet.Commands.WarningPropertiesCollection.ApplyWarningProperties(NuGet.Common.IRestoreLogMessage)">
      <summary>
            Attempts to suppress a warning log message or upgrade it to error log message.
            The decision is made based on the Package Specific or Project wide warning properties.
            </summary>
      <param name="message">Message that should be suppressed or upgraded to an error.</param>
      <returns>Bool indicating is the warning should be suppressed or not. 
            If not then the param message sould have been mutated to an error</returns>
    </member>
    <member name="M:NuGet.Commands.WarningPropertiesCollection.ApplyNoWarnProperties(NuGet.Common.IRestoreLogMessage)">
      <summary>
            Attempts to suppress a warning log message.
            The decision is made based on the Package Specific or Project wide no warn properties.
            </summary>
      <param name="message">Message that should be suppressed.</param>
      <returns>Bool indicating is the warning should be suppressed or not.</returns>
    </member>
    <member name="M:NuGet.Commands.WarningPropertiesCollection.ApplyWarningAsErrorProperties(NuGet.Common.IRestoreLogMessage)">
      <summary>
            Method is used to upgrade a warning to an error if needed.
            </summary>
      <param name="message">Message which should be upgraded to error if needed.</param>
    </member>
    <member name="M:NuGet.Commands.WarningPropertiesCollection.ApplyPackageSpecificNoWarnProperties(NuGet.Common.IRestoreLogMessage)">
      <summary>
            Method is used to check is a warning should be suppressed due to package specific no warn properties.
            </summary>
      <param name="message">Message to be checked for no warn.</param>
      <returns>bool indicating if the IRestoreLogMessage should be suppressed or not.</returns>
    </member>
    <member name="M:NuGet.Commands.WarningPropertiesCollection.ApplyProjectWideNoWarnProperties(NuGet.Common.ILogMessage,NuGet.ProjectModel.WarningProperties)">
      <summary>
            Method is used to check is a warning should be suppressed due to project wide no warn properties.
            </summary>
      <param name="message">Message to be checked for no warn.</param>
      <returns>bool indicating if the ILogMessage should be suppressed or not.</returns>
    </member>
    <member name="M:NuGet.Commands.WarningPropertiesCollection.ApplyProjectWideWarningsAsErrorProperties(NuGet.Common.ILogMessage,NuGet.ProjectModel.WarningProperties)">
      <summary>
            Method is used to check is a warning should be treated as an error.
            </summary>
      <param name="message">Message which should be upgraded to error if needed.</param>
    </member>
    <member name="P:NuGet.Commands.WarningPropertiesCollection.ProjectFrameworks">
      <summary>
            Contains the target frameworks for the project.
            These are used for no warn filtering in case of a log message without a target graph.
            </summary>
    </member>
    <member name="P:NuGet.Commands.WarningPropertiesCollection.ProjectWideWarningProperties">
      <summary>
            Contains Project wide properties for Warnings.
            </summary>
    </member>
    <member name="P:NuGet.Commands.WarningPropertiesCollection.PackageSpecificWarningProperties">
      <summary>
            Contains Package specific properties for Warnings.
            NuGetLogCode -&gt; LibraryId -&gt; Set of Frameworks.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildOutputFile.Path">
      <summary>
            Output path on disk.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildOutputFile.Content">
      <summary>
            MSBuild file content. This will be null for files
            that should be removed.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildRestoreItemGroup.Position">
      <summary>
            Optional position arguement used when ordering groups in the output file.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildRestoreItemGroup.Conditions">
      <summary>
            Conditions applied to the item group. These will be AND'd together.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildRestoreItemGroup.Items">
      <summary>
            Items or imports.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildRestoreItemGroup.RootName">
      <summary>
            Root element name.
            </summary>
    </member>
    <member name="P:NuGet.Commands.MSBuildRestoreItemGroup.Condition">
      <summary>
            Combined conditions
            </summary>
    </member>
    <member name="M:NuGet.Commands.ProjectRestoreCommand.GetRuntimeGraph(NuGet.Commands.RestoreTargetGraph,System.Collections.Generic.IReadOnlyList{NuGet.Repositories.NuGetv3LocalRepository})">
      <summary>
            Merge all runtime.json found in the flattened graph.
            </summary>
    </member>
    <member name="T:NuGet.Commands.DependencyGraphSpecRequestProvider">
      <summary>
            In Memory dg file provider.
            </summary>
    </member>
    <member name="M:NuGet.Commands.DependencyGraphSpecRequestProvider.CollectReferences(NuGet.ProjectModel.ExternalProjectReference,System.Collections.Generic.Dictionary{System.String,NuGet.ProjectModel.ExternalProjectReference},System.Collections.Generic.HashSet{NuGet.ProjectModel.ExternalProjectReference})">
      <summary>
            Return all references for a given project path.
            References is modified by this method.
            This includes the root project.
            </summary>
    </member>
    <member name="T:NuGet.Commands.IMSBuildItem">
      <summary>
            ITaskItem abstraction
            </summary>
    </member>
    <member name="M:NuGet.Commands.IMSBuildItem.GetProperty(System.String)">
      <summary>
            Retrieve property value and trim.
            </summary>
    </member>
    <member name="M:NuGet.Commands.IMSBuildItem.GetProperty(System.String,System.Boolean)">
      <summary>
            Retrieve property value with optional trimming.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IMSBuildItem.Identity">
      <summary>
            Include attribute value.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IMSBuildItem.Properties">
      <summary>
            Raw untrimmed properties.
            </summary>
    </member>
    <member name="T:NuGet.Commands.IPreLoadedRestoreRequestProvider">
      <summary>
            Retrieves pre-loaded restore requests. The inputs here have already been determined.
            </summary>
    </member>
    <member name="M:NuGet.Commands.IPreLoadedRestoreRequestProvider.CreateRequests(NuGet.Commands.RestoreArgs)">
      <summary>
            Create RestoreRequest objects.
            </summary>
    </member>
    <member name="M:NuGet.Commands.IRestoreRequestProvider.Supports(System.String)">
      <summary>
            True if this provider supports the given path. Only one provider should handle an input.
            </summary>
    </member>
    <member name="M:NuGet.Commands.IRestoreRequestProvider.CreateRequests(System.String,NuGet.Commands.RestoreArgs)">
      <summary>
            Create RestoreRequest objects.
            </summary>
      <param name="inputPath">Project.json or project file path.</param>
      <param name="restoreContext">Command line arguments.</param>
      <returns>
      </returns>
    </member>
    <member name="T:NuGet.Commands.MSBuildItem">
      <summary>
            Internal ITaskItem abstraction
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildItem.GetProperty(System.String)">
      <summary>
            Get property or null if empty. Trims whitespace from values.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildItem.GetProperty(System.String,System.Boolean)">
      <summary>
            Get property or null if empty.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreArgs.GetEffectiveSources(NuGet.Configuration.ISettings,System.Collections.Generic.IList{NuGet.Configuration.PackageSource})">
      <summary>
            Uses either Sources or Settings, and then adds Fallback sources.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreArgs.Sources">
      <summary>
            Sources to use for restore. This is not used if SourceRepositories contains the 
            already built SourceRepository objects.
            </summary>
    </member>
    <member name="T:NuGet.Commands.RestoreSpecException">
      <summary>
            DG v2 related validation error.
            </summary>
    </member>
    <member name="T:NuGet.Commands.ResolvedDependencyKey">
      <summary>
            ResolvedDependencyKey represents a node in the graph, the edge containing
            the dependency constraint, and the child node that was resolved based 
            on this constraint.
            
            (Parent Node) --(Range Constraint)--&gt; (Resolved Child Node)
            </summary>
    </member>
    <member name="P:NuGet.Commands.ResolvedDependencyKey.Parent">
      <summary>
            Parent node.
            </summary>
    </member>
    <member name="P:NuGet.Commands.ResolvedDependencyKey.Range">
      <summary>
            Dependency range from the parent on the child.
            </summary>
    </member>
    <member name="P:NuGet.Commands.ResolvedDependencyKey.Child">
      <summary>
            Child node.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreCommand.ValidateRestoreGraphsAsync(System.Collections.Generic.IEnumerable{NuGet.Commands.RestoreTargetGraph},NuGet.Common.ILogger)">
      <summary>
            Check if the given graphs are valid and log errors/warnings.
            If fatal errors are encountered the rest of the errors/warnings
            are not logged. This is to avoid flooding the log with long 
            dependency chains for every package.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreCommand.ValidateCyclesAsync(System.Collections.Generic.IEnumerable{NuGet.Commands.RestoreTargetGraph},NuGet.Common.ILogger)">
      <summary>
            Logs an error and returns false if any cycles exist.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreCommand.ValidateConflictsAsync(System.Collections.Generic.IEnumerable{NuGet.Commands.RestoreTargetGraph},NuGet.Common.ILogger)">
      <summary>
            Logs an error and returns false if any conflicts exist.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreCommand.LogDowngradeWarningsAsync(System.Collections.Generic.IEnumerable{NuGet.Commands.RestoreTargetGraph},NuGet.Common.ILogger)">
      <summary>
            Log downgrade warnings from the graphs.
            </summary>
    </member>
    <member name="T:NuGet.Commands.RestoreCommandException">
      <summary>
            Holds an <see cref="T:NuGet.Common.IRestoreLogMessage" /> and returns the message for the exception.
            </summary>
    </member>
    <member name="T:NuGet.Commands.RestoreCommandProviders">
      <summary>
            Feed providers
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreCommandProviders.#ctor(NuGet.Repositories.NuGetv3LocalRepository,System.Collections.Generic.IReadOnlyList{NuGet.Repositories.NuGetv3LocalRepository},System.Collections.Generic.IReadOnlyList{NuGet.DependencyResolver.IRemoteDependencyProvider},System.Collections.Generic.IReadOnlyList{NuGet.DependencyResolver.IRemoteDependencyProvider},NuGet.Protocol.LocalPackageFileCache)">
      <summary>
            Providers used by the restore command. These can be shared across restores.
            </summary>
      <param name="globalPackages">Path to the global packages folder.</param>
      <param name="fallbackPackageFolders">Path to any fallback package folders.</param>
      <param name="localProviders">This is typically just a provider for the global packages folder.</param>
      <param name="remoteProviders">All dependency providers.</param>
      <param name="packageFileCache">Nuspec and package file cache.</param>
    </member>
    <member name="P:NuGet.Commands.RestoreCommandProviders.GlobalPackages">
      <summary>
            A <see cref="T:NuGet.Repositories.NuGetv3LocalRepository" /> repository may be passed in as part of the request.
            This allows multiple restores to share the same cache for the global packages folder
            and reduce disk hits.
            </summary>
    </member>
    <member name="T:NuGet.Commands.RestoreCommandProvidersCache">
      <summary>
            Caches providers for the RestoreCommand. This helper ensures that no resources are duplicated.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.Project">
      <summary>
            The project to perform the restore on
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.PackagesDirectory">
      <summary>
            The directory in which to install packages
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.IsLowercasePackagesDirectory">
      <summary>
            Whether or not packages written and read from the global packages directory has
            lowercase ID and version folder names or original case.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.ExternalProjects">
      <summary>
            A list of projects provided by external build systems (i.e. MSBuild)
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.LockFilePath">
      <summary>
            The path to the lock file to read/write. If not specified, uses the file 'project.lock.json' in the same
            directory as the provided PackageSpec.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.ExistingLockFile">
      <summary>
            The existing lock file to use. If not specified, the lock file will be read from the <see cref="P:NuGet.Commands.RestoreRequest.LockFilePath" />
            (or, if that property is not specified, from the default location of the lock file, as specified in the
            description for <see cref="P:NuGet.Commands.RestoreRequest.LockFilePath" />)
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.MaxDegreeOfConcurrency">
      <summary>
            The number of concurrent tasks to run during installs. Defaults to
            <see cref="F:NuGet.Commands.RestoreRequest.DefaultDegreeOfConcurrency" />. Set this to '1' to
            run without concurrency.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.CompatibilityProfiles">
      <summary>
            Additional compatibility profiles to check compatibility with.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.LockFileVersion">
      <summary>
            Lock file version format to output.
            </summary>
      <remarks>This defaults to the latest version.</remarks>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.RequestedRuntimes">
      <summary>
            These Runtime Ids will be added to the graph in addition to the runtimes contained
            in project.json under runtimes.
            </summary>
      <remarks>RIDs are case sensitive.</remarks>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.PackageSaveMode">
      <summary>
            Gets or sets the <see cref="T:NuGet.Packaging.PackageSaveMode" />.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.FallbackRuntimes">
      <summary>
            These Runtime Ids will be used if <see cref="P:NuGet.Commands.RestoreRequest.RequestedRuntimes" /> and the project runtimes
            are both empty.
            </summary>
      <remarks>RIDs are case sensitive.</remarks>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.DependencyProviders">
      <summary>
            This contains resources that are shared between project restores.
            This includes both remote and local package providers.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.ProjectStyle">
      <summary>
            Defines the paths and behavior for outputs
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.RestoreOutputPath">
      <summary>
            Restore output path
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.MSBuildProjectExtensionsPath">
      <summary>
            MSBuildProjectExtensionsPath
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.ValidateRuntimeAssets">
      <summary>
            Compatibility options
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.HideWarningsAndErrors">
      <summary>
            Display Errors and warnings as they occur
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.PackageSignatureVerifier">
      <summary>
            Package Signature verifier
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreRequest.SignedPackageVerifierSettings">
      <summary>
            SignedPackageVerifierSettings to be used when verifying signed packages.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreResult.GetAllInstalled">
      <summary>
            Calculates the complete set of all packages installed by this operation
            </summary>
      <remarks>
            This requires quite a bit of iterating over the graph so the result should be cached
            </remarks>
      <returns>A set of libraries that were installed by this operation</returns>
    </member>
    <member name="M:NuGet.Commands.RestoreResult.GetAllUnresolved">
      <summary>
            Calculates the complete set of all unresolved dependencies for this operation
            </summary>
      <remarks>
            This requires quite a bit of iterating over the graph so the result should be cached
            </remarks>
      <returns>A set of dependencies that were unable to be resolved by this operation</returns>
    </member>
    <member name="M:NuGet.Commands.RestoreResult.CommitAsync(NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Commits the lock file contained in <see cref="P:NuGet.Commands.RestoreResult.LockFile" /> and the MSBuild targets/props to
            the local file system.
            </summary>
      <remarks>If <see cref="P:NuGet.Commands.RestoreResult.PreviousLockFile" /> and <see cref="P:NuGet.Commands.RestoreResult.LockFile" /> are identical
             the file will not be written to disk.</remarks>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.LockFilePath">
      <summary>
            Gets the path that the lock file will be written to.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.RestoreGraphs">
      <summary>
            Gets the resolved dependency graphs produced by the restore operation
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.MSBuildOutputFiles">
      <summary>
            Props and targets files to be written to disk.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.ProjectStyle">
      <summary>
            Restore type.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.LockFile">
      <summary>
            Gets the lock file that was generated during the restore or, in the case of a locked lock file,
            was used to determine the packages to install during the restore.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.PreviousLockFile">
      <summary>
            The existing lock file. This is null if no lock file was provided on the <see cref="T:NuGet.Commands.RestoreRequest" />.
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.ElapsedTime">
      <summary>
            Restore time
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.CacheFile">
      <summary>
             Cache File. The previous cache file for this project
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreResult.CacheFilePath">
      <summary>
            Cache File path. The file path where the cache is written out
            </summary>
    </member>
    <member name="T:NuGet.Commands.RestoreRunner">
      <summary>
            Shared code to run the "restore" command for dotnet restore, nuget.exe, and VS.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreRunner.RunAsync(NuGet.Commands.RestoreArgs,System.Threading.CancellationToken)">
      <summary>
            Create requests, execute requests, and commit restore results.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreRunner.RunAsync(NuGet.Commands.RestoreArgs)">
      <summary>
            Create requests, execute requests, and commit restore results.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreRunner.RunAsync(System.Collections.Generic.IEnumerable{NuGet.Commands.RestoreSummaryRequest},NuGet.Commands.RestoreArgs,System.Threading.CancellationToken)">
      <summary>
            Execute and commit restore requests.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreRunner.RunWithoutCommit(System.Collections.Generic.IEnumerable{NuGet.Commands.RestoreSummaryRequest},NuGet.Commands.RestoreArgs)">
      <summary>
            Execute and commit restore requests.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RestoreRunner.GetRequests(NuGet.Commands.RestoreArgs)">
      <summary>
            Create restore requests but do not execute them.
            </summary>
    </member>
    <member name="T:NuGet.Commands.RestoreSummaryRequest">
      <summary>
            Wrapper for RestoreRequest
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreTargetGraph.RuntimeIdentifier">
      <summary>
            Gets the runtime identifier used during the restore operation on this graph
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreTargetGraph.Framework">
      <summary>
            Gets the <see cref="T:NuGet.Frameworks.NuGetFramework" /> used during the restore operation on this graph
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreTargetGraph.Conventions">
      <summary>
            Gets the <see cref="T:NuGet.Client.ManagedCodeConventions" /> used to resolve assets from packages in this graph
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreTargetGraph.RuntimeGraph">
      <summary>
            Gets the <see cref="P:NuGet.Commands.RestoreTargetGraph.RuntimeGraph" /> that defines runtimes and their relationships for this graph
            </summary>
    </member>
    <member name="P:NuGet.Commands.RestoreTargetGraph.Graphs">
      <summary>
            Gets the resolved dependency graph
            </summary>
    </member>
    <member name="T:NuGet.Commands.SourceRepositoryDependencyProvider">
      <summary>
            A source repository dependency provider.
            </summary>
    </member>
    <member name="M:NuGet.Commands.SourceRepositoryDependencyProvider.#ctor(NuGet.Protocol.Core.Types.SourceRepository,NuGet.Common.ILogger,NuGet.Protocol.Core.Types.SourceCacheContext,System.Boolean,System.Boolean)">
      <summary>
            Initializes a new <see cref="T:NuGet.Commands.SourceRepositoryDependencyProvider" /> class.
            </summary>
      <param name="sourceRepository">A source repository.</param>
      <param name="logger">A logger.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="ignoreFailedSources">
        <c>true</c> to ignore failed sources; otherwise <c>false</c>.</param>
      <param name="ignoreWarning">
        <c>true</c> to ignore warnings; otherwise <c>false</c>.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="sourceRepository" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Commands.SourceRepositoryDependencyProvider.#ctor(NuGet.Protocol.Core.Types.SourceRepository,NuGet.Common.ILogger,NuGet.Protocol.Core.Types.SourceCacheContext,System.Boolean,System.Boolean,NuGet.Protocol.LocalPackageFileCache)">
      <summary>
            Initializes a new <see cref="T:NuGet.Commands.SourceRepositoryDependencyProvider" /> class.
            </summary>
      <param name="sourceRepository">A source repository.</param>
      <param name="logger">A logger.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="ignoreFailedSources">
        <c>true</c> to ignore failed sources; otherwise <c>false</c>.</param>
      <param name="ignoreWarning">
        <c>true</c> to ignore warnings; otherwise <c>false</c>.</param>
      <param name="fileCache">Optional nuspec/file cache.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="sourceRepository" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Commands.SourceRepositoryDependencyProvider.FindLibraryAsync(NuGet.LibraryModel.LibraryRange,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously discovers all versions of a package from a source and selects the best match.
            </summary>
      <remarks>This does not download the package.</remarks>
      <param name="libraryRange">A library range.</param>
      <param name="targetFramework">A target framework.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.LibraryModel.LibraryIdentity" />
            instance.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="libraryRange" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="targetFramework" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Commands.SourceRepositoryDependencyProvider.GetDependenciesAsync(NuGet.LibraryModel.LibraryIdentity,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets package dependencies.
            </summary>
      <param name="libraryIdentity">A library identity.</param>
      <param name="targetFramework">A target framework.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.LibraryModel.LibraryDependencyInfo" />
            instance.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="libraryIdentity" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="targetFramework" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Commands.SourceRepositoryDependencyProvider.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package downloader.
            </summary>
      <param name="packageIdentity">A package identity.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.Packaging.IPackageDownloader" />
            instance.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageIdentity" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Commands.SourceRepositoryDependencyProvider.GetAllVersionsAsync(System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously discover all package versions from a feed.
            </summary>
      <param name="id">A package ID.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
    </member>
    <member name="P:NuGet.Commands.SourceRepositoryDependencyProvider.IsHttp">
      <summary>
            Gets a flag indicating whether or not the provider source is HTTP or HTTPS.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SourceRepositoryDependencyProvider.Source">
      <summary>
            Gets the package source.
            </summary>
      <remarks>Optional. This will be <c>null</c> for project providers.</remarks>
    </member>
    <member name="F:NuGet.Commands.BuildAssetsUtils.MacroCandidates">
      <summary>
            The macros that we may use in MSBuild to replace path roots.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.WriteFiles(System.Collections.Generic.IEnumerable{NuGet.Commands.MSBuildOutputFile},NuGet.Common.ILogger)">
      <summary>
            Write XML to disk.
            Delete files which do not have new XML.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.GenerateMultiTargetFailureFiles(System.String,System.String,NuGet.ProjectModel.ProjectStyle)">
      <summary>
            Create MSBuild targets and props files.
            Null will be returned for files that should be removed.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.AddNuGetPropertiesToFirstImport(System.Collections.Generic.IEnumerable{NuGet.Commands.MSBuildOutputFile},System.Collections.Generic.IEnumerable{System.String},System.String,NuGet.ProjectModel.ProjectStyle,System.String,System.Boolean)">
      <summary>
            Add standard properties to only props file if it exists, otherwise the targets.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.AddNuGetProperties(System.Xml.Linq.XDocument,System.Collections.Generic.IEnumerable{System.String},System.String,NuGet.ProjectModel.ProjectStyle,System.String,System.Boolean)">
      <summary>
            Apply standard properties in a property group.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.GenerateEmptyImportsFile">
      <summary>
            Get empty file with the base properties.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.GenerateMSBuildFile(System.Collections.Generic.List{NuGet.Commands.MSBuildRestoreItemGroup},NuGet.ProjectModel.ProjectStyle)">
      <summary>
            Returns null if the result should not exist on disk.
            </summary>
    </member>
    <member name="M:NuGet.Commands.BuildAssetsUtils.HasChanges(System.Xml.Linq.XDocument,System.String,NuGet.Common.ILogger)">
      <summary>
            Check if the file has changes compared to the original on disk.
            </summary>
    </member>
    <member name="T:NuGet.Commands.IncludeFlagUtils.DependencyNode">
      <summary>
            A simple node class to hold the incoming dependency edge during the graph walk.
            </summary>
    </member>
    <member name="P:NuGet.Commands.IncludeFlagUtils.DependencyNode.DependencyType">
      <summary>
            Incoming edge
            </summary>
    </member>
    <member name="P:NuGet.Commands.IncludeFlagUtils.DependencyNode.Item">
      <summary>
            Node item
            </summary>
    </member>
    <member name="M:NuGet.Commands.IncludeFlagUtils.GetDependencyType(NuGet.DependencyResolver.GraphNode{NuGet.DependencyResolver.RemoteResolveResult},NuGet.DependencyResolver.GraphNode{NuGet.DependencyResolver.RemoteResolveResult})">
      <summary>
            Find the flags for a node. 
            Include - Exclude - ParentExclude
            </summary>
    </member>
    <member name="M:NuGet.Commands.IncludeFlagUtils.OrderType(NuGet.DependencyResolver.GraphItem{NuGet.DependencyResolver.RemoteResolveResult})">
      <summary>
            Prefer projects over packages
            </summary>
      <param name="item">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.AddAssets(NuGet.ProjectModel.LockFileLibrary,NuGet.Repositories.LocalPackageInfo,NuGet.Commands.RestoreTargetGraph,NuGet.LibraryModel.LibraryIncludeFlags,NuGet.ProjectModel.LockFileTargetLibrary,NuGet.Frameworks.NuGetFramework,System.String,NuGet.ContentModel.ContentItemCollection,NuGet.Packaging.NuspecReader,System.Collections.Generic.IReadOnlyList{NuGet.ContentModel.SelectionCriteria})">
      <summary>
            Populate assets for a <see cref="T:NuGet.ProjectModel.LockFileLibrary" />.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.AddRuntimeTargets(NuGet.Commands.RestoreTargetGraph,NuGet.LibraryModel.LibraryIncludeFlags,NuGet.ProjectModel.LockFileTargetLibrary,NuGet.Frameworks.NuGetFramework,System.String,NuGet.ContentModel.ContentItemCollection)">
      <summary>
            Runtime targets
            These are applied only to non-RID target graphs.
            They are not used for compatibility checks.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.AddFrameworkReferences(NuGet.ProjectModel.LockFileTargetLibrary,NuGet.Frameworks.NuGetFramework,NuGet.Packaging.NuspecReader)">
      <summary>
            Add framework references.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.ApplyReferenceFilter(NuGet.ProjectModel.LockFileTargetLibrary,NuGet.Frameworks.NuGetFramework,NuGet.Packaging.NuspecReader)">
      <summary>
            Apply filters from the references node in the nuspec.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.ApplyLibContract(NuGet.Repositories.LocalPackageInfo,NuGet.ProjectModel.LockFileTargetLibrary,NuGet.Frameworks.NuGetFramework,NuGet.ContentModel.ContentItemCollection)">
      <summary>
            COMPAT: Support lib/contract so older packages can be consumed
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.CreateLockFileTargetProject(NuGet.DependencyResolver.GraphItem{NuGet.DependencyResolver.RemoteResolveResult},NuGet.LibraryModel.LibraryIdentity,NuGet.LibraryModel.LibraryIncludeFlags,NuGet.Commands.RestoreTargetGraph,NuGet.ProjectModel.ProjectStyle)">
      <summary>
            Create a library for a project.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.ConvertToProjectPaths(System.Collections.Generic.Dictionary{System.String,NuGet.ProjectModel.ProjectRestoreMetadataFile},System.String,System.Collections.Generic.IEnumerable{NuGet.ProjectModel.LockFileItem})">
      <summary>
            Convert from the expected nupkg path to the on disk path.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.GetLockFileItems(System.Collections.Generic.IReadOnlyList{NuGet.ContentModel.SelectionCriteria},NuGet.ContentModel.ContentItemCollection,NuGet.ContentModel.PatternSet[])">
      <summary>
            Create lock file items for the best matching group.
            </summary>
      <remarks>Enumerate this once after calling.</remarks>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.GetBuildItemsForPackageId(System.Collections.Generic.IEnumerable{NuGet.ProjectModel.LockFileItem},System.String)">
      <summary>
            Get packageId.targets and packageId.props
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.CreateCriteria(NuGet.Commands.RestoreTargetGraph,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Creates an ordered list of selection criteria to use. This supports fallback frameworks.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.ClearIfExists``1(System.Collections.Generic.IList{``0})">
      <summary>
            Clears a lock file group and replaces the first item with _._ if 
            the group has items. Empty groups are left alone.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.GroupHasNonEmptyItems(System.Collections.Generic.IEnumerable{NuGet.ProjectModel.LockFileItem})">
      <summary>
            True if the group has items that do not end with _._
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.GetContentGroupsForFramework(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.List{NuGet.ContentModel.ContentItemGroup},System.String)">
      <summary>
            Group all items by the primary key, then select the nearest TxM 
            within each group.
            Items that do not contain the primaryKey will be filtered out.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.GetRuntimeTargetItems(System.Collections.Generic.List{NuGet.ContentModel.ContentItemGroup},System.String)">
      <summary>
            Create LockFileItems from groups of library items.
            </summary>
      <param name="groups">Library items grouped by RID.</param>
      <param name="assetType">Lock file section the items apply to.</param>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.ToDirectorySeparator(System.String)">
      <summary>
            Replace / with the local directory separator if needed.
            For OSX and Linux the same string is returned.
            </summary>
    </member>
    <member name="M:NuGet.Commands.LockFileUtils.ExcludeItems(NuGet.ProjectModel.LockFileTargetLibrary,NuGet.LibraryModel.LibraryIncludeFlags)">
      <summary>
            Replace excluded asset groups with _._ if they have &gt; 0 items.
            </summary>
    </member>
    <member name="T:NuGet.Commands.MSBuildRestoreUtility">
      <summary>
            Helpers for dealing with dg files and processing msbuild related inputs.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.GetDependencySpec(System.Collections.Generic.IEnumerable{NuGet.Commands.IMSBuildItem})">
      <summary>
            Convert MSBuild items to a DependencyGraphSpec.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.ApplyIncludeFlags(NuGet.LibraryModel.LibraryDependency,System.String,System.String,System.String)">
      <summary>
            Insert asset flags into dependency, based on ;-delimited string args
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.ApplyIncludeFlags(NuGet.ProjectModel.ProjectRestoreReference,System.String,System.String,System.String)">
      <summary>
            Insert asset flags into project dependency, based on ;-delimited string args
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.GetPackageSpec(System.Collections.Generic.IEnumerable{NuGet.Commands.IMSBuildItem})">
      <summary>
            Convert MSBuild items to a PackageSpec.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.RemoveMissingProjects(NuGet.ProjectModel.DependencyGraphSpec)">
      <summary>
            Remove missing project dependencies. These are typically caused by
            non-NuGet projects which are missing the targets needed to walk them.
            Visual Studio ignores these projects so from the command line we should
            also. Build will fail with the appropriate errors for missing projects
            restore should not warn or message for this.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.NormalizePathCasings(System.Collections.Generic.Dictionary{System.String,System.String},NuGet.ProjectModel.DependencyGraphSpec)">
      <summary>
            Change all project paths to the same casing.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.ContainsClearKeyword(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            True if the list contains CLEAR.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.HasInvalidClear(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            True if the list contains CLEAR and non-CLEAR keywords.
            </summary>
      <remarks>CLEAR;CLEAR is considered valid.</remarks>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.LogErrorForClearIfInvalid(System.Collections.Generic.IEnumerable{System.String},System.String,NuGet.Common.ILogger)">
      <summary>
            Logs an error if CLEAR is used with non-CLEAR entries.
            </summary>
      <returns>True if an invalid combination exists.</returns>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.GetWarningForUnsupportedProject(System.String)">
      <summary>
            Log warning NU1503
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.AggregateSources(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Remove duplicates and excluded values a set of sources or fallback folders.
            </summary>
      <remarks>Compares with Ordinal, excludes must be exact matches.</remarks>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.GetVersion(NuGet.Commands.IMSBuildItem)">
      <summary>
            Return the parsed version or 1.0.0 if the property does not exist.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.PersistDGFileIfDebugging(NuGet.ProjectModel.DependencyGraphSpec,NuGet.Common.ILogger)">
      <summary>
            Write the dg file to a temp location if NUGET_PERSIST_DG.
            </summary>
      <remarks>This is a noop if NUGET_PERSIST_DG is not set to true.</remarks>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.FixSourcePath(System.String)">
      <summary>
            Convert http:/url to http://url 
            If not needed the same path is returned. This is to work around
            issues with msbuild dropping slashes from paths on linux and osx.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.IsPersistDGSet">
      <summary>
            True if NUGET_PERSIST_DG is set to true.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildRestoreUtility.ReplayWarningsAndErrorsAsync(NuGet.ProjectModel.LockFile,NuGet.Common.ILogger)">
      <summary>
            Function used to display errors and warnings at the end of restore operation.
            The errors and warnings are read from the assets file based on restore result.
            </summary>
      <param name="lockFile">LockFile generated by preview restore.</param>
      <param name="logger">Logger used to display warnings and errors.</param>
    </member>
    <member name="M:NuGet.Commands.NoOpRestoreUtilities.IsNoOpSupported(NuGet.Commands.RestoreRequest)">
      <summary>
            If the dependencyGraphSpec is not set, we cannot no-op on this project restore. 
            </summary>
    </member>
    <member name="M:NuGet.Commands.NoOpRestoreUtilities.GetBuildIntegratedProjectCacheFilePath(NuGet.Commands.RestoreRequest)">
      <summary>
            The cache file path is $(MSBuildProjectExtensionsPath)\$(project).nuget.cache
            </summary>
    </member>
    <member name="M:NuGet.Commands.NoOpRestoreUtilities.GetCacheFilePath(NuGet.Commands.RestoreRequest)">
      <summary>
            Evaluate the location of the cache file path, based on ProjectStyle.
            </summary>
    </member>
    <member name="M:NuGet.Commands.NoOpRestoreUtilities.GetCacheFilePath(NuGet.Commands.RestoreRequest,NuGet.ProjectModel.LockFile)">
      <summary>
            Evaluate the location of the cache file path, based on ProjectStyle.
            </summary>
    </member>
    <member name="M:NuGet.Commands.NoOpRestoreUtilities.VerifyAssetsAndMSBuildFilesAndPackagesArePresent(NuGet.Commands.RestoreRequest)">
      <summary>
            This method verifies that the props/targets files and all the packages written out in the lock file are present on disk
            This does not account if the files were manually modified since the last restore
            </summary>
    </member>
    <member name="M:NuGet.Commands.NoOpRestoreUtilities.VerifyPackagesOnDisk(NuGet.Commands.RestoreRequest)">
      <summary>
            Read out all the packages specified in the existing lock file and verify that they are in the cache
            </summary>
    </member>
    <member name="M:NuGet.Commands.NoOpRestoreUtilities.GetHash(NuGet.Commands.RestoreRequest)">
      <summary>
            Calculates the hash value, used for the no-op optimization, for the request
            This methods handles the deduping of tools
            Handles the ignoring of RestoreSettings
            </summary>
    </member>
    <member name="M:NuGet.Commands.NoOpRestoreUtilities.PersistHashedDGFileIfDebugging(NuGet.ProjectModel.DependencyGraphSpec,NuGet.Common.ILogger)">
      <summary>
            Write the dg file to a temp location if NUGET_PERSIST_NOOP_DG.
            </summary>
      <remarks>This is a noop if NUGET_PERSIST_NOOP_DG is not set to true.</remarks>
    </member>
    <member name="M:NuGet.Commands.NoOpRestoreUtilities.IsPersistDGSet">
      <summary>
            True if NUGET_PERSIST_NOOP_DG is set to true.
            </summary>
    </member>
    <member name="M:NuGet.Commands.NoOpRestoreUtilities.UpdateRequestBestMatchingToolPathsIfAvailable(NuGet.Commands.RestoreRequest)">
      <summary>
            This method will resolve the cache/lock file paths for the tool if available in the cache
            This method will set the CacheFilePath and the LockFilePath in the RestoreMetadat if a matching tool is available
            </summary>
    </member>
    <member name="M:NuGet.Commands.SpecValidationUtility.ValidateDependencySpec(NuGet.ProjectModel.DependencyGraphSpec)">
      <summary>
            Validate a dg file. This will throw a RestoreSpecException if there are errors.
            </summary>
    </member>
    <member name="M:NuGet.Commands.ToolRestoreUtility.GetSpec(System.String,System.String,NuGet.Versioning.VersionRange,NuGet.Frameworks.NuGetFramework,System.String,System.Collections.Generic.IList{System.String},System.Collections.Generic.IList{NuGet.Configuration.PackageSource},NuGet.ProjectModel.WarningProperties)">
      <summary>
            Build a package spec in memory to execute the tool restore as if it were
            its own project. For now, we always restore for a null runtime and a single
            constant framework.
            </summary>
    </member>
    <member name="M:NuGet.Commands.ToolRestoreUtility.GetSubSetRequests(System.Collections.Generic.IEnumerable{NuGet.Commands.RestoreSummaryRequest})">
      <summary>
            Only one output can win per packages folder/version range. Between colliding requests take
            the intersection of the inputs used.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Commands.ToolRestoreUtility.GetToolIdOrNullFromSpec(NuGet.ProjectModel.PackageSpec)">
      <summary>
            Returns the name of the single dependency in the spec or null.
            </summary>
    </member>
    <member name="M:NuGet.Commands.ToolRestoreUtility.GetToolDependencyOrNullFromSpec(NuGet.ProjectModel.PackageSpec)">
      <summary>
            Returns the name of the single dependency in the spec or null.
            </summary>
    </member>
    <member name="T:NuGet.Commands.CertificateSourceOptions">
      <summary>
            Source options for X.509 certificates.
            <seealso cref="T:NuGet.Commands.CertificateProvider" /></summary>
    </member>
    <member name="P:NuGet.Commands.CertificateSourceOptions.CertificatePath">
      <summary>
            The certificate file path.
            </summary>
    </member>
    <member name="P:NuGet.Commands.CertificateSourceOptions.CertificatePassword">
      <summary>
            The certificate password.
            </summary>
    </member>
    <member name="P:NuGet.Commands.CertificateSourceOptions.StoreName">
      <summary>
            The certificate store name.
            </summary>
    </member>
    <member name="P:NuGet.Commands.CertificateSourceOptions.StoreLocation">
      <summary>
            The certificate store location.
            </summary>
    </member>
    <member name="P:NuGet.Commands.CertificateSourceOptions.SubjectName">
      <summary>
            The certificate subject name or a substring to be used to search for the certificate.
            </summary>
    </member>
    <member name="P:NuGet.Commands.CertificateSourceOptions.Fingerprint">
      <summary>
            The SHA-1 fingerprint of the certificate.
            </summary>
    </member>
    <member name="P:NuGet.Commands.CertificateSourceOptions.NonInteractive">
      <summary>
            bool used to indicate if the user can be prompted for password.
            </summary>
    </member>
    <member name="P:NuGet.Commands.CertificateSourceOptions.PasswordProvider">
      <summary>
            Password provider to get the password from user for opening a pfx file.
            </summary>
    </member>
    <member name="P:NuGet.Commands.CertificateSourceOptions.Token">
      <summary>
            Cancellation token.
            </summary>
    </member>
    <member name="M:NuGet.Commands.CertificateProvider.GetCertificatesAsync(NuGet.Commands.CertificateSourceOptions)">
      <summary>
            Looks for X509Certificates using the CertificateSourceOptions.
            Throws an InvalidOperationException if the option specifies a CertificateFilePath with invalid password.
            </summary>
      <param name="options">CertificateSourceOptions to be used while searching for the certificates.</param>
      <returns>An X509Certificate2Collection object containing matching certificates.
            If no matching certificates are found then it returns an empty collection.</returns>
    </member>
    <member name="M:NuGet.Commands.CertificateProvider.OpenStore(System.Security.Cryptography.X509Certificates.X509Store)">
      <summary>
            Opens an X509Store with read only access.
            Throws an InvalidOperationException if the store does not exist.
            </summary>
      <param name="store">X509Store to be opened.</param>
    </member>
    <member name="T:NuGet.Commands.SignArgs">
      <summary>
            Object to hold params passed to the sign command and pass to the sign command runner.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.PackagePath">
      <summary>
            Path to the package that has to be signed.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.OutputDirectory">
      <summary>
            Output directory where the signed package should be dropped.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.CertificatePath">
      <summary>
            Path to a Certificate file.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.CertificateStoreName">
      <summary>
            Name of the store to be used when searching for a certificate.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.CertificateStoreLocation">
      <summary>
            Location of the store to be used when searching for a certificate.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.CertificateSubjectName">
      <summary>
            Subject Name for the certificate that can be used to search the local certificate store.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.CertificateFingerprint">
      <summary>
            Fingerprint for the certificate that can be used to search the local certificate store.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.SignatureHashAlgorithm">
      <summary>
            Hashing Algorithm to be used to digest the package files.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.Timestamper">
      <summary>
            URL to an RFC 3161 timestamp server.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.TimestampHashAlgorithm">
      <summary>
            Hashing Algorithm to be used by the RFC 3161 time stamp server.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.CertificatePassword">
      <summary>
            Password for a pfx file, if needed.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.Overwrite">
      <summary>
            Switch used to indicate if an existing signature should be overwritten.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.NonInteractive">
      <summary>
            Switch used to indicate that we should not prompt for user input or confirmations.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.Logger">
      <summary>
            Logger to be used to display the logs during the execution of sign command.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.PasswordProvider">
      <summary>
            Password provider to get the password from user for opening a pfx file.
            </summary>
    </member>
    <member name="P:NuGet.Commands.SignArgs.Token">
      <summary>
            Cancellation Token.
            </summary>
    </member>
    <member name="T:NuGet.Commands.SignCommandException">
      <summary>
            Holds an <see cref="T:NuGet.Common.ILogMessage" /> and returns the message for the exception.
            </summary>
    </member>
    <member name="T:NuGet.Commands.SignCommandRunner">
      <summary>
            Command Runner used to run the business logic for nuget sign command
            </summary>
    </member>
    <member name="T:NuGet.Commands.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.AddFileToPackage">
      <summary>
              Looks up a localized string similar to Add file '{0}' to package as '{1}'.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.BuildingProjectTargetingFramework">
      <summary>
              Looks up a localized string similar to Building project '{0}' for target framework '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.CannotBeUsedWithOtherValues">
      <summary>
              Looks up a localized string similar to '{0}' cannot be used in conjunction with other values..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_BuildFailed">
      <summary>
              Looks up a localized string similar to Failed to build using '{0} {1}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_CannotFindMsbuild">
      <summary>
              Looks up a localized string similar to Cannot find version of msbuild..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_EmptySourceFilePath">
      <summary>
              Looks up a localized string similar to A source file was added with an empty path..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_EmptySourceFileProjectDirectory">
      <summary>
              Looks up a localized string similar to The project directory for the source file '{0}' could not be found..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_InputFileNotSpecified">
      <summary>
              Looks up a localized string similar to Please specify a nuspec, project.json, or project file to use.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_InvalidATF">
      <summary>
              Looks up a localized string similar to PackageTargetFallback and AssetTargetFallback cannot be used together. Remove PackageTargetFallback(deprecated) references from the project environment..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_InvalidCommandLineInput">
      <summary>
              Looks up a localized string similar to Invalid input '{0}'. The file type was not recognized..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_InvalidCommandLineInputConfig">
      <summary>
              Looks up a localized string similar to Invalid input '{0}'. Valid file names are 'packages.config' or 'packages.*.config'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_InvalidCommandLineInputJson">
      <summary>
              Looks up a localized string similar to Invalid input '{0}'. Valid file names are 'project.json' or '*.project.json'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_InvalidDependencyVersionConstraints">
      <summary>
              Looks up a localized string similar to Package version constraints for '{0}' return a version range that is empty..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_InvalidProjectPackageCombo">
      <summary>
              Looks up a localized string similar to Invalid project-package combination for {0} {1}. DotnetToolReference project style can only contain references of the DotnetTool type.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_InvalidTargetFramework">
      <summary>
              Looks up a localized string similar to Failed to build package because of an unsupported targetFramework value on '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_MissingSourceParameter">
      <summary>
              Looks up a localized string similar to Source parameter was not specified..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_NoPackageVersionsExist">
      <summary>
              Looks up a localized string similar to Unable to find package {0}. No packages exist with this id in source(s): {1}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_NoPackageVersionsExistInRange">
      <summary>
              Looks up a localized string similar to Unable to find package {0} with version {1}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_NoStablePackageVersionsExist">
      <summary>
              Looks up a localized string similar to Unable to find a stable package {0} with version {1}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_PackageCommandNoFilesForLibPackage">
      <summary>
              Looks up a localized string similar to Failed to build package. Ensure '{0}' includes assembly files. For help on building symbols package, visit {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_PackageCommandNoFilesForSymbolsPackage">
      <summary>
              Looks up a localized string similar to Failed to build package. Ensure '{0}' includes source and symbol files. For help on building symbols package, visit {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_PackFailed">
      <summary>
              Looks up a localized string similar to Failed to build package. {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_ProcessingNuspecFile">
      <summary>
              Looks up a localized string similar to Error occurred when processing file '{0}': {1}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_ProjectDoesNotExist">
      <summary>
              Looks up a localized string similar to Unable to find project '{0}'. Check that the project reference is valid and that the project file exists..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_ProjectWithIncorrectDependenciesCount">
      <summary>
              Looks up a localized string similar to Project {0} must have a single package reference(s)..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_ToolsPackageWithExtraPackageTypes">
      <summary>
              Looks up a localized string similar to Invalid tools package {0} {1}. Tools packages cannot contain more than one PackageType..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_UnableToFindProjectInfo">
      <summary>
              Looks up a localized string similar to Unable to find project information for '{0}'. The project file may be invalid or missing targets required for restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_UnableToLocateBuildOutput">
      <summary>
              Looks up a localized string similar to No build found in {0}. Use the -Build option or build the project..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_UnableToLocateRestoreTarget">
      <summary>
              Looks up a localized string similar to The folder '{0}' does not contain a project to restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_UnableToLocateRestoreTarget_Because">
      <summary>
              Looks up a localized string similar to Failed to find a project to restore in the folder '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_UnableToSignPackage">
      <summary>
              Looks up a localized string similar to Unable to sign package..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_UnknownBuildAction">
      <summary>
              Looks up a localized string similar to Package '{0}' specifies an invalid build action '{1}' for file '{2}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_WriteResolvedNuSpecOverwriteOriginal">
      <summary>
              Looks up a localized string similar to Unable to output resolved nuspec file because it would overwrite the original at '{0}'.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Error_XPROJNotAllowed">
      <summary>
              Looks up a localized string similar to Invalid input '{0}'. XProj support has been removed. Support for XProj and standalone project.json files has been removed, to continue working with legacy projects use NuGet 3.5.x from https://nuget.org/downloads.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.FailedToBuildProject">
      <summary>
              Looks up a localized string similar to Failed to build '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.FileNotAddedToPackage">
      <summary>
              Looks up a localized string similar to File '{0}' is not added because the package already contains file '{1}'.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.FoundVersionsInSource">
      <summary>
              Looks up a localized string similar to Found {0} version(s) in {1} [ Nearest version: {2} ].
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.FoundVersionsInSourceWithoutMatch">
      <summary>
              Looks up a localized string similar to Found {0} version(s) in {1}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.InvalidRestoreInput">
      <summary>
              Looks up a localized string similar to Invalid restore input. {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.InvalidRestoreInputWithFiles">
      <summary>
              Looks up a localized string similar to Invalid restore input. {0} Input files: {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.InvalidSource">
      <summary>
              Looks up a localized string similar to The specified source '{0}' is invalid. Please provide a valid source..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearedSuccessful">
      <summary>
              Looks up a localized string similar to Local resources cleared..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearFailed">
      <summary>
              Looks up a localized string similar to Clearing local resources failed: Unable to delete one or more files..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearingNuGetCache">
      <summary>
              Looks up a localized string similar to Clearing NuGet cache: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearingNuGetGlobalPackagesFolder">
      <summary>
              Looks up a localized string similar to Clearing NuGet global packages folder: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearingNuGetHttpCache">
      <summary>
              Looks up a localized string similar to Clearing NuGet HTTP cache: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearingNuGetPluginsCache">
      <summary>
              Looks up a localized string similar to Clearing NuGet plugins cache: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_ClearingNuGetTempCache">
      <summary>
              Looks up a localized string similar to Clearing NuGet Temp cache: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_FailedToDeletePath">
      <summary>
              Looks up a localized string similar to Failed to delete '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_Help">
      <summary>
               Looks up a localized string similar to usage: NuGet locals &lt;all | http-cache | global-packages | temp | plugins-cache&gt; [--clear | -c | --list | -l]
            For more information, visit http://docs.nuget.org/docs/reference/command-line-reference.
             </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_InvalidLocalResourceName">
      <summary>
              Looks up a localized string similar to An invalid local resource name was provided. Please provide one of the following values: http-cache, temp, global-packages, all..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_LocalResourcePathNotSet">
      <summary>
              Looks up a localized string similar to The location of local resource '{0}' is undefined..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.LocalsCommand_LocalsPartiallyCleared">
      <summary>
              Looks up a localized string similar to Local resources partially cleared..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_AssetsFileNotOnDisk">
      <summary>
              Looks up a localized string similar to The expected assets file for {0} does not exist, no-op is not possible. Continuing restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_CheckingCompatibility">
      <summary>
              Looks up a localized string similar to Checking compatibility of packages on {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_CheckingPackageCompatibility">
      <summary>
              Looks up a localized string similar to Checking compatibility for {0} {1} with {2}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_Committing">
      <summary>
              Looks up a localized string similar to Committing restore....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ConfigFileSummary">
      <summary>
              Looks up a localized string similar to NuGet Config files used:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ConvertedPackageToOriginalCase">
      <summary>
              Looks up a localized string similar to The package {0} was converted to original case in the packages directory..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_CycleDetected">
      <summary>
              Looks up a localized string similar to Cycle detected..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_DependencyBumpedUp">
      <summary>
              Looks up a localized string similar to Dependency specified was {0} {1} but ended up with {2} {3}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_DowngradeWarning">
      <summary>
              Looks up a localized string similar to Detected package downgrade: {0} from {1} to {2}. Reference the package directly from the project to select a different version..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ErrorSummary">
      <summary>
              Looks up a localized string similar to Errors in {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_FailedToResolveConflicts">
      <summary>
              Looks up a localized string similar to Failed to resolve conflicts for {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_FeedsUsedSummary">
      <summary>
              Looks up a localized string similar to Feeds used:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_FoundProjectRoot">
      <summary>
              Looks up a localized string similar to Found project root directory: {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_FrameworkDisplay">
      <summary>
              Looks up a localized string similar to {0} ({1}).
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_FrameworkRIDDisplay">
      <summary>
              Looks up a localized string similar to {0} ({1}) / {2}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_GeneratingMsBuildFile">
      <summary>
              Looks up a localized string similar to Generating MSBuild file {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ImportsFallbackWarning">
      <summary>
              Looks up a localized string similar to Package '{0}' was restored using '{1}' instead of the project target framework '{2}'. This package may not be fully compatible with your project..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_InstalledSummary">
      <summary>
              Looks up a localized string similar to Installed:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_InstalledSummaryCount">
      <summary>
              Looks up a localized string similar to {0} package(s) to {1}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_InstallingPackage">
      <summary>
              Looks up a localized string similar to Installing {0} {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_LockFileMissingLibraryForTargetLibrary">
      <summary>
              Looks up a localized string similar to {0} {1} is specified in the Lock File target for {2} but is not present in the top-level Libraries list..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_LockFileOutOfDate">
      <summary>
              Looks up a localized string similar to The lock file is out-of-date relative to the project file. Regenerating the lock file and re-locking..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_MergingRuntimes">
      <summary>
              Looks up a localized string similar to Merging in runtimes defined in {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_MissingImplementationFx">
      <summary>
              Looks up a localized string similar to {0} {1} provides a compile-time reference assembly for {2} on {3}, but there is no compatible run-time assembly..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_MissingImplementationFxRuntime">
      <summary>
              Looks up a localized string similar to {0} {1} provides a compile-time reference assembly for {2} on {3}, but there is no run-time assembly compatible with {4}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_MissingPackagesOnDisk">
      <summary>
              Looks up a localized string similar to Not all packages are on disk for: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageCommandAddedFile">
      <summary>
              Looks up a localized string similar to Added file '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageCommandAttemptingToBuildSymbolsPackage">
      <summary>
              Looks up a localized string similar to Attempting to build symbols package for '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageCommandInstallPackageToOutputPath">
      <summary>
              Looks up a localized string similar to Install {0} to output path '{1}'.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageCommandSuccess">
      <summary>
              Looks up a localized string similar to Successfully created package '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageNotCompatibleWithFx">
      <summary>
              Looks up a localized string similar to Package {0} {1} is not compatible with {2}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageNotCompatibleWithFx_NoSupports">
      <summary>
              Looks up a localized string similar to Package {0} {1} does not support any target frameworks..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackageNotCompatibleWithFx_Supports">
      <summary>
              Looks up a localized string similar to Package {0} {1} supports:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackagesAndProjectsAreCompatible">
      <summary>
              Looks up a localized string similar to All packages and projects are compatible with {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PackagesIncompatible">
      <summary>
              Looks up a localized string similar to One or more packages are incompatible with {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ProjectDoesNotSpecifyTargetFrameworks">
      <summary>
              Looks up a localized string similar to The project {0} does not specify any target frameworks in {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ProjectNotCompatibleWithFx">
      <summary>
              Looks up a localized string similar to Project {0} is not compatible with {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ProjectNotCompatibleWithFx_NoSupports">
      <summary>
              Looks up a localized string similar to Project {0} does not support any target frameworks..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ProjectNotCompatibleWithFx_Supports">
      <summary>
              Looks up a localized string similar to Project {0} supports:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ProjectsIncompatible">
      <summary>
              Looks up a localized string similar to One or more projects are incompatible with {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_PropsFileNotOnDisk">
      <summary>
              Looks up a localized string similar to The props file for {0} at location {1} does not exist, no-op is not possible. Continuing restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ReadingProject">
      <summary>
              Looks up a localized string similar to Reading project file {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ResolverConflict">
      <summary>
              Looks up a localized string similar to Unable to satisfy conflicting requests for '{0}': {1} Framework: {2}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ResolvingConflicts">
      <summary>
              Looks up a localized string similar to Resolving conflicts for {0}....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RestoreComplete">
      <summary>
              Looks up a localized string similar to Restore completed in {0} for {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RestoreFailed">
      <summary>
              Looks up a localized string similar to Restore failed in {0} for {1}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RestoreNoOpDGChanged">
      <summary>
              Looks up a localized string similar to The restore inputs for '{0}' have changed. Continuing restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RestoreNoOpFinish">
      <summary>
              Looks up a localized string similar to The restore inputs for '{0}' have not changed. No further actions are required to complete the restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RestoringPackages">
      <summary>
              Looks up a localized string similar to Restoring packages for {0}....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RestoringPackagesForCompat">
      <summary>
              Looks up a localized string similar to Restoring packages for {0} to determine compatibility....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RestoringToolPackages">
      <summary>
              Looks up a localized string similar to Restoring packages for tool '{0}' in {1}....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RunningNonParallelRestore">
      <summary>
              Looks up a localized string similar to Running non-parallel restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_RunningParallelRestore">
      <summary>
              Looks up a localized string similar to Running restore with {0} concurrent jobs..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ScanningForRuntimeJson">
      <summary>
              Looks up a localized string similar to Scanning packages for runtime.json files....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_SkippingAssetsFile">
      <summary>
              Looks up a localized string similar to Assets file has not changed. Skipping assets file writing. Path: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_SkippingCacheFile">
      <summary>
              Looks up a localized string similar to No-Op restore. The cache will not be updated. Path: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_SkippingCompatibiilityCheckOnRidlessGraphForDotnetToolReferenceProject">
      <summary>
              Looks up a localized string similar to Skipping compatibility checks of the ridless graph for DotnetToolReference project type. This graph is not used. .
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_SkippingRuntimeWalk">
      <summary>
              Looks up a localized string similar to Skipping runtime dependency walk, no runtimes defined in project.json..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_TargetsFileNotOnDisk">
      <summary>
              Looks up a localized string similar to The targets file for {0} at location {1} does not exist, no-op is not possible. Continuing restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ToolSkippingAssetsFile">
      <summary>
              Looks up a localized string similar to Tool assets file has not changed. Skipping assets file write. Path: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ToolWritingCacheFile">
      <summary>
              Looks up a localized string similar to Writing tool cache file to disk. Path: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_ToolWritingLockFile">
      <summary>
              Looks up a localized string similar to Writing tool lock file to disk. Path: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_UnknownCompatibilityProfile">
      <summary>
              Looks up a localized string similar to Unknown Compatibility Profile: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_UnresolvedDependency">
      <summary>
              Looks up a localized string similar to Unable to resolve '{0}' for '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_UsingPackagesDirectory">
      <summary>
              Looks up a localized string similar to Using packages directory: {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_UsingSource">
      <summary>
              Looks up a localized string similar to Using source {0}..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_VersionConflict">
      <summary>
              Looks up a localized string similar to Version conflict detected for {0}. Install/reference {1} directly to project {2} to resolve this issue..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_WritingCacheFile">
      <summary>
              Looks up a localized string similar to Writing cache file to disk. Path: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Log_WritingLockFile">
      <summary>
              Looks up a localized string similar to Writing lock file to disk. Path: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.MissingRequiredProperty">
      <summary>
              Looks up a localized string similar to Missing required property '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.MissingRequiredPropertyForProjectType">
      <summary>
              Looks up a localized string similar to Missing required property '{0}' for project type '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.MSBuildWarning_MultiTarget">
      <summary>
              Looks up a localized string similar to Packages containing MSBuild targets and props files cannot be fully installed in projects targeting multiple frameworks. The MSBuild targets and props files have been ignored..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.NonMatchingProperties">
      <summary>
              Looks up a localized string similar to Properties '{0}':'{1}' and '{2}':'{3}' do not match..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.NuGetDocs">
      <summary>
              Looks up a localized string similar to http://docs.nuget.org/.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.PackageCommandFileFromDependencyIsChanged">
      <summary>
              Looks up a localized string similar to File from dependency is not changed. File '{0}' is not added..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.PackageCommandFileFromDependencyIsNotChanged">
      <summary>
              Looks up a localized string similar to File from dependency is not changed. File '{0}' is not added..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.PackagingFilesFromOutputPath">
      <summary>
              Looks up a localized string similar to Packing files from '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.PersistDGFile">
      <summary>
              Looks up a localized string similar to Persisting restore input to '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.PropertyNotAllowed">
      <summary>
              Looks up a localized string similar to Invalid input combination. Property '{0}' is not allowed..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.PropertyNotAllowedForProjectType">
      <summary>
              Looks up a localized string similar to Invalid input combination. Property '{0}' is not allowed for project type '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.ResolverRequest_ToStringFormat">
      <summary>
              Looks up a localized string similar to {0} (via {1}).
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandCertificateFileNotFound">
      <summary>
              Looks up a localized string similar to Certificate file '{0}' not found. For a list of accepted ways to provide a certificate, please visit https://docs.nuget.org/docs/reference/command-line-reference.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandCertificateStoreNotFound">
      <summary>
              Looks up a localized string similar to Certificate store '{0}' not found. For a list of accepted ways to provide a certificate, please visit https://docs.nuget.org/docs/reference/command-line-reference.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandDialogMessage">
      <summary>
              Looks up a localized string similar to Please select a valid certificate.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandDialogTitle">
      <summary>
              Looks up a localized string similar to NuGet Sign Certificate Selection.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandDisplayCertificate">
      <summary>
              Looks up a localized string similar to Signing package(s) with certificate:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandDisplayTimestamper">
      <summary>
              Looks up a localized string similar to Timestamping package(s) with:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandInvalidCertEku">
      <summary>
              Looks up a localized string similar to The following certificate cannot be used for signing a package as it does not have Code Signing enhanced key usage:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandInvalidCertException">
      <summary>
              Looks up a localized string similar to Certificate file '{0}' is invalid. For a list of accepted ways to provide a certificate, please visit https://docs.nuget.org/docs/reference/command-line-reference.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandInvalidPasswordException">
      <summary>
              Looks up a localized string similar to Invalid password was provided for the certificate file '{0}'. Please provide a valid password using the '-{1}' option.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandMultipleCertException">
      <summary>
              Looks up a localized string similar to Multiple certificates were found that meet all the given criteria. Use the '-{0}' option with the hash of the desired certificate..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandNoCertException">
      <summary>
              Looks up a localized string similar to No certificates were found that meet all the given criteria. For a list of accepted ways to provide a certificate, please visit https://docs.nuget.org/docs/reference/command-line-reference.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandOutputPath">
      <summary>
              Looks up a localized string similar to Signed package(s) output path:.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SignCommandSuccess">
      <summary>
              Looks up a localized string similar to Package(s) signed successfully..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationDuplicateFrameworks">
      <summary>
              Looks up a localized string similar to Duplicate frameworks found: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationInvalidFramework">
      <summary>
              Looks up a localized string similar to Invalid target framework '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationMissingDependency">
      <summary>
              Looks up a localized string similar to Missing dependency on '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationMissingProject">
      <summary>
              Looks up a localized string similar to Missing project '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationNoFrameworks">
      <summary>
              Looks up a localized string similar to No target frameworks specified..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationUAPSingleFramework">
      <summary>
              Looks up a localized string similar to UAP projects must contain exactly one target framework..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.SpecValidationZeroRestoreRequests">
      <summary>
              Looks up a localized string similar to Restore request does not contain any projects to restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.UnableToExtractAssemblyMetadata">
      <summary>
              Looks up a localized string similar to Unable to extract metadata from '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.UnableToFindBuildOutput">
      <summary>
              Looks up a localized string similar to Unable to find '{0}'. Make sure the project has been built..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.UnsupportedProject">
      <summary>
              Looks up a localized string similar to Skipping restore for project '{0}'. The project file may be invalid or missing targets required for restore..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.UsingNuspecForMetadata">
      <summary>
              Looks up a localized string similar to Using '{0}' for metadata..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.UsingPackagesConfigForDependencies">
      <summary>
              Looks up a localized string similar to Found packages.config. Using packages listed as dependencies.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.VerifyCommand_Failed">
      <summary>
              Looks up a localized string similar to Package signature validation failed..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.VerifyCommand_FinishedWithErrors">
      <summary>
              Looks up a localized string similar to Finished with {0} errors and {1} warnings..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.VerifyCommand_PackageIsNotValid">
      <summary>
              Looks up a localized string similar to '{0}' is not a valid package file..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.VerifyCommand_Success">
      <summary>
              Looks up a localized string similar to Successfully verified package '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.VerifyCommand_VerificationTypeNotSupported">
      <summary>
              Looks up a localized string similar to Verification type not supported. Please use only one of the following supported types: -All, -Signatures.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.VerifyCommand_VerifyingPackage">
      <summary>
              Looks up a localized string similar to Verifying {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_DuplicatePropertyKey">
      <summary>
              Looks up a localized string similar to '{0}' key already exists in Properties collection. Overriding value..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_FileDoesNotExist">
      <summary>
              Looks up a localized string similar to '{0}' was included in the project but doesn't exist. Skipping....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_FileExcludedByDefault">
      <summary>
              Looks up a localized string similar to File '{0}' was not added to the package. Files and folders starting with '.' or ending with '.nupkg' are excluded by default. To include this file, use -NoDefaultExcludes from the commandline.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_MinVersionDoesNotExist">
      <summary>
              Looks up a localized string similar to {0} depends on {1} but {2} was not found. An approximate best match of {3} was resolved..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_MinVersionNonInclusive">
      <summary>
              Looks up a localized string similar to {0} does not provide an inclusive lower bound for dependency {1}. An approximate best match of {2} was resolved..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_MultiTarget">
      <summary>
              Looks up a localized string similar to Packages containing MSBuild targets and props files cannot be fully installed in projects targeting multiple frameworks. The MSBuild targets and props files have been ignored..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_PackageCommandIssueDescription">
      <summary>
              Looks up a localized string similar to Description: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_PackageCommandIssueSolution">
      <summary>
              Looks up a localized string similar to Solution: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_PackageCommandIssueTitle">
      <summary>
              Looks up a localized string similar to Issue: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_PackageCommandPackageIssueSummary">
      <summary>
              Looks up a localized string similar to Issue found with package '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_ProjectDependencyMissingLowerBound">
      <summary>
              Looks up a localized string similar to Project dependency {0} does not contain an inclusive lower bound. Include a lower bound in the dependency version to ensure consistent restore results..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_SemanticVersion">
      <summary>
              Looks up a localized string similar to Version "{0}" does not follow semantic versioning guidelines. Update your nuspec file or use the AssemblyInformationalVersion assembly attribute to specify a semantic version as described at http://semver.org..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_UnresolvedFilePath">
      <summary>
              Looks up a localized string similar to '{0}' was included in the project but the path could not be resolved. Skipping....
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_UnspecifiedField">
      <summary>
              Looks up a localized string similar to {0} was not specified. Using '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Commands.Strings.Warning_VersionAboveUpperBound">
      <summary>
              Looks up a localized string similar to Detected package version outside of dependency constraint: {0} requires {1} but version {2} was resolved..
            </summary>
    </member>
    <member name="M:NuGet.Commands.AssetTargetFallbackUtility.EnsureValidFallback(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework},System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework},System.String)">
      <summary>
            Throw if an invalid combination exists.
            </summary>
    </member>
    <member name="M:NuGet.Commands.AssetTargetFallbackUtility.GetFallbackFramework(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework},System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Returns the fallback framework or the original.
            </summary>
    </member>
    <member name="M:NuGet.Commands.AssetTargetFallbackUtility.ApplyFramework(NuGet.ProjectModel.TargetFrameworkInformation,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework},System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Update TargetFrameworkInformation properties.
            </summary>
    </member>
    <member name="T:NuGet.Commands.CommandRunnerUtility">
      <summary>
            Helper functions for shared command runners (push, delete, etc)
            </summary>
    </member>
    <member name="T:NuGet.Commands.Extensions">
      <summary>
            Internal extension helpers for NuGet.Commands
            </summary>
    </member>
    <member name="M:NuGet.Commands.Extensions.LogMessagesAsync(NuGet.Common.ILogger,NuGet.Common.ILogMessage[])">
      <summary>
            Log all messages.
            </summary>
    </member>
    <member name="M:NuGet.Commands.Extensions.LogMessagesAsync(NuGet.Common.ILogger,System.Collections.Generic.IEnumerable{NuGet.Common.ILogMessage})">
      <summary>
            Log all messages.
            </summary>
    </member>
    <member name="M:NuGet.Commands.Extensions.AsRestoreLogMessage(NuGet.ProjectModel.IAssetsLogMessage)">
      <summary>
            Converts an IAssetsLogMessage into a RestoreLogMessage.
            This is needed when an IAssetsLogMessage needs to be logged and loggers do not have visibility to IAssetsLogMessage.
            </summary>
      <param name="logMessage">IAssetsLogMessage to be converted.</param>
      <returns>RestoreLogMessage equivalent to the IAssetsLogMessage.</returns>
    </member>
    <member name="M:NuGet.Commands.Extensions.AsRestoreLogMessage(NuGet.Common.LogMessage)">
      <summary>
            Converts an LogMessage into a RestoreLogMessage.
            This is needed when an LogMessage needs to be logged and loggers do not have visibility to LogMessage.
            </summary>
      <param name="logMessage">LogMessage to be converted.</param>
      <returns>RestoreLogMessage equivalent to the LogMessage.</returns>
    </member>
    <member name="M:NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFrameworkStrings(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
      <summary>
            Determine the target framework of an msbuild project.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFrameworkStrings(System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.Boolean,System.Boolean)">
      <summary>
            Determine the target framework of an msbuild project.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFrameworks(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Parse project framework strings into NuGetFrameworks.
            </summary>
    </member>
    <member name="M:NuGet.Commands.MSBuildProjectFrameworkUtility.GetProjectFrameworkReplacement(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Parse existing nuget framework for .net core 4.5.1 or 4.5 and return compatible framework instance
            </summary>
    </member>
    <member name="M:NuGet.Commands.RequestRuntimeUtility.GetRestoreRuntimes(NuGet.Commands.RestoreRequest)">
      <summary>
            Combines the project runtimes with the request.RequestedRuntimes.
            If those are both empty FallbackRuntimes is returned.
            </summary>
    </member>
    <member name="M:NuGet.Commands.RequestRuntimeUtility.GetDefaultRestoreRuntimes(System.String,System.String)">
      <summary>
            Infer the runtimes from the current environment.
            </summary>
    </member>
    <member name="T:NuGet.Commands.VerifyArgs.Verification">
      <summary>
            Available types of verification.
            </summary>
    </member>
    <member name="P:NuGet.Commands.VerifyArgs.Verifications">
      <summary>
            Types of verifications to be performed.
            </summary>
    </member>
    <member name="P:NuGet.Commands.VerifyArgs.PackagePath">
      <summary>
            Path to the package that has to be signed.
            </summary>
    </member>
    <member name="P:NuGet.Commands.VerifyArgs.Logger">
      <summary>
            Logger to be used to display the logs during the execution of sign command.
            </summary>
    </member>
    <member name="P:NuGet.Commands.VerifyArgs.LogLevel">
      <summary>
            Amount of detail the logger should receive
            </summary>
    </member>
    <member name="P:NuGet.Commands.VerifyArgs.CertificateFingerprint">
      <summary>
            If not empty, signer certificate fingerprint must match one in this list
            </summary>
    </member>
    <member name="T:NuGet.Commands.VerifyCommandRunner">
      <summary>
            Command Runner used to run the business logic for nuget verify command
            </summary>
    </member>
    <member name="M:NuGet.Commands.SignCommand.IPasswordProvider.GetPassword(System.String,System.Threading.CancellationToken)">
      <summary>
            Requests user to input password and returns it as a SecureString.
            </summary>
      <param name="filePath">Path to the file that needs a password to open.</param>
      <param name="token">Cancellation token.</param>
      <returns>SecureString containing the user input password. The SecureString should be disposed after use.</returns>
    </member>
    <member name="M:NuGet.Shared.NuGet.Common474215.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Common474215.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Common474215.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Common474215.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Common474215.HashCodeCombiner.GetHashCode``2(``0,``1)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Common474215.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Common474215.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
      <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
    </member>
    <member name="M:NuGet.Shared.NuGet.Common474215.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
    </member>
    <member name="T:NuGet.Common.ActivityCorrelationId">
      <summary>
            Ambient correlation ID used to associate information pertaining to a current activity. A single activity
            engages multiple method calls at different layers. Sometimes it's necessary to identify separate calls
            belonging to the same activity if shared state is needed.
            </summary>
    </member>
    <member name="M:NuGet.Common.ActivityCorrelationId.StartNew">
      <summary>
            Starts a new activity activity correlation ID by updating ambient context value.
            </summary>
    </member>
    <member name="P:NuGet.Common.ActivityCorrelationId.Current">
      <summary>
            Returns current activity correlation ID or a default if not set previously.
            </summary>
    </member>
    <member name="T:NuGet.Common.AggregateEnumerableAsync`1">
      <summary>
            Aggregates from a list of already ordered enumerables
            The ordered result will contain only unique values
            If comparer/EqualityComparer are not provided the default ones for that type will be used.
            If the provided enumerables are not sorted already, the behavior is undefined
            </summary>
    </member>
    <member name="T:NuGet.Common.AggregateEnumeratorAsync`1">
      <summary>
            Aggregates from a list of already ordered enumerables
            The ordered result will contain only unique values
            If comparer/EqualityComparer are not provided the default ones for that type will be used.
            If the provided enumerables are not sorted already, the behavior is undefined
            </summary>
    </member>
    <member name="T:NuGet.Common.IEnumeratorAsync`1">
      <summary>
            Supports async iteration over a generic collection.
            Prior to calling Current, MoveNextAsync needs to be called otherwise the behavior is undefined 
            </summary>
      <typeparam name="T">The type of objects to enumerate.This type parameter is covariant. That is, you can use either the type you specified or any type that is more derived. For more information about covariance and contravariance, see Covariance and Contravariance in Generics.</typeparam>
      <filterpriority>1</filterpriority>
    </member>
    <member name="M:NuGet.Common.IEnumeratorAsync`1.MoveNextAsync">
      <summary>
            Moves the pointer to the next element in the collection. 
            </summary>
      <returns>
            Success status of the pointer move
            </returns>
    </member>
    <member name="P:NuGet.Common.IEnumeratorAsync`1.Current">
      <summary>
            Gets the element in the collection at the current position of the enumerator.
            If <ref>MoveNextAsync</ref> has not been called prior to calling current the behavior is undefined
            If the last <ref>MoveNextAsync</ref> call returned false then the next call to Current should throw an InvalidOperationException
            </summary>
      <returns>
            The element in the collection at the current position of the enumerator.
            </returns>
    </member>
    <member name="T:NuGet.Common.AsyncLazy`1">
      <summary>
            Wrapper class representing shorter syntax of Lazy&lt;Task&lt;T&gt;&gt;"/&gt;.
            Useful when declaring a lazy async factory of value T.
            </summary>
      <typeparam name="T">Value type</typeparam>
    </member>
    <member name="T:NuGet.Common.AsyncLazy">
      <summary>
            Shortcuts to common Lazy&lt;Task&lt;T&gt;&gt; constructor calls
            </summary>
    </member>
    <member name="M:NuGet.Common.ClientVersionUtility.GetNuGetAssemblyVersion">
      <summary>
            Find the current NuGet client version from the assembly info as a string.
            If no value can be found an InvalidOperationException will be thrown.
            </summary>
      <remarks>This can contain prerelease labels if AssemblyInformationalVersionAttribute exists.</remarks>
    </member>
    <member name="T:NuGet.Common.CryptoHashProvider">
      <summary>
            CryptoHashProvider helps calculate or verify hash based on SHA256 or SHA512 algorithms
            </summary>
    </member>
    <member name="F:NuGet.Common.CryptoHashProvider.SHA512HashAlgorithm">
      <summary>
            Server token used to represent that the hash being used is SHA 512
            </summary>
    </member>
    <member name="F:NuGet.Common.CryptoHashProvider.SHA256HashAlgorithm">
      <summary>
            Server token used to represent that the hash being used is SHA 256
            </summary>
    </member>
    <member name="M:NuGet.Common.CryptoHashProvider.#ctor">
      <summary>
            Creates an instance of CryptoHashProvider. Since the algorithm is not specified, SHA512 is assumed
            </summary>
    </member>
    <member name="M:NuGet.Common.CryptoHashProvider.#ctor(System.String)">
      <summary>
            Creates an instance of CryptoHashProvider using the hashAlgorithm
            </summary>
    </member>
    <member name="M:NuGet.Common.CryptoHashProvider.CalculateHash(System.IO.Stream)">
      <summary>
            Calculates the hash for a given stream
            </summary>
    </member>
    <member name="M:NuGet.Common.CryptoHashProvider.CalculateHash(System.Byte[])">
      <summary>
            Calculates the hash for a byte array
            </summary>
    </member>
    <member name="M:NuGet.Common.CryptoHashProvider.VerifyHash(System.Byte[],System.Byte[])">
      <summary>
            Verifies the hash for the given data and hash
            </summary>
    </member>
    <member name="M:NuGet.Common.CryptoHashUtility.ComputeHashAsBase64(System.Security.Cryptography.HashAlgorithm,System.IO.Stream)">
      <summary>
            Compute the hash as a base64 encoded string.
            </summary>
      <remarks>Closes the stream by default.</remarks>
      <param name="hashAlgorithm">Algorithm to use for hashing.</param>
      <param name="data">Stream to hash.</param>
    </member>
    <member name="M:NuGet.Common.CryptoHashUtility.ComputeHashAsBase64(System.Security.Cryptography.HashAlgorithm,System.IO.Stream,System.Boolean)">
      <summary>
            Compute the hash as a base64 encoded string.
            </summary>
      <param name="hashAlgorithm">Algorithm to use for hashing.</param>
      <param name="data">Stream to hash.</param>
      <param name="leaveStreamOpen">If false the stream will be closed.</param>
      <returns>A base64 encoded hash string.</returns>
    </member>
    <member name="M:NuGet.Common.CryptoHashUtility.ComputeHash(NuGet.Common.HashAlgorithmName,System.Byte[])">
      <summary>
            Compute the hash as a byte[].
            </summary>
    </member>
    <member name="M:NuGet.Common.CryptoHashUtility.ComputeHash(System.Security.Cryptography.HashAlgorithm,System.IO.Stream)">
      <summary>
            Compute the hash as a byte[].
            </summary>
      <remarks>Closes the stream by default.</remarks>
      <param name="hashAlgorithm">Algorithm to use for hashing.</param>
      <param name="data">Stream to hash.</param>
      <returns>A hash byte[].</returns>
    </member>
    <member name="M:NuGet.Common.CryptoHashUtility.ComputeHash(System.Security.Cryptography.HashAlgorithm,System.IO.Stream,System.Boolean)">
      <summary>
            Compute the hash as a byte[].
            </summary>
      <param name="hashAlgorithm">Algorithm to use for hashing.</param>
      <param name="data">Stream to hash.</param>
      <param name="leaveStreamOpen">If false the stream will be closed.</param>
      <returns>A hash byte[].</returns>
    </member>
    <member name="M:NuGet.Common.CryptoHashUtility.ReadFipsConfigValue">
      <summary>
            Determines if we are to only allow Fips compliant algorithms.
            </summary>
      <remarks>
            CryptoConfig.AllowOnlyFipsAlgorithm does not exist in Mono.
            </remarks>
    </member>
    <member name="M:NuGet.Common.CryptoHashUtility.ConvertToSystemSecurityHashAlgorithmName(NuGet.Common.HashAlgorithmName)">
      <summary>
            Extension method to convert NuGet.Common.HashAlgorithmName to System.Security.Cryptography.HashAlgorithmName
            </summary>
      <returns>System.Security.Cryptography.HashAlgorithmName equivalent of the NuGet.Common.HashAlgorithmName</returns>
    </member>
    <member name="M:NuGet.Common.CryptoHashUtility.ConvertToOidString(NuGet.Common.HashAlgorithmName)">
      <summary>
            Extension method to convert NuGet.Common.HashAlgorithmName to an Oid string
            </summary>
      <returns>Oid string equivalent of the NuGet.Common.HashAlgorithmName</returns>
    </member>
    <member name="M:NuGet.Common.CryptoHashUtility.ConvertToOid(NuGet.Common.HashAlgorithmName)">
      <summary>
            Extension method to convert NuGet.Common.HashAlgorithmName to an OID
            </summary>
      <returns>OID equivalent of the NuGet.Common.HashAlgorithmName</returns>
    </member>
    <member name="M:NuGet.Common.CryptoHashUtility.OidToHashAlgorithmName(System.String)">
      <summary>
            Helper method to convert an Oid string to NuGet.Common.HashAlgorithmName
            </summary>
      <param name="oid">An oid string.</param>
      <returns>NuGet.Common.HashAlgorithmName equivalent of the oid string</returns>
    </member>
    <member name="M:NuGet.Common.CryptoHashUtility.ConvertToOidString(NuGet.Common.SignatureAlgorithmName)">
      <summary>
            Extension method to convert NuGet.Common.SignatureAlgorithmName to an Oid string
            </summary>
      <returns>Oid string equivalent of the NuGet.Common.SignatureAlgorithmName</returns>
    </member>
    <member name="T:NuGet.Common.DatetimeUtility">
      <summary>
            static class to provide datetime common utility apis
            </summary>
    </member>
    <member name="M:NuGet.Common.DatetimeUtility.ToReadableTimeFormat(System.TimeSpan)">
      <summary>
            take timespan n return in appropriate unit like ms, or seconds, or minutes, or hours
            </summary>
      <param name="time">timespan</param>
      <returns>
      </returns>
    </member>
    <member name="P:NuGet.Common.ILogFileContext.FilePath">
      <summary>
            Indicates the file for which the error was thrown.
            </summary>
    </member>
    <member name="P:NuGet.Common.ILogFileContext.StartLineNumber">
      <summary>
            Indicates the starting line for which the error was thrown.
            </summary>
    </member>
    <member name="P:NuGet.Common.ILogFileContext.StartColumnNumber">
      <summary>
            Indicates the starting column for which the error was thrown.
            </summary>
    </member>
    <member name="P:NuGet.Common.ILogFileContext.EndLineNumber">
      <summary>
            Indicates the ending line for which the error was thrown.
            </summary>
    </member>
    <member name="P:NuGet.Common.ILogFileContext.EndColumnNumber">
      <summary>
            Indicates the ending column for which the error was thrown.
            </summary>
    </member>
    <member name="P:NuGet.Common.ILogMessage.Level">
      <summary>
            Level to indicate if this is an error or warning.
            </summary>
    </member>
    <member name="P:NuGet.Common.ILogMessage.WarningLevel">
      <summary>
            Level to indicate the warning level for the message.
            This is relevant only if the Level == LogLevel.Warning.
            </summary>
    </member>
    <member name="P:NuGet.Common.ILogMessage.Code">
      <summary>
            Indicates the NuGet error code.
            </summary>
    </member>
    <member name="P:NuGet.Common.ILogMessage.Message">
      <summary>
            Indicates the staring generated by the code to go with the error code.
            </summary>
    </member>
    <member name="P:NuGet.Common.ILogMessage.ProjectPath">
      <summary>
            Indicates the project for which the error was thrown.
            </summary>
    </member>
    <member name="P:NuGet.Common.ILogMessage.Time">
      <summary>
            Indicates the date time at which the error occurred.
            </summary>
    </member>
    <member name="T:NuGet.Common.ILogMessageException">
      <summary>
            Allows converting an Exception to an ILogMessage.
            </summary>
    </member>
    <member name="M:NuGet.Common.ILogMessageException.AsLogMessage">
      <summary>
            Retrieve the exception as a log message.
            </summary>
    </member>
    <member name="P:NuGet.Common.IRestoreLogMessage.LibraryId">
      <summary>
            Project or Package Id.
            </summary>
    </member>
    <member name="P:NuGet.Common.IRestoreLogMessage.TargetGraphs">
      <summary>
            List of TargetGraphs.
            </summary>
    </member>
    <member name="P:NuGet.Common.IRestoreLogMessage.ShouldDisplay">
      <summary>
            Bool indicating if this message needs to be logged to the inner logger.
            </summary>
    </member>
    <member name="T:NuGet.Common.LogMessage">
      <summary>
            Basic log message.
            </summary>
    </member>
    <member name="T:NuGet.Common.NuGetLogCode">
      <summary>
             This enum is used to quantify NuGet error and warning codes. 
             Format - NUxyzw where NU is the profix indicating NuGet and xyzw is a 4 digit code
            
             Numbers - xyzw
                 x - 'x' is the largest digit and should be used to quantify a set of errors.
                     For example 1yzw are set of restore related errors and no other code path should use the range 1000 to 1999 for errors or warnings.
                     
                 y - 'y' is the second largest digit and should be used for sub sections withing a broad category.
                 
                     For example 12zw cvould be http related errors.
                     Further 'y' = 0-4 should be used for errors and 'y' = 5-9 should be warnings.
                     
                 zw - 'zw' are the least two digit.
                     These could be used for different errors or warnings within the broad categories set by digits 'xy'.
            
             Groups:
             1000-1999 - Restore
             3000-3999 - Signing
             5000-5999 - Packaging
            
             Sub groups for Restore:
             error/warning - Reason
             1000/1500     - Input
             1100/1600     - Resolver
             1200/1700     - Compat
             1300/1800     - Feed
             1400/1900     - Package
             </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.Undefined">
      <summary>
            Do not display the code.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1000">
      <summary>
            Undefined error
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1001">
      <summary>
            Project has zero target frameworks.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1002">
      <summary>
            Invalid combination with CLEAR
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1003">
      <summary>
            Invalid combination of PTF and ATF
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1100">
      <summary>
            Unable to resolve package, generic message for unknown type constraints.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1101">
      <summary>
            No versions of the package exist on any of the sources.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1102">
      <summary>
            Versions of the package exist, but none are in the range.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1103">
      <summary>
            Range does not allow prerelease packages and only prerelease versions were found
            within the range.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1104">
      <summary>
            Project path does not exist on disk.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1105">
      <summary>
            Project reference was not in the dg spec.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1106">
      <summary>
            Resolver conflict
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1107">
      <summary>
            Version conflict.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1108">
      <summary>
            Circular dependency.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1201">
      <summary>
            Dependency project has an incompatible framework.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1202">
      <summary>
            Dependency package does not contain assets for the current framework.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1203">
      <summary>
            un-matched reference assemblies
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1204">
      <summary>
            Invalid package types
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1211">
      <summary>
            project has an invalid dependency count
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1212">
      <summary>
            Incompatible tools package/project combination
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1401">
      <summary>
            Package MinClientVersion did not match.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1402">
      <summary>
            Package contains unsafe zip entry.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1410">
      <summary>
            Package Signature is invalid
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1500">
      <summary>
            Undefined warning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1501">
      <summary>
            Missing restore target.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1502">
      <summary>
            Unknown compatibility profile
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1503">
      <summary>
            Skipping project that does not support restore.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1601">
      <summary>
            Dependency bumped up
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1602">
      <summary>
            Non-exact match on dependency range due to non inclusive minimum bound.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1603">
      <summary>
            Non-exact match on dependency range due to missing package version.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1604">
      <summary>
            Project dependency does not include a lower bound.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1605">
      <summary>
            Package dependency downgraded.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1608">
      <summary>
            Version is higher than upper bound.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1701">
      <summary>
            Fallback framework used.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU1801">
      <summary>
            Feed error converted to a warning when ignoreFailedSources is true.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3000">
      <summary>
            Undefined signature error
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3001">
      <summary>
            Invalid input error
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3002">
      <summary>
            The '-Timestamper' option was not provided. The signed package will not be timestamped.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3003">
      <summary>
            The package signature is invalid.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3004">
      <summary>
            The package is not signed.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3005">
      <summary>
            The package signature file entry is invalid.
            </summary>
      <remarks>
            Examples which would trigger this include:
                * the entry has incorrect external file attributes
                * the entry is compressed not stored
                * the entry's compressed and uncompressed sizes differ
            </remarks>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3006">
      <summary>
            Signed Zip64 packages are not supported.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3007">
      <summary>
            The package signature format version is not supported.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3008">
      <summary>
            The package integrity check failed.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3009">
      <summary>
            The package signature file does not contain exactly one primary signature.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3010">
      <summary>
            The primary signature does not have a signing certificate.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3011">
      <summary>
            The primary signature is invalid.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3012">
      <summary>
            Primary signature validation failed.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3013">
      <summary>
            The signing certificate has an unsupported signature algorithm.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3014">
      <summary>
            The signing certificate does not meet a minimum public key length requirement.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3015">
      <summary>
            Certificates with lifetime signer EKU are not supported.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3016">
      <summary>
            The package hash uses an unsupported hash algorithm.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3017">
      <summary>
            The signing certificate is not yet valid.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3018">
      <summary>
            Chain building failed for primary signature
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3019">
      <summary>
            The timestamp integrity check failed.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3020">
      <summary>
            The timestamp signature does not have a signing certificate.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3021">
      <summary>
            Timestamp signature validation failed.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3022">
      <summary>
            The timestamp certificate has an unsupported signature algorithm.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3023">
      <summary>
            The timestamp's certificate does not meet a minimum public key length requirement.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3024">
      <summary>
            The timestamp signing certificate has an unsupported signature algorithm.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3025">
      <summary>
            The timestamp signing certificate is not yet valid.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3026">
      <summary>
            The timestamp response is invalid.  Nonces did not match.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3027">
      <summary>
            The primary signature should be timestamped to enable long-term signature validity after the certificate has expired.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3028">
      <summary>
            Chain building failed for timestamp
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3029">
      <summary>
            The timestamp signature is invalid.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3030">
      <summary>
            The timestamp's message imprint uses an unsupported hash algorithm.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3031">
      <summary>
            The repository countersignature is invalid.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3032">
      <summary>
            The package signature contains multiple repository countersignatures.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3033">
      <summary>
            A repository primary signature must not have a repository countersignature.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3034">
      <summary>
            The package signature certificate does not match the trusted certificate list.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3035">
      <summary>
            Chain building failed for the repository countersignature.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3036">
      <summary>
            Timestamp Generalized time is outside certificate's valdity period
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3037">
      <summary>
            The signature has expired.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU3038">
      <summary>
            Verification settings require a repository countersignature, but the package does not have a repository countersignature.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5000">
      <summary>
            Undefined Package Error.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5001">
      <summary>
            Error_WriteResolvedNuSpecOverwriteOriginal
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5002">
      <summary>
            Error_InputFileNotSpecified
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5003">
      <summary>
            Error_InvalidTargetFramework
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5004">
      <summary>
            Error_PackageCommandNoFilesForLibPackage
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5005">
      <summary>
            Error_PackageCommandNoFilesForSymbolsPackage
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5006">
      <summary>
            Error_PackFailed
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5007">
      <summary>
            Error_UnableToLocateBuildOutput
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5008">
      <summary>
            ErrorManifestFileNotFound
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5009">
      <summary>
            Error_CannotFindMsbuild
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5010">
      <summary>
            Error_InvalidVersionInPackage
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5011">
      <summary>
            Error_UnableToExtractAssemblyMetadata
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5012">
      <summary>
            Error_UnableToFindBuildOutput
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5013">
      <summary>
            Error_FailedToBuildProject
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5014">
      <summary>
            Error_ProcessingNuspecFile
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5015">
      <summary>
            Error_MultipleTargetFrameworks
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5016">
      <summary>
            Error_InvalidDependencyVersionConstraints
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5017">
      <summary>
            Error_CannotCreateEmptyPackage
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5018">
      <summary>
            Error_Manifest_InvalidReference
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5019">
      <summary>
            Error_PackageAuthoring_FileNotFound
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5020">
      <summary>
            Error_EmptySourceFilePath
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5021">
      <summary>
            Error_EmptySourceFileProjectDirectory
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5022">
      <summary>
            Error_InvalidMinClientVersion
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5023">
      <summary>
            Error_AssetsFileNotFound
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5024">
      <summary>
            Error_InvalidPackageVersion
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5025">
      <summary>
            Error_AssetsFileDoesNotHaveValidPackageSpec
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5026">
      <summary>
            Error_FileNotFound
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5027">
      <summary>
            Error_InvalidTargetFramework
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5028">
      <summary>
            Error_NoPackItemProvided
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5029">
      <summary>
            Error_InvalidNuspecProperties
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5100">
      <summary>
            AssemblyOutsideLibWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5101">
      <summary>
            AssemblyDirectlyUnderLibWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5102">
      <summary>
            DefaultSpecValueWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5103">
      <summary>
            InvalidFrameworkWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5104">
      <summary>
            InvalidPrereleaseDependencyWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5105">
      <summary>
            LegacyVersionWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5106">
      <summary>
            WinRTObsoleteWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5107">
      <summary>
            MisplacedInitScriptWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5108">
      <summary>
            MisplacedTransformFileWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5109">
      <summary>
            PlaceholderFileInPackageWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5110">
      <summary>
            ScriptOutsideToolsWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5111">
      <summary>
            UnrecognizedScriptWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5112">
      <summary>
            UnspecifiedDependencyVersionWarning
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5113">
      <summary>
            Warning_SemanticVersion
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5114">
      <summary>
            Warning_DuplicatePropertyKey
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5115">
      <summary>
            Warning_UnspecifiedField
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5116">
      <summary>
            Warning_FileDoesNotExist
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5117">
      <summary>
            Warning_UnresolvedFilePath
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5118">
      <summary>
            Warning_FileNotAddedToPackage
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5119">
      <summary>
            Warning_FileExcludedByDefault
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5120">
      <summary>
            Migrator_PackageHasInstallScript
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5121">
      <summary>
            Migrator_PackageHasContentFolder
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5122">
      <summary>
            Migrator_XdtTransformInPackage
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5123">
      <summary>
            Warning_FilePathTooLong
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetLogCode.NU5500">
      <summary>
            Undefined package warning
            </summary>
    </member>
    <member name="M:NuGet.Common.PackagingLogMessage.#ctor(NuGet.Common.LogLevel,NuGet.Common.NuGetLogCode,System.String)">
      <summary>
            Initializes a new instance of the PackLogMessage class
            </summary>
      <param name="logLevel">The log level</param>
      <param name="logCode">The NuGet log code</param>
      <param name="message">The log message</param>
    </member>
    <member name="M:NuGet.Common.PackagingLogMessage.CreateError(System.String,NuGet.Common.NuGetLogCode)">
      <summary>
            Create an error log message.
            </summary>
      <param name="code">The logging code</param>
      <param name="message">The log message</param>
    </member>
    <member name="M:NuGet.Common.PackagingLogMessage.GetDefaultLogCode(NuGet.Common.LogLevel)">
      <summary>
            Get default LogCode based on the log level
            </summary>
      <param name="logLevel">The log level</param>
    </member>
    <member name="M:NuGet.Common.RestoreLogMessage.CreateWarning(NuGet.Common.NuGetLogCode,System.String,System.String,System.String[])">
      <summary>
            Create a log message for a target graph library.
            </summary>
    </member>
    <member name="M:NuGet.Common.RestoreLogMessage.CreateWarning(NuGet.Common.NuGetLogCode,System.String)">
      <summary>
            Create a warning log message.
            </summary>
    </member>
    <member name="M:NuGet.Common.RestoreLogMessage.CreateError(NuGet.Common.NuGetLogCode,System.String)">
      <summary>
            Create an error log message.
            </summary>
    </member>
    <member name="M:NuGet.Common.RestoreLogMessage.CreateError(NuGet.Common.NuGetLogCode,System.String,System.String,System.String[])">
      <summary>
            Create an error log message for a target graph.
            </summary>
    </member>
    <member name="M:NuGet.Common.RestoreLogMessage.GetDefaultLogCode(NuGet.Common.LogLevel)">
      <summary>
            Get default LogCode based on the log level
            </summary>
    </member>
    <member name="T:NuGet.Common.WarningLevel">
      <summary>
            These are Warning Levels used by NuGet while throwing warnings.
            These logically correspond to .NET spec at https://msdn.microsoft.com/en-us/library/13b90fz7(v=vs.140).aspx
            
            We do not have a level 0 as that has no logical meaning of having a warning with level 0.
            
            Severe - This should be used to throw warnings that are just short of being an error.
            
            Important - Lower level than severe. 
            
            Minimal - Lower level than important. 
            
            Default - Lowest level of warnings. 
                      Default NuGet logging will ignore these warnings.
            </summary>
    </member>
    <member name="T:NuGet.Common.ExceptionUtilities">
      <summary>
            For internal use only
            </summary>
    </member>
    <member name="M:NuGet.Common.ExceptionUtilities.LogException(System.Exception,NuGet.Common.ILogger)">
      <summary>
            Log an exception to an ILogger.
            This will log using NU1000 if the exception does not contain a code.
            </summary>
    </member>
    <member name="M:NuGet.Common.ExceptionUtilities.LogException(System.Exception,NuGet.Common.ILogger,System.Boolean)">
      <summary>
            Log an exception to an ILogger.
            This will log using NU1000 if the exception does not contain a code.
            </summary>
    </member>
    <member name="P:NuGet.Common.ExceptionLogger.ShowStack">
      <summary>
            Determines whether the full exception (including stack trace) should be displayed to
            the user. In prerelease or dogfooding scenarios, it is useful to have a non-verbose
            logging level but, in the case of an unhandled exception, print the full exception for
            bug reporting.
            </summary>
      <returns>
            True if the exception stack should be displayed to the user. False, otherwise.
            </returns>
    </member>
    <member name="P:NuGet.Common.ICollectorLogger.Errors">
      <summary>
            Fetch all of the errors logged so far. This method is useful when error log messages
            should be redisplayed after the initial log message is emitted.
            </summary>
    </member>
    <member name="T:NuGet.Common.ILogger">
      <summary>
            A generic interface for logging.
            </summary>
    </member>
    <member name="T:NuGet.Common.LegacyLoggerAdapter">
      <summary>
            Call legacy Log* methods from LogAsync/Log.
            This is for legacy ILogger implementations,
            new loggers should use LoggerBase.
            </summary>
    </member>
    <member name="M:NuGet.Common.LoggerBase.DisplayMessage(NuGet.Common.LogLevel)">
      <summary>
            True if the message meets the verbosity level.
            </summary>
    </member>
    <member name="M:NuGet.Common.LoggerBase.CollectMessage(NuGet.Common.LogLevel)">
      <summary>
            True if the message is an error or warning.
            </summary>
    </member>
    <member name="M:NuGet.Common.LoggingExtensions.FormatWithCode(NuGet.Common.ILogMessage)">
      <summary>
            Formats a ILogMessage into a string representation containg the log code and message.
            The log code is added only if it is a valid NuGetLogCode and is greater than NuGetLogCode.Undefined.
            </summary>
      <param name="message">ILogMessage to be formatted.</param>
      <returns>string representation of the ILogMessage.</returns>
    </member>
    <member name="M:NuGet.Common.LoggingExtensions.GetName(NuGet.Common.NuGetLogCode)">
      <summary>
            Formats a NuGetLogCode into a string representation.
            </summary>
      <param name="code">NuGetLogCode to be formatted into string.</param>
      <returns>strings representation of the NuGetLogCode.</returns>
    </member>
    <member name="M:NuGet.Common.LoggingExtensions.TryGetName(NuGet.Common.NuGetLogCode,System.String@)">
      <summary>
            Tries to get the string from the NuGetLogCode enum.
            </summary>
      <param name="code">NuGetLogCode to be formatted into string.</param>
      <param name="codeString">strings representation of the NuGetLogCode if the result is true else null.</param>
      <returns>bool indcating if the GetName operation was successfull or not.</returns>
    </member>
    <member name="M:NuGet.Common.MSBuildStringUtility.Split(System.String)">
      <summary>
            Split on ; and trim. Null or empty inputs will return an
            empty array.
            </summary>
    </member>
    <member name="M:NuGet.Common.MSBuildStringUtility.Split(System.String,System.Char[])">
      <summary>
            Split on ; and trim. Null or empty inputs will return an
            empty array.
            </summary>
    </member>
    <member name="M:NuGet.Common.MSBuildStringUtility.TrimAndGetNullForEmpty(System.String)">
      <summary>
            Trims the provided string and converts empty strings to null.
            </summary>
    </member>
    <member name="M:NuGet.Common.MSBuildStringUtility.TrimAndExcludeNullOrEmpty(System.String[])">
      <summary>
            Trims the provided strings and excludes empty or null strings.
            </summary>
    </member>
    <member name="M:NuGet.Common.MSBuildStringUtility.IsTrue(System.String)">
      <summary>
            True if the property is set to true
            </summary>
    </member>
    <member name="M:NuGet.Common.MSBuildStringUtility.IsTrueOrEmpty(System.String)">
      <summary>
            True if the property is set to true or empty.
            </summary>
    </member>
    <member name="M:NuGet.Common.MSBuildStringUtility.GetNuGetLogCodes(System.String)">
      <summary>
            Splits and parses a ; or , delimited list of log codes.
            Ignores codes that are unknown.
            </summary>
    </member>
    <member name="M:NuGet.Common.MSBuildStringUtility.Convert(System.String)">
      <summary>
            Convert the provided string to MSBuild style.
            </summary>
    </member>
    <member name="M:NuGet.Common.MSBuildStringUtility.GetDistinctNuGetLogCodesOrDefault(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{NuGet.Common.NuGetLogCode}})">
      <summary>
            Return empty list of NuGetLogCode if all lists of NuGetLogCode are not the same. 
            </summary>
    </member>
    <member name="M:NuGet.Common.NetworkProtocolUtility.ConfigureSupportedSslProtocols">
      <summary>
            This only has effect on .NET Framework (desktop). On .NET Core,
            <see cref="T:System.Net.ServicePointManager" /> is not available. Additionally,
            no API is available to configure the supported SSL protocols.
            </summary>
    </member>
    <member name="M:NuGet.Common.NetworkProtocolUtility.SetConnectionLimit">
      <summary>
            Set ServicePointManager.DefaultConnectionLimit
            </summary>
    </member>
    <member name="T:NuGet.Common.DirectoryUtility">
      <summary>
            Directory operation helpers.
            </summary>
    </member>
    <member name="M:NuGet.Common.DirectoryUtility.CreateSharedDirectory(System.String)">
      <summary>
            Creates all directories and subdirectories in the specified path unless they already exist.
            New directories can be read and written by all users.
            </summary>
    </member>
    <member name="T:NuGet.Common.FileUtility">
      <summary>
            File operation helpers.
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.GetTempFilePath(System.String)">
      <summary>
            Get the full path to a new temp file
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.DeleteWithLock(System.String)">
      <summary>
            Lock around the output path.
            Delete the existing file with retries.
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.ReplaceWithLock(System.Action{System.String},System.String)">
      <summary>
            Lock around the output path.
            Delete the existing file with retries.
            Move a file with retries.
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.Replace(System.Action{System.String},System.String)">
      <summary>
            Delete the existing file with retries.
            Move a file with retries.
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.Replace(System.String,System.String)">
      <summary>
            Delete the existing file with retries.
            Move a file with retries.
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.Move(System.String,System.String)">
      <summary>
            Move a file with retries.
            This will not overwrite
            </summary>
    </member>
    <member name="M:NuGet.Common.FileUtility.Delete(System.String)">
      <summary>
            Delete a file with retries.
            </summary>
    </member>
    <member name="T:NuGet.Common.INuGetPathContext">
      <summary>
            Common NuGet paths. These values may be overridden in NuGet.Config or by 
            environment variables, resolving the paths here requires NuGet.Configuration.
            </summary>
    </member>
    <member name="P:NuGet.Common.INuGetPathContext.UserPackageFolder">
      <summary>
            User package folder directory.
            </summary>
    </member>
    <member name="P:NuGet.Common.INuGetPathContext.FallbackPackageFolders">
      <summary>
            Fallback package folder locations.
            </summary>
    </member>
    <member name="P:NuGet.Common.INuGetPathContext.HttpCacheFolder">
      <summary>
            Http file cache.
            </summary>
    </member>
    <member name="T:NuGet.Common.NuGetEnvironment.SpecialFolder">
      <summary>
            Since <see cref="T:System.Environment.SpecialFolder" /> is not available on .NET Core, we have to
            make our own and re-implement the functionality. On .NET Framework, we can use the
            built-in functionality.
            </summary>
    </member>
    <member name="M:NuGet.Common.NuGetEnvironment.GetValueOrThrowMissingEnvVarsDotnet(System.Func{System.String},System.String,System.String)">
      <summary>
            Throw a helpful message if the required env vars are not set.
            </summary>
    </member>
    <member name="M:NuGet.Common.NuGetEnvironment.GetValueOrThrowMissingEnvVar(System.Func{System.String},System.String)">
      <summary>
            Throw a helpful message if a required env var is not set.
            </summary>
    </member>
    <member name="M:NuGet.Common.PathResolver.GetMatches``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Returns a collection of files from the source that matches the wildcard.
            </summary>
      <param name="source">The collection of files to match.</param>
      <param name="getPath">Function that returns the path to filter a package file </param>
      <param name="wildcards">The wildcards to apply to match the path with.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Common.PathResolver.FilterPackageFiles``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.String},System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Removes files from the source that match any wildcard.
            </summary>
    </member>
    <member name="M:NuGet.Common.PathResolver.IsWildcardSearch(System.String)">
      <summary>
            Returns true if the path contains any wildcard characters.
            </summary>
    </member>
    <member name="M:NuGet.Common.PathUtility.GetStringComparerBasedOnOS">
      <summary>
            Returns OrdinalIgnoreCase windows and mac. Ordinal for linux.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Common.PathUtility.GetUniquePathsBasedOnOS(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Returns distinct orderd paths based on the file system case sensitivity.
            </summary>
    </member>
    <member name="M:NuGet.Common.PathUtility.GetPathWithForwardSlashes(System.String)">
      <summary>
            Replace all back slashes with forward slashes.
            If the path does not contain a back slash
            the original string is returned.
            </summary>
    </member>
    <member name="M:NuGet.Common.PathUtility.GetRelativePath(System.String,System.String)">
      <summary>
            Returns path2 relative to path1, with Path.DirectorySeparatorChar as separator
            </summary>
    </member>
    <member name="M:NuGet.Common.PathUtility.GetRelativePath(System.String,System.String,System.Char)">
      <summary>
            Returns path2 relative to path1, with given path separator
            </summary>
    </member>
    <member name="M:NuGet.Common.PathValidator.IsValidSource(System.String)">
      <summary>
            Validates that a source is a valid path or url.
            </summary>
      <param name="source">The path to validate.</param>
      <returns>True if valid, False if invalid.</returns>
    </member>
    <member name="M:NuGet.Common.PathValidator.IsValidLocalPath(System.String)">
      <summary>
            Validates that path is properly formatted as a local path. 
            </summary>
      <remarks>
            On Windows, a valid local path must starts with the drive letter.
            Example: C:\, C:\path, C:\path\to\
            Bad: C:\invalid\*\"\chars
            </remarks>
      <param name="path">The path to validate.</param>
      <returns>True if valid, False if invalid.</returns>
    </member>
    <member name="M:NuGet.Common.PathValidator.IsValidUncPath(System.String)">
      <summary>
            Validates that path is properly formatted as an UNC path. 
            </summary>
      <remarks>
            Example: \\server\share, \\server\share\path, \\server\share\path\to\
            Bad: \\server\invalid\*\"\chars
            </remarks>
      <param name="path">The path to validate.</param>
      <returns>True if valid, False if invalid.</returns>
    </member>
    <member name="M:NuGet.Common.PathValidator.IsValidUrl(System.String)">
      <summary>
            Validates that url is properly formatted as an URL based on .NET <see cref="T:System.Uri">Uri</see> class.
            </summary>
      <param name="url">The url to validate.</param>
      <returns>True if valid, False if invalid.</returns>
    </member>
    <member name="F:NuGet.Common.ProjectJsonPathUtilities.ProjectConfigFileName">
      <summary>
            project.json
            </summary>
    </member>
    <member name="F:NuGet.Common.ProjectJsonPathUtilities.ProjectConfigFileEnding">
      <summary>
            .project.json
            </summary>
    </member>
    <member name="F:NuGet.Common.ProjectJsonPathUtilities.ProjectLockFileName">
      <summary>
            Lock file name
            </summary>
    </member>
    <member name="M:NuGet.Common.ProjectJsonPathUtilities.GetProjectConfigPath(System.String,System.String)">
      <summary>
            Finds the projectName.project.json in a directory. If no projectName.project.json exists
            the default project.json path will be returned regardless of existance.
            </summary>
      <returns>Returns the full path to the project.json file.</returns>
    </member>
    <member name="M:NuGet.Common.ProjectJsonPathUtilities.GetProjectConfigWithProjectName(System.String)">
      <summary>
            Creates a projectName.project.json file name.
            </summary>
    </member>
    <member name="M:NuGet.Common.ProjectJsonPathUtilities.GetProjectLockFileNameWithProjectName(System.String)">
      <summary>
            Creates a projectName.project.lock.json file name.
            </summary>
    </member>
    <member name="M:NuGet.Common.ProjectJsonPathUtilities.GetLockFilePath(System.String)">
      <summary>
            Create the lock file path from the config file path.
            If the config file includes a project name the 
            lock file will include the name also.
            </summary>
    </member>
    <member name="M:NuGet.Common.ProjectJsonPathUtilities.GetProjectNameFromConfigFileName(System.String)">
      <summary>
            Parses a projectName.project.json file name into a project name.
            If there is no project name null will be returned.
            </summary>
    </member>
    <member name="M:NuGet.Common.ProjectJsonPathUtilities.IsProjectConfig(System.String)">
      <summary>
            True if the file is a project.json or projectname.project.json file.
            </summary>
    </member>
    <member name="T:NuGet.Common.Preprocessor">
      <summary>
            Simple token replacement system for content files.
            </summary>
    </member>
    <member name="M:NuGet.Common.Preprocessor.ProcessAsync(System.Func{System.Threading.Tasks.Task{System.IO.Stream}},System.Func{System.String,System.String},System.Threading.CancellationToken)">
      <summary>
            Asynchronously performs token replacement on a file stream.
            </summary>
      <param name="streamTaskFactory">A stream task factory.</param>
      <param name="tokenReplacement">A token replacement function.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.String" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="streamTaskFactory" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="tokenReplacement" />
            is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Common.Preprocessor.Process(System.IO.Stream,System.Func{System.String,System.String})">
      <summary>
            Performs token replacement on a stream and returns the result.
            </summary>
      <param name="stream">A stream.</param>
      <param name="tokenReplacement">A token replacement funciton.</param>
      <returns>The token-replaced stream content.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="stream" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="tokenReplacement" />
            is <c>null</c>.</exception>
    </member>
    <member name="T:NuGet.Common.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.AbsolutePathRequired">
      <summary>
              Looks up a localized string similar to An absolute path is required: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.Argument_Must_Be_GreaterThanOrEqualTo">
      <summary>
              Looks up a localized string similar to Value must be greater than or equal to {0}.
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.ArgumentNullOrEmpty">
      <summary>
              Looks up a localized string similar to Argument cannot be null or empty.
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.Error_FailedToCreateRandomFile">
      <summary>
              Looks up a localized string similar to Failed to create random file for dotnet add pkg command..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.MissingRequiredEnvVar">
      <summary>
              Looks up a localized string similar to Required environment variable '{0}' is not set. Try setting '{0}' and running the operation again..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.MissingRequiredEnvVarsDotnet">
      <summary>
              Looks up a localized string similar to Required environment variable '{0}' is not set. Try setting '{1}' or '{0}' and running the operation.
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.NoPackageFoldersFound">
      <summary>
              Looks up a localized string similar to At least one package folder path must be provided..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.PackageFolderNotFound">
      <summary>
              Looks up a localized string similar to Package folder not found: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.UnableToDetemineClientVersion">
      <summary>
              Looks up a localized string similar to Unable to determine the current NuGet client version..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.UnauthorizedLockFail">
      <summary>
              Looks up a localized string similar to Unable to obtain lock file access on '{0}' for operations on '{1}'. This may mean that a different user or administator is holding this lock and that this process does not have permission to access it. If no other process is currently performing an operation on this file it may mean that an earlier NuGet process crashed and left an inaccessible lock file, in this case removing the file '{0}' will allow NuGet to continue..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.UnsupportedHashAlgorithm">
      <summary>
              Looks up a localized string similar to Hash algorithm '{0}' is unsupported. Supported algorithms include: SHA512 and SHA256..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.UnsupportedHashAlgorithmName">
      <summary>
              Looks up a localized string similar to Hash algorithm '{0}' is unsupported..
            </summary>
    </member>
    <member name="P:NuGet.Common.Strings.UnsupportedSignatureAlgorithmName">
      <summary>
              Looks up a localized string similar to Signature algorithm '{0}' is unsupported..
            </summary>
    </member>
    <member name="T:NuGet.Common.ITelemetrySession">
      <summary>
            Interface to post telemetry events.
            </summary>
    </member>
    <member name="T:NuGet.Common.NuGetOperationStatus">
      <summary>
            Define different states for nuget operation status.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetOperationStatus.NoOp">
      <summary>
            no operation performed.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetOperationStatus.Succeeded">
      <summary>
            operation was successful.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetOperationStatus.Failed">
      <summary>
            operation failed.
            </summary>
    </member>
    <member name="F:NuGet.Common.NuGetOperationStatus.Cancelled">
      <summary>
            operation was cancelled
            </summary>
    </member>
    <member name="M:NuGet.Common.TelemetryActivity.CreateTelemetryActivityWithNewOperationIdAndEvent(System.Guid,System.String)">
      <summary>
            Creates a TelemetryActivity.
            </summary>
      <param name="parentId">OperationId of the parent event.</param>
      <param name="eventName">Name of the event.</param>
      <returns>TelemetryActivity with a given parentId and new operationId and a TelemetryEvent with eventName</returns>
    </member>
    <member name="T:NuGet.Common.TelemetryEvent">
      <summary>
            This will be used to pass different nuget telemetry events data to vs telemetry service.
            </summary>
    </member>
    <member name="P:NuGet.Common.TelemetryEvent.Count">
      <summary>
            Property count in TelemetryEvent
            </summary>
    </member>
    <member name="T:NuGet.Common.Tokenizer">
      <summary>
            This class is used to parse string into tokens.    
            There are two types of tokens: variables, e.g. "$variable$", or text. 
            The dollar sign can be escaped using $$.
            A variable contains only word characters.
            
            Examples:
            - "a $b$ c" is parsed into 
              {text, "a "}, {variable, "b"}, {text, " c"}.
            - "a $$b$$ c" is parsed into
              {text, "a $b$ c"}.
            - "a $b$ $c" is parsed into
              {text, "a "}, {variable, "b"}, {text, " $c"}.
            - "a $b$$c$" is parsed into
              {text, "a "}, {variable, "b"}, {variable, "c"}.
            - "a $b c$d$" is parsed into 
              {text, "a $b c"}, {variable, "d"} (because space is not a word character).
            </summary>
    </member>
    <member name="M:NuGet.Common.Tokenizer.Read">
      <summary>
            Gets the next token.
            </summary>
      <returns>The parsed token. Or null if no more tokens are available.</returns>
    </member>
    <member name="M:NuGet.Common.UriUtility.CreateSourceUri(System.String,System.UriKind)">
      <summary>
            Same as "new Uri" except that it can handle UNIX style paths that start with '/'
            </summary>
    </member>
    <member name="M:NuGet.Common.UriUtility.TryCreateSourceUri(System.String,System.UriKind)">
      <summary>
            Same as "Uri.TryCreate" except that it can handle UNIX style paths that start with '/'
            </summary>
    </member>
    <member name="M:NuGet.Common.UriUtility.UrlEncodeOdataParameter(System.String)">
      <summary>
            Provides Uri encoding for V2 servers in the same way that NuGet.Core.dll encoded urls.
            </summary>
    </member>
    <member name="M:NuGet.Common.UriUtility.GetLocalPath(System.String)">
      <summary>
            Convert a file:// URI to a local path.
            </summary>
      <returns>If the input can be parsed this will return Uri.LocalPath, if the input 
            is not a URI or fails to parse the original string will be returned.</returns>
      <param name="localOrUriPath">Possible file:// URI path or local path.</param>
    </member>
    <member name="M:NuGet.Common.UriUtility.GetAbsolutePathFromFile(System.String,System.String)">
      <summary>
            Calls GetAbsolutePath with the directory of <paramref name="sourceFile" />.
            </summary>
    </member>
    <member name="M:NuGet.Common.UriUtility.GetAbsolutePath(System.String,System.String)">
      <summary>
            Convert a relative local folder path to an absolute path.
            For http sources and UNC shares this will return
            the same path.
            </summary>
      <param name="rootDirectory">Directory to make the source relative to.</param>
      <param name="path">Source path.</param>
      <returns>The absolute source path or the original source. Noops for non-file paths.</returns>
    </member>
    <member name="M:NuGet.Shared.NuGet.Configuration510476.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Configuration510476.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Configuration510476.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Configuration510476.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Configuration510476.HashCodeCombiner.GetHashCode``2(``0,``1)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Configuration510476.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Configuration510476.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
      <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
    </member>
    <member name="M:NuGet.Shared.NuGet.Configuration510476.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
    </member>
    <member name="F:NuGet.Configuration.CredentialRequestType.Proxy">
      <summary>
            Indicates that the request credentials are to be used to access a proxy.
            </summary>
    </member>
    <member name="F:NuGet.Configuration.CredentialRequestType.Unauthorized">
      <summary>
            Indicates that the remote server rejected the previous request as unauthorized. This 
            suggests that the server does not know who the caller is (i.e. the caller is not
            authenticated).
            </summary>
    </member>
    <member name="F:NuGet.Configuration.CredentialRequestType.Forbidden">
      <summary>
            Indicates that the remote server rejected the previous request as forbidden. This
            suggests that the server knows who the caller is (i.e. the caller is authorized) but
            is not allowed to access the request resource. A different set of credentials could
            solve this failure.
            </summary>
    </member>
    <member name="T:NuGet.Configuration.ICredentialService">
      <summary>
            A credentials service.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ICredentialService.GetCredentialsAsync(System.Uri,System.Net.IWebProxy,NuGet.Configuration.CredentialRequestType,System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets credentials.
            </summary>
      <param name="uri">The URI for which credentials should be retrieved.</param>
      <param name="proxy">A web proxy.</param>
      <param name="type">The credential request type.</param>
      <param name="message">A message to display when prompting for credentials.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.Net.ICredentials" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="uri" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Configuration.ICredentialService.TryGetLastKnownGoodCredentialsFromCache(System.Uri,System.Boolean,System.Net.ICredentials@)">
      <summary>
            Attempts to retrieve last known good credentials for a URI from a credentials cache.
            </summary>
      <remarks>
            When the return value is <c>true</c>, <paramref name="credentials" /> will have last known
            good credentials from the credentials cache.  These credentials may have become invalid
            since their last use, so there is no guarantee that the credentials are currently valid.
            </remarks>
      <param name="uri">The URI for which cached credentials should be retrieved.</param>
      <param name="isProxy">
        <c>true</c> for proxy credentials; otherwise, <c>false</c>.</param>
      <param name="credentials">Cached credentials or <c>null</c>.</param>
      <returns>
        <c>true</c> if a result is returned from the cache; otherwise, false.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="uri" /> is <c>null</c>.</exception>
    </member>
    <member name="P:NuGet.Configuration.ICredentialService.HandlesDefaultCredentials">
      <summary>
            Gets a value indicating whether this credential service wants to handle "default credentials" specially,
            instead of relying on DefaultNetworkCredentials
            </summary>
    </member>
    <member name="F:NuGet.Configuration.NuGetConstants.DefaultGalleryServerUrl">
      <summary>
            NuGet.org gallery Url used as a source display name and as a default "id" when storing nuget.org API key.
            </summary>
      <remarks>
            Albeit this url is not actual feed we should keep it unchanged for back-compat with earlier NuGet versions.
            Typical scenario leading to adding this url to config file is to run setApiKey command without a source:
            nuget.exe setApiKey XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
            </remarks>
    </member>
    <member name="F:NuGet.Configuration.PackageSource.DefaultProtocolVersion">
      <summary>
            The feed version for NuGet prior to v3.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.TrySourceAsUri">
      <summary>
            Returns null if Source is an invalid URI
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.SourceUri">
      <summary>
            Throws if Source is an invalid URI
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.IsOfficial">
      <summary>
            This does not represent just the NuGet Official Feed alone
            It may also represent a Default Package Source set by Configuration Defaults
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.ProtocolVersion">
      <summary>
            Gets or sets the protocol version of the source. Defaults to 2.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.IsLocal">
      <summary>
            True if the source path is file based. Unc shares are not included.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.Origin">
      <summary>
            Gets the <see cref="T:NuGet.Configuration.ISettings" /> that this source originated from. May be null.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSource.TrustedSource">
      <summary>
            Corresponding trusted source details. Null if the package source does not have trusted sources information.
            </summary>
    </member>
    <member name="T:NuGet.Configuration.PackageSourceCredential">
      <summary>
            Represents credentials required to authenticate user within package source web requests.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.PackageSourceCredential.IsValid">
      <summary>
            Verifies if object contains valid data, e.g. not empty user name and password.
            </summary>
      <returns>True if credentials object is valid</returns>
    </member>
    <member name="M:NuGet.Configuration.PackageSourceCredential.#ctor(System.String,System.String,System.String,System.Boolean)">
      <summary>
            Instantiates the credential instance out of raw values read from a config file.
            </summary>
      <param name="source">Associated source ID (needed for reporting errors)</param>
      <param name="username">User name</param>
      <param name="passwordText">Password as stored in config file</param>
      <param name="isPasswordClearText">Hints if password provided in clear text</param>
    </member>
    <member name="M:NuGet.Configuration.PackageSourceCredential.FromUserInput(System.String,System.String,System.String,System.Boolean)">
      <summary>
            Creates new instance of credential object out values provided by user.
            </summary>
      <param name="source">Source ID needed for reporting errors if any</param>
      <param name="username">User name</param>
      <param name="password">Password text in clear</param>
      <param name="storePasswordInClearText">Hints if the password should be stored in clear text on disk.</param>
      <returns>New instance of <see cref="T:NuGet.Configuration.PackageSourceCredential" /></returns>
    </member>
    <member name="P:NuGet.Configuration.PackageSourceCredential.Username">
      <summary>
            User name
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSourceCredential.PasswordText">
      <summary>
            Password text as stored in config file. May be encrypted.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSourceCredential.IsPasswordClearText">
      <summary>
            Indicates if password is stored in clear text.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSourceCredential.Password">
      <summary>
            Retrieves password in clear text. Decrypts on-demand.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.PackageSourceCredential.Source">
      <summary>
            Associated source ID
            </summary>
    </member>
    <member name="M:NuGet.Configuration.PackageSourceProvider.LoadPackageSources">
      <summary>
            Returns PackageSources if specified in the config file. Else returns the default sources specified in the
            constructor.
            If no default values were specified, returns an empty sequence.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.PackageSourceProvider.OnPackageSourcesChanged">
      <summary>
            Fires event PackageSourcesChanged
            </summary>
    </member>
    <member name="M:NuGet.Configuration.PackageSourceProvider.SaveActivePackageSource(NuGet.Configuration.PackageSource)">
      <summary>
            Saves the <paramref name="source" /> as the active source.
            </summary>
      <param name="source">
      </param>
    </member>
    <member name="P:NuGet.Configuration.PackageSourceProvider.ActivePackageSourceName">
      <summary>
            Gets the name of the ActivePackageSource from NuGet.Config
            </summary>
    </member>
    <member name="T:NuGet.Configuration.IProxyCredentialCache">
      <summary>
        <see cref="T:System.Net.CredentialCache" />-like interface with Update credential semantics rather than Add/Remove
            </summary>
    </member>
    <member name="M:NuGet.Configuration.IProxyCredentialCache.UpdateCredential(System.Uri,System.Net.NetworkCredential)">
      <summary>
            Add or update proxy credential
            </summary>
      <param name="proxyAddress">Proxy network address</param>
      <param name="credentials">New credential object</param>
    </member>
    <member name="P:NuGet.Configuration.IProxyCredentialCache.Version">
      <summary>
            Tracks the cache version. Changes every time proxy credential is updated.
            </summary>
    </member>
    <member name="F:NuGet.Configuration.ProxyCache._originalSystemProxy">
      <summary>
            Capture the default System Proxy so that it can be re-used by the IProxyFinder
            because we can't rely on WebRequest.DefaultWebProxy since someone can modify the DefaultWebProxy
            property and we can't tell if it was modified and if we are still using System Proxy Settings or not.
            One limitation of this method is that it does not look at the config file to get the defined proxy
            settings.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ProxyCache.IsSystemProxySet(System.Uri)">
      <summary>
            Return true or false if connecting through a proxy server
            </summary>
      <param name="uri">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NuGet.Configuration.WebProxy">
      <summary>
            Internal implementation of <see cref="T:System.Net.IWebProxy" /> mirroring default desktop one.
            Introduced for XPlat coreFx support.
            </summary>
    </member>
    <member name="T:NuGet.Configuration.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.Argument_Cannot_Be_Null_Or_Empty">
      <summary>
              Looks up a localized string similar to Value cannot be null or empty string..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.Error_EncryptionUnsupported">
      <summary>
              Looks up a localized string similar to Encryption is not supported on non-Windows platforms..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.Error_NoWritableConfig">
      <summary>
              Looks up a localized string similar to There are no writable config files..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.FileDoesNotExist">
      <summary>
              Looks up a localized string similar to File '{0}' does not exist..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.InvalidNullSettingsOperation">
      <summary>
              Looks up a localized string similar to "{0}" cannot be called on a NullSettings. This may be caused on account of insufficient permissions to read or write to "%AppData%\NuGet\NuGet.config"..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.MustContainAbsolutePath">
      <summary>
              Looks up a localized string similar to '{0}' must contain an absolute path '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.PackageSource_Invalid">
      <summary>
              Looks up a localized string similar to The package source does not belong to the collection of available sources..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.RelativeEnvVarPath">
      <summary>
              Looks up a localized string similar to Environment variable '{0}' must contain an absolute path, the full path of '{1}' cannot be determined..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.Settings_FileName_Cannot_Be_A_Path">
      <summary>
              Looks up a localized string similar to Parameter 'fileName' to Settings must be just a fileName and not a path.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.ShowError_ConfigInvalidOperation">
      <summary>
              Looks up a localized string similar to NuGet.Config is malformed. Path: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.ShowError_ConfigInvalidXml">
      <summary>
              Looks up a localized string similar to NuGet.Config is not valid XML. Path: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.ShowError_ConfigRootInvalid">
      <summary>
              Looks up a localized string similar to NuGet.Config does not contain the expected root element: 'configuration'. Path: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.ShowError_ConfigUnauthorizedAccess">
      <summary>
              Looks up a localized string similar to Failed to read NuGet.Config due to unauthorized access. Path: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.Unknown_Config_Exception">
      <summary>
              Looks up a localized string similar to Unexpected failure reading NuGet.Config. Path: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.UnsupportedDecryptPassword">
      <summary>
              Looks up a localized string similar to Password decryption is not supported on .NET Core for this platform. The following feed uses an encrypted password: '{0}'. You can use a clear text password as a workaround..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.UnsupportedEncryptPassword">
      <summary>
              Looks up a localized string similar to Password encryption is not supported on .NET Core for this platform. The following feed try to use an encrypted password: '{0}'. You can use a clear text password as a workaround..
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Resources.UserSettings_UnableToParseConfigFile">
      <summary>
              Looks up a localized string similar to Unable to parse config file '{0}'..
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ConfigurationDefaults.#ctor(System.String,System.String)">
      <summary>
            An internal constructor MAINLY INTENDED FOR TESTING THE CLASS. But, the product code is only expected to
            use the static Instance property
            Only catches FileNotFoundException. Will throw all exceptions including other IOExceptions and
            XmlExceptions for invalid xml and so on
            </summary>
      <param name="directory">The directory that has the NuGetDefaults.Config</param>
      <param name="configFile">Name of the NuGetDefaults.Config</param>
    </member>
    <member name="T:NuGet.Configuration.ISettings">
      <summary>
            Interface to expose NuGet Settings
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ISettings.GetValue(System.String,System.String,System.Boolean)">
      <summary>
            Gets a value for the given key from the given section
            If isPath is true, then the value represents a path. If the path value is already rooted, it is simply
            returned
            Otherwise, path relative to ISettings.Root is returned
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ISettings.GetAllSubsections(System.String)">
      <summary>
            Gets all subsection element names under section as a List of string.
            </summary>
      <param name="section">Name of the section.</param>
      <returns>List of string containing subsection element names.</returns>
    </member>
    <member name="M:NuGet.Configuration.ISettings.GetSettingValues(System.String,System.Boolean)">
      <summary>
            Gets all the values under section
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ISettings.GetNestedValues(System.String,System.String)">
      <summary>
            Gets all the values under section as List of KeyValuePair
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ISettings.GetNestedSettingValues(System.String,System.String)">
      <summary>
            Gets all the values under section as List of SettingValue
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ISettings.SetValue(System.String,System.String,System.String)">
      <summary>
            Sets the value under the specified <paramref name="section" />.
            </summary>
      <param name="section">The name of the section.</param>
      <param name="key">The key to set set.</param>
      <param name="value">The value to set.</param>
    </member>
    <member name="M:NuGet.Configuration.ISettings.SetValues(System.String,System.Collections.Generic.IReadOnlyList{NuGet.Configuration.SettingValue})">
      <summary>
            Sets the values under the specified <paramref name="section" />.
            </summary>
      <param name="section">The name of the section.</param>
      <param name="values">The values to set.</param>
    </member>
    <member name="M:NuGet.Configuration.ISettings.UpdateSections(System.String,System.Collections.Generic.IReadOnlyList{NuGet.Configuration.SettingValue})">
      <summary>
            Updates the <paramref name="values" /> across multiple <see cref="T:NuGet.Configuration.ISettings" /> instances in the hierarchy.
            Values are updated in the <see cref="T:NuGet.Configuration.ISettings" /> with the nearest priority.
            </summary>
      <param name="section">The name of the section.</param>
      <param name="values">The values to set.</param>
    </member>
    <member name="M:NuGet.Configuration.ISettings.UpdateSubsections(System.String,System.String,System.Collections.Generic.IReadOnlyList{NuGet.Configuration.SettingValue})">
      <summary>
            Updates nested <paramref name="values" /> across multiple <see cref="T:NuGet.Configuration.ISettings" /> instances in the hierarchy.
            Values are updated in the <see cref="T:NuGet.Configuration.ISettings" /> with the nearest priority.
            </summary>
      <param name="section">The name of the section.</param>
      <param name="subsection">The name of the subsection.</param>
      <param name="values">The values to set.</param>
    </member>
    <member name="M:NuGet.Configuration.ISettings.SetNestedValues(System.String,System.String,System.Collections.Generic.IList{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
      <summary>
            Sets the values under the specified <paramref name="section" /> and <paramref name="subsection" />.
            </summary>
      <param name="section">The name of the section.</param>
      <param name="subsection">The name of the subsection.</param>
      <param name="values">The values to set.</param>
    </member>
    <member name="M:NuGet.Configuration.ISettings.SetNestedSettingValues(System.String,System.String,System.Collections.Generic.IList{NuGet.Configuration.SettingValue})">
      <summary>
            Sets the setting values under the specified <paramref name="section" /> and <paramref name="subsection" />.
            </summary>
      <param name="section">The name of the section.</param>
      <param name="subsection">The name of the subsection.</param>
      <param name="values">The setting values to set.</param>
    </member>
    <member name="M:NuGet.Configuration.ISettings.DeleteValue(System.String,System.String)">
      <summary>
            Deletes a key from the specified <paramref name="section" />.
            </summary>
      <param name="section">The name of the section.</param>
      <param name="key">The key to be delted.</param>
      <returns>bool indicating success.</returns>
    </member>
    <member name="M:NuGet.Configuration.ISettings.DeleteSection(System.String)">
      <summary>
            Deletes the specified <paramref name="section" />.
            </summary>
      <param name="section">The name of the section.</param>
      <returns>bool indicating success.</returns>
    </member>
    <member name="P:NuGet.Configuration.ISettings.Root">
      <summary>
            Folder under which the config file is present
            </summary>
    </member>
    <member name="P:NuGet.Configuration.ISettings.FileName">
      <summary>
            The file name of the config file. Joining <see cref="P:NuGet.Configuration.ISettings.Root" /> and
            <see cref="P:NuGet.Configuration.ISettings.FileName" /> results in the full path to the config file.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.ISettings.Priority">
      <summary>
            Enumerates the sequence of <see cref="T:NuGet.Configuration.ISettings" /> instances used to fetch settings
            values (e.g. with <see cref="M:NuGet.Configuration.ISettings.GetValue(System.String,System.String,System.Boolean)" />). This enumeration includes this instance
            itself.
            </summary>
    </member>
    <member name="E:NuGet.Configuration.ISettings.SettingsChanged">
      <summary>
            Event raised when the setting have been changed.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.NuGetPathContext.Create(NuGet.Configuration.ISettings)">
      <summary>
            Load paths from already loaded settings.
            </summary>
      <param name="settings">NuGet.Config settings.</param>
    </member>
    <member name="M:NuGet.Configuration.NuGetPathContext.Create(System.String)">
      <summary>
            Load settings based on the solution or project root directory. NuGet.Config files will 
            be discovered based on this path. The machine wide config will also be loaded.
            </summary>
      <param name="settingsRoot">Root directory of the solution or project.</param>
    </member>
    <member name="P:NuGet.Configuration.NuGetPathContext.FallbackPackageFolders">
      <summary>
            Fallback package folders. There many be zero or more of these.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.NuGetPathContext.UserPackageFolder">
      <summary>
            User global packages folder.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.NuGetPathContext.HttpCacheFolder">
      <summary>
            User level http cache.
            </summary>
    </member>
    <member name="T:NuGet.Configuration.Settings">
      <summary>
            Concrete implementation of ISettings to support NuGet Settings
            </summary>
    </member>
    <member name="F:NuGet.Configuration.Settings.DefaultSettingsFileName">
      <summary>
            Default file name for a settings file is 'NuGet.config'
            Also, the machine level setting file at '%APPDATA%\NuGet' always uses this name
            </summary>
    </member>
    <member name="F:NuGet.Configuration.Settings.OrderedSettingsFileNames">
      <summary>
            NuGet config names with casing ordered by precedence.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.Settings.LoadDefaultSettings(System.String)">
      <summary>
            Load default settings based on a directory.
            This includes machine wide settings.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.Settings.LoadDefaultSettings(System.String,System.String,NuGet.Configuration.IMachineWideSettings)">
      <summary>
            Loads user settings from the NuGet configuration files. The method walks the directory
            tree in <paramref name="root" /> up to its root, and reads each NuGet.config file
            it finds in the directories. It then reads the user specific settings,
            which is file <paramref name="configFileName" />
            in <paramref name="root" /> if <paramref name="configFileName" /> is not null,
            If <paramref name="configFileName" /> is null, the user specific settings file is
            %AppData%\NuGet\NuGet.config.
            After that, the machine wide settings files are added.
            </summary>
      <remarks>
            For example, if <paramref name="root" /> is c:\dir1\dir2, <paramref name="configFileName" />
            is "userConfig.file", the files loaded are (in the order that they are loaded):
            c:\dir1\dir2\nuget.config
            c:\dir1\nuget.config
            c:\nuget.config
            c:\dir1\dir2\userConfig.file
            machine wide settings (e.g. c:\programdata\NuGet\Config\*.config)
            </remarks>
      <param name="root">
            The file system to walk to find configuration files.
            Can be null.
            </param>
      <param name="configFileName">The user specified configuration file.</param>
      <param name="machineWideSettings">
            The machine wide settings. If it's not null, the
            settings files in the machine wide settings are added after the user sepcific
            config file.
            </param>
      <returns>The settings object loaded.</returns>
    </member>
    <member name="M:NuGet.Configuration.Settings.LoadSpecificSettings(System.String,System.String)">
      <summary>
            Loads Specific NuGet.Config file. The method only loads specific config file 
            which is file <paramref name="configFileName" />from <paramref name="root" />.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.Settings.LoadDefaultSettings(System.String,System.String,NuGet.Configuration.IMachineWideSettings,System.Boolean,System.Boolean)">
      <summary>
            For internal use only
            </summary>
    </member>
    <member name="M:NuGet.Configuration.Settings.LoadMachineWideSettings(System.String,System.String[])">
      <summary>
            Loads the machine wide settings.
            </summary>
      <remarks>
            For example, if <paramref name="paths" /> is {"IDE", "Version", "SKU" }, then
            the files loaded are (in the order that they are loaded):
            %programdata%\NuGet\Config\IDE\Version\SKU\*.config
            %programdata%\NuGet\Config\IDE\Version\*.config
            %programdata%\NuGet\Config\IDE\*.config
            %programdata%\NuGet\Config\*.config
            </remarks>
      <param name="root">The file system in which the settings files are read.</param>
      <param name="paths">The additional paths under which to look for settings files.</param>
      <returns>The list of settings read.</returns>
    </member>
    <member name="M:NuGet.Configuration.Settings.UpdateSection(System.Xml.Linq.XElement,System.String,System.Collections.Generic.IEnumerable{NuGet.Configuration.SettingValue})">
      <summary>
            Adds or Updates a section in the root element with the values.
            </summary>
      <param name="root">Root element.</param>
      <param name="section">Name of the section.</param>
      <param name="valuesToWrite">Values to be added or updated in the section.</param>
    </member>
    <member name="M:NuGet.Configuration.Settings.RemoveElementBeforeClearTag(System.Xml.Linq.XElement)">
      <summary>
            Removes all element nodes in the sectionElement which appear before a clear element.
            </summary>
      <param name="sectionElement">XElement section.</param>
    </member>
    <member name="M:NuGet.Configuration.Settings.ContainsClearTag(System.Xml.Linq.XElement)">
      <summary>
            Checks if a section contains clear tag.
            </summary>
      <param name="section">XElement section.</param>
    </member>
    <member name="M:NuGet.Configuration.Settings.IsElement(System.Xml.Linq.XNode)">
      <summary>
            Checks if an XNode is an XElement.
            </summary>
      <param name="node">XNode</param>
      <returns>Bool indicating if the node is an element.</returns>
    </member>
    <member name="M:NuGet.Configuration.Settings.HasName(System.Xml.Linq.XElement,System.String)">
      <summary>
            Checks if an XElement has a specific local name. Performs an OrdinalIgnoreCase comparison.
            </summary>
      <param name="element">XElement to be matched</param>
      <param name="name">name to be matched</param>
      <returns>Bool indicating if the element and has the same local name as the name parameter.</returns>
    </member>
    <member name="M:NuGet.Configuration.Settings.GetSettingsFileNames(System.String)">
      <remarks>
            Order is most significant (e.g. applied last) to least significant (applied first)
            ex:
            c:\someLocation\nuget.config
            c:\nuget.config
            </remarks>
    </member>
    <member name="M:NuGet.Configuration.Settings.GetSettingsFileNameFromDir(System.String)">
      <summary>
            Checks for each possible casing of nuget.config in the directory. The first match is
            returned. If there are no nuget.config files null is returned.
            </summary>
      <remarks>For windows <see cref="F:NuGet.Configuration.Settings.OrderedSettingsFileNames" /> contains a single casing since
            the file system is case insensitive.</remarks>
    </member>
    <member name="P:NuGet.Configuration.Settings.Root">
      <summary>
            Folder under which the config file is present
            </summary>
    </member>
    <member name="P:NuGet.Configuration.Settings.ConfigFilePath">
      <summary>
            Full path to the ConfigFile corresponding to this Settings object
            </summary>
    </member>
    <member name="T:NuGet.Configuration.SettingValue">
      <summary>
            Represents a single setting value in a settings file
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.Key">
      <summary>
            Represents the key of the setting
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.Value">
      <summary>
            Represents the value of the setting
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.OriginalValue">
      <summary>
            Original value of the source as in NuGet.Config.
            Should be used only if the SettingValue is read from a config file.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.IsMachineWide">
      <summary>
            IsMachineWide tells if the setting is machine-wide or not.
            Should be used only if the SettingValue is read from a config file.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.Priority">
      <summary>
            The priority of this setting in the nuget.config hierarchy. Bigger number means higher priority.
            Should be used only if the SettingValue is read from a config file.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.Origin">
      <summary>
            Gets the <see cref="T:NuGet.Configuration.ISettings" /> that provided this value.
            Should be used only if the SettingValue is read from a config file.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.SettingValue.AdditionalData">
      <summary>
            Gets additional values with the specified setting.
            </summary>
      <remarks>
            When reading from an XML based settings file, this includes all attributes on the element
            other than the <c>Key</c> and <c>Value</c>.
            </remarks>
    </member>
    <member name="T:NuGet.Configuration.XPlatMachineWideSetting">
      <summary>
            Machine wide settings based on the default machine wide config directory.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.CertificateTrustEntry.Fingerprint">
      <summary>
            Certificate fingerprint.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.CertificateTrustEntry.SubjectName">
      <summary>
            Certificate subject name.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.CertificateTrustEntry.FingerprintAlgorithm">
      <summary>
            Hash algorithm used to generate the certificate fingerprint.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.CertificateTrustEntry.Priority">
      <summary>
            The priority of this certificate entry in the nuget.config hierarchy. Same as SettingValue.Priority.
            Null if this entry is not read from a config file.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.ITrustedSourceProvider.LoadTrustedSources">
      <summary>
            Loads all trusted sources.
            </summary>
      <returns>IEnumerable of TrustedSource.</returns>
    </member>
    <member name="M:NuGet.Configuration.ITrustedSourceProvider.LoadTrustedSource(System.String)">
      <summary>
            Loads a trusted source corresponding to a package source.
            </summary>
      <param name="packageSourceName">Name of the PackageSource used for lookup.</param>
      <returns>TrustedSource corresponding to the PackageSource. Null if none found.</returns>
    </member>
    <member name="M:NuGet.Configuration.ITrustedSourceProvider.SaveTrustedSources(System.Collections.Generic.IEnumerable{NuGet.Configuration.TrustedSource})">
      <summary>
            Saves all trusted sources. Creates new entries or updates existing trusted source entries.
            </summary>
      <param name="sources">IEnumerable of TrustedSource to be saved.</param>
    </member>
    <member name="M:NuGet.Configuration.ITrustedSourceProvider.SaveTrustedSource(NuGet.Configuration.TrustedSource)">
      <summary>
            Saves a trusted sources. Creates new entry or updates existing trusted source entry.
            </summary>
      <param name="source">TrustedSource to be saved.</param>
    </member>
    <member name="M:NuGet.Configuration.ITrustedSourceProvider.DeleteTrustedSource(System.String)">
      <summary>
            Deletes a trusted source.
            </summary>
      <param name="sourceName">Name of the TrustedSource to be deleted.</param>
    </member>
    <member name="P:NuGet.Configuration.ITrustEntry.Priority">
      <summary>
            The priority of this entry in the nuget.config hierarchy. Same as SettingValue.Priority.
            Null if this entry is not read from a config file.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.ServiceIndexTrustEntry.Value">
      <summary>
            Service index uri.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.ServiceIndexTrustEntry.Priority">
      <summary>
            The priority of this entry in the nuget.config hierarchy. Same as SettingValue.Priority.
            Null if this entry is not read from a config file.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.TrustedSource.SourceName">
      <summary>
            Name of the associated package source.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.TrustedSource.ServiceIndex">
      <summary>
            Service index of the source.
            </summary>
    </member>
    <member name="P:NuGet.Configuration.TrustedSource.Certificates">
      <summary>
            List of trusted certificates.
            </summary>
    </member>
    <member name="T:NuGet.Configuration.IExtensionLocator">
      <summary>
            Provides a common facility for locating extensions
            </summary>
    </member>
    <member name="M:NuGet.Configuration.IExtensionLocator.FindExtensions">
      <summary>
            Find paths to all extensions
            </summary>
    </member>
    <member name="M:NuGet.Configuration.IExtensionLocator.FindCredentialProviders">
      <summary>
            Find paths to all credential providers
            </summary>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.GetConfigValue(NuGet.Configuration.ISettings,System.String,System.Boolean,System.Boolean)">
      <summary>
            Retrieves a config value for the specified key
            </summary>
      <param name="settings">The settings instance to retrieve </param>
      <param name="key">The key to look up</param>
      <param name="decrypt">Determines if the retrieved value needs to be decrypted.</param>
      <param name="isPath">Determines if the retrieved value is returned as a path.</param>
      <returns>Null if the key was not found, value from config otherwise.</returns>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.SetConfigValue(NuGet.Configuration.ISettings,System.String,System.String,System.Boolean)">
      <summary>
            Sets a config value in the setting.
            </summary>
      <param name="settings">The settings instance to store the key-value in.</param>
      <param name="key">The key to store.</param>
      <param name="value">The value to store.</param>
      <param name="encrypt">Determines if the value needs to be encrypted prior to storing.</param>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.DeleteConfigValue(NuGet.Configuration.ISettings,System.String)">
      <summary>
            Deletes a config value from settings
            </summary>
      <param name="settings">The settings instance to delete the key from.</param>
      <param name="key">The key to delete.</param>
      <returns>True if the value was deleted, false otherwise.</returns>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.GetFallbackPackageFolders(NuGet.Configuration.ISettings)">
      <summary>
            Read fallback folders from the environment variable or from nuget.config.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.GetFallbackPackageFoldersFromConfig(NuGet.Configuration.ISettings)">
      <summary>
            Read fallback folders only from nuget.config.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.GetHttpCacheFolder">
      <summary>
            Get the HTTP cache folder from either an environment variable or a default.
            </summary>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.GetPluginsCacheFolder">
      <summary>
             Get plugins cache folder
            </summary>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.GetDefaultPushSource(NuGet.Configuration.ISettings)">
      <summary>
            The DefaultPushSource can be:
            - An absolute URL
            - An absolute file path
            - A relative file path
            - The name of a registered source from a config file
            </summary>
    </member>
    <member name="M:NuGet.Configuration.SettingsUtility.VerifyPathIsRooted(System.String,System.String)">
      <summary>
            Throw if a path is relative.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.DependencyResolver.Core558093.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.DependencyResolver.Core558093.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.DependencyResolver.Core558093.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.DependencyResolver.Core558093.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.DependencyResolver.Core558093.HashCodeCombiner.GetHashCode``2(``0,``1)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.DependencyResolver.Core558093.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.DependencyResolver.Core558093.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
      <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
    </member>
    <member name="M:NuGet.Shared.NuGet.DependencyResolver.Core558093.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
    </member>
    <member name="T:NuGet.DependencyResolver.GraphEdge`1">
      <summary>
            GraphEdge holds a reference to the parent node, the incoming edge to the parent, and
            the out going edge to the current position of the walk.
            
            Root -&gt; OuterEdge -&gt; Node -&gt; Edge -&gt; (Current Node)
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.GraphEdge`1.OuterEdge">
      <summary>
            Incoming edge to <see cref="P:NuGet.DependencyResolver.GraphEdge`1.Item" />.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.GraphEdge`1.Item">
      <summary>
            Graph node between <see cref="P:NuGet.DependencyResolver.GraphEdge`1.OuterEdge" /> and <see cref="P:NuGet.DependencyResolver.GraphEdge`1.Edge" />.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.GraphEdge`1.Edge">
      <summary>
            Outgoing edge from <see cref="P:NuGet.DependencyResolver.GraphEdge`1.Item" />.
            </summary>
    </member>
    <member name="M:NuGet.DependencyResolver.GraphOperations.GetPath``1(NuGet.DependencyResolver.GraphNode{``0})">
      <summary>
            A 1.0.0 -&gt; B 1.0.0 -&gt; C 2.0.0
            </summary>
    </member>
    <member name="M:NuGet.DependencyResolver.GraphOperations.GetPathWithLastRange``1(NuGet.DependencyResolver.GraphNode{``0})">
      <summary>
            A 1.0.0 -&gt; B 1.0.0 -&gt; C (= 2.0.0)
            </summary>
    </member>
    <member name="M:NuGet.DependencyResolver.GraphOperations.GetIdAndRange``1(NuGet.DependencyResolver.GraphNode{``0})">
      <summary>
            Prints the id and version constraint for a node.
            </summary>
      <remarks>Projects will not display a range.</remarks>
    </member>
    <member name="M:NuGet.DependencyResolver.GraphOperations.GetIdAndVersionOrRange``1(NuGet.DependencyResolver.GraphNode{``0})">
      <summary>
            Prints the id and version of a node. If the version does not exist use the range.
            </summary>
      <remarks>Projects will not display a version or range.</remarks>
    </member>
    <member name="M:NuGet.DependencyResolver.GraphOperations.GetId``1(NuGet.DependencyResolver.GraphNode{``0})">
      <summary>
            Id of the node.
            </summary>
    </member>
    <member name="M:NuGet.DependencyResolver.GraphOperations.GetVersionOrDefault``1(NuGet.DependencyResolver.GraphNode{``0})">
      <summary>
            Version of the resolved node version if it exists.
            </summary>
    </member>
    <member name="M:NuGet.DependencyResolver.GraphOperations.GetVersionRange``1(NuGet.DependencyResolver.GraphNode{``0})">
      <summary>
            Dependency range for the node.
            </summary>
      <remarks>Defaults to All</remarks>
    </member>
    <member name="M:NuGet.DependencyResolver.GraphOperations.IsPackage``1(NuGet.DependencyResolver.GraphNode{``0})">
      <summary>
            True if the node is resolved to a package or allows a package if unresolved.
            </summary>
    </member>
    <member name="T:NuGet.DependencyResolver.LibraryRangeCacheKey">
      <summary>
            Helper class to hold a library range and framework.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.LibraryRangeCacheKey.Framework">
      <summary>
            Target framework
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.LibraryRangeCacheKey.LibraryRange">
      <summary>
            Library range information.
            </summary>
    </member>
    <member name="M:NuGet.DependencyResolver.PackagingUtility.GetLibraryDependencyFromNuspec(NuGet.Packaging.Core.PackageDependency)">
      <summary>
            Convert a nuspec dependency to a library dependency.
            </summary>
    </member>
    <member name="T:NuGet.DependencyResolver.IRemoteDependencyProvider">
      <summary>
            A remote dependency provider.
            </summary>
    </member>
    <member name="M:NuGet.DependencyResolver.IRemoteDependencyProvider.FindLibraryAsync(NuGet.LibraryModel.LibraryRange,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously discovers all versions of a package from a source and selects the best match.
            </summary>
      <remarks>This does not download the package.</remarks>
      <param name="libraryRange">A library range.</param>
      <param name="targetFramework">A target framework.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.LibraryModel.LibraryIdentity" />
            instance.</returns>
      <exception cref="!:ArgumentNullException">Thrown if <paramref name="libraryRange" />
            is either <c>null</c> or empty.</exception>
      <exception cref="!:ArgumentNullException">Thrown if <paramref name="targetFramework" />
            is either <c>null</c> or empty.</exception>
      <exception cref="!:ArgumentNullException">Thrown if <paramref name="cacheContext" />
            is either <c>null</c> or empty.</exception>
      <exception cref="!:ArgumentNullException">Thrown if <paramref name="logger" />
            is either <c>null</c> or empty.</exception>
      <exception cref="!:OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.DependencyResolver.IRemoteDependencyProvider.GetDependenciesAsync(NuGet.LibraryModel.LibraryIdentity,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets package dependencies.
            </summary>
      <param name="libraryIdentity">A library identity.</param>
      <param name="targetFramework">A target framework.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.LibraryModel.LibraryDependencyInfo" />
            instance.</returns>
      <exception cref="!:ArgumentNullException">Thrown if <paramref name="libraryIdentity" />
            is either <c>null</c> or empty.</exception>
      <exception cref="!:ArgumentNullException">Thrown if <paramref name="targetFramework" />
            is either <c>null</c> or empty.</exception>
      <exception cref="!:ArgumentNullException">Thrown if <paramref name="cacheContext" />
            is either <c>null</c> or empty.</exception>
      <exception cref="!:ArgumentNullException">Thrown if <paramref name="logger" />
            is either <c>null</c> or empty.</exception>
      <exception cref="!:OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.DependencyResolver.IRemoteDependencyProvider.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package downloader.
            </summary>
      <param name="packageIdentity">A package identity.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.Packaging.IPackageDownloader" />
            instance.</returns>
      <exception cref="!:ArgumentNullException">Thrown if <paramref name="packageIdentity" />
            is either <c>null</c> or empty.</exception>
      <exception cref="!:ArgumentNullException">Thrown if <paramref name="cacheContext" />
            is either <c>null</c> or empty.</exception>
      <exception cref="!:ArgumentNullException">Thrown if <paramref name="logger" />
            is either <c>null</c> or empty.</exception>
      <exception cref="!:OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="P:NuGet.DependencyResolver.IRemoteDependencyProvider.IsHttp">
      <summary>
            Gets a flag indicating whether or not the provider source is HTTP or HTTPS.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.IRemoteDependencyProvider.Source">
      <summary>
            Gets the package source.
            </summary>
      <remarks>Optional. This will be <c>null</c> for project providers.</remarks>
    </member>
    <member name="T:NuGet.DependencyResolver.LocalDependencyProvider">
      <summary>
            A local dependency provider.
            </summary>
    </member>
    <member name="M:NuGet.DependencyResolver.LocalDependencyProvider.#ctor(NuGet.DependencyResolver.IDependencyProvider)">
      <summary>
            Initializes a new <see cref="T:NuGet.DependencyResolver.LocalDependencyProvider" /> class.
            </summary>
      <param name="dependencyProvider">
      </param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="dependencyProvider" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.DependencyResolver.LocalDependencyProvider.FindLibraryAsync(NuGet.LibraryModel.LibraryRange,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously discovers all versions of a package from a source and selects the best match.
            </summary>
      <remarks>This does not download the package.</remarks>
      <param name="libraryRange">A library range.</param>
      <param name="targetFramework">A target framework.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.LibraryModel.LibraryIdentity" />
            instance.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="libraryRange" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="targetFramework" />
            is either <c>null</c> or empty.</exception>
    </member>
    <member name="M:NuGet.DependencyResolver.LocalDependencyProvider.GetDependenciesAsync(NuGet.LibraryModel.LibraryIdentity,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets package dependencies.
            </summary>
      <param name="libraryIdentity">A library identity.</param>
      <param name="targetFramework">A target framework.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.LibraryModel.LibraryDependencyInfo" />
            instance.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="libraryIdentity" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="targetFramework" />
            is either <c>null</c> or empty.</exception>
    </member>
    <member name="M:NuGet.DependencyResolver.LocalDependencyProvider.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package downloader.
            </summary>
      <param name="packageIdentity">A package identity.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.Packaging.IPackageDownloader" />
            instance.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="P:NuGet.DependencyResolver.LocalDependencyProvider.IsHttp">
      <summary>
            Gets a flag indicating whether or not the provider source is HTTP or HTTPS.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.LocalDependencyProvider.Source">
      <summary>
            Gets the package source.
            </summary>
      <remarks>Optional. This will be <c>null</c> for project providers.</remarks>
    </member>
    <member name="T:NuGet.DependencyResolver.LocalMatch">
      <summary>
            Extends <see cref="T:NuGet.DependencyResolver.RemoteMatch" /> to add a reference to the full Library.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.LocalMatch.LocalLibrary">
      <summary>
            Full local Library metadata
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.LocalMatch.LocalProvider">
      <summary>
            The local provider where the library was found.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.RemoteWalkContext.FindLibraryEntryCache">
      <summary>
            Library entry cache.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.RemoteWalkContext.IsMsBuildBased">
      <summary>
            True if this is a csproj or similar project. Xproj should be false.
            </summary>
    </member>
    <member name="T:NuGet.DependencyResolver.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.DependencyResolver.Strings.Error_PackageNotFoundWhenExpected">
      <summary>
              Looks up a localized string similar to The feed '{0}' lists package '{1}' but multiple attempts to download the nupkg have failed. The feed is either invalid or required packages were removed while the current operation was in progress. Verify the package exists on the feed and try again..
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Frameworks579564.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Frameworks579564.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Frameworks579564.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Frameworks579564.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Frameworks579564.HashCodeCombiner.GetHashCode``2(``0,``1)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Frameworks579564.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Frameworks579564.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
      <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
    </member>
    <member name="M:NuGet.Shared.NuGet.Frameworks579564.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.AssetTargetFallbackFramework">
      <summary>
            AssetTargetFallbackFramework only fallback when zero assets are selected. These do not 
            auto fallback during GetNearest as FallbackFramework would.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.AssetTargetFallbackFramework.AsFallbackFramework">
      <summary>
            Create a FallbackFramework from the current AssetTargetFallbackFramework.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.AssetTargetFallbackFramework.Fallback">
      <summary>
            List framework to fall back to.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.AssetTargetFallbackFramework.RootFramework">
      <summary>
            Root project framework.
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.FrameworkPrecedenceSorter">
      <summary>
            Sorts frameworks according to the framework mappings
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.NuGetFrameworkFullComparer">
      <summary>
            A case insensitive compare of the framework, version, and profile
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.NuGetFrameworkNameComparer">
      <summary>
            A case insensitive compare of the framework name only
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.NuGetFrameworkSorter">
      <summary>
            Sorts NuGet Frameworks in a consistent way for package readers.
            The order is not particularly useful here beyond making things deterministic
            since it compares completely different frameworks.
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.CompatibilityCacheKey">
      <summary>
            Internal cache key used to store framework compatibility.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.CompatibilityProvider.IsCompatible(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Check if the frameworks are compatible.
            </summary>
      <param name="target">Project framework</param>
      <param name="candidate">Other framework to check against the project framework</param>
      <returns>True if framework supports other</returns>
    </member>
    <member name="M:NuGet.Frameworks.CompatibilityProvider.IsCompatibleCore(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Actual compatibility check without caching
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.CompatibilityProvider.GetEquivalentFrameworksClosure(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Find all equivalent frameworks, and their equivalent frameworks.
            Example:
            Mappings:
            A &lt;&gt; B
            B &lt;&gt; C
            C &lt;&gt; D
            For A we need to find B, C, and D so we must retrieve equivalent frameworks for A, B, and C
            also as we discover them.
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.CompatibilityTable">
      <summary>
            Creates a table of compatible frameworks.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.CompatibilityTable.HasFramework(NuGet.Frameworks.NuGetFramework)">
      <summary>
            True if the framework is in the table.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.CompatibilityTable.GetNearest(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Gives the smallest set of frameworks from the table that cover everything the given framework would cover.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.CompatibilityTable.TryGetCompatible(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Returns the list of all frameworks compatible with the given framework
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.DefaultFrameworkMappings.Instance">
      <summary>
            Singleton instance of the default framework mappings.
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.DefaultPortableFrameworkMappings">
      <summary>
            Contains the standard portable framework mappings
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.DefaultPortableFrameworkMappings.Instance">
      <summary>
            Static instance of the portable framework mappings
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkCompatibilityListProvider.GetFrameworksSupporting(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Get a list of frameworks supporting the provided framework. This list
            is not meant to be exhaustive but is instead meant to be human-readable.
            Ex: netstandard1.5 -&gt; netstandardapp1.5, net462, dnxcore50, ...
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkCompatibilityProvider.IsCompatible(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Ex: IsCompatible(net45, net40) -&gt; true
            Ex: IsCompatible(net40, net45) -&gt; false
            </summary>
      <param name="framework">Project target framework</param>
      <param name="other">Library framework that is going to be installed</param>
      <returns>True if framework supports other</returns>
    </member>
    <member name="T:NuGet.Frameworks.IFrameworkMappings">
      <summary>
            A raw list of framework mappings. These are indexed by the framework name provider and in most cases all
            mappings are
            mirrored so that the IFrameworkMappings implementation only needs to provide the minimum amount of
            mappings.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.IdentifierSynonyms">
      <summary>
            Synonym &gt; Identifier
            Ex: NET Framework &gt; .NET Framework
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.IdentifierShortNames">
      <summary>
            Ex: .NET Framework &gt; net
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.ProfileShortNames">
      <summary>
            Ex: WindowsPhone &gt; wp
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.EquivalentFrameworks">
      <summary>
            Equal frameworks. Used for legacy conversions.
            ex: Framework: Win8 &lt;&gt; Framework: NetCore45 Platform: Win8
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.EquivalentProfiles">
      <summary>
            Framework, EquivalentProfile1, EquivalentProfile2
            Ex: Silverlight, WindowsPhone71, WindowsPhone
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.SubSetFrameworks">
      <summary>
            Frameworks which are subsets of others.
            Ex: .NETCore &gt; .NET
            Everything in .NETCore maps to .NET and is one way compatible. Version numbers follow the same format.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.CompatibilityMappings">
      <summary>
            Additional framework compatibility rules beyond name and version matching.
            Ex: .NETFramework supports &gt; Native
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.NonPackageBasedFrameworkPrecedence">
      <summary>
            Ordered list of framework identifiers. The first framework in the list will be preferred over other 
            framework identifiers. This is enable better tie breaking in scenarios where legacy frameworks are 
            equivalently compatible to a new framework.
            Example: UAP10.0 &gt; win81, wpa81
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.PackageBasedFrameworkPrecedence">
      <summary>
            Same as <see cref="P:NuGet.Frameworks.IFrameworkMappings.NonPackageBasedFrameworkPrecedence" /> but is only referred to if all of the packages
            in consideration are package based (determined by <see cref="P:NuGet.Frameworks.NuGetFramework.IsPackageBased" />).
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.EquivalentFrameworkPrecedence">
      <summary>
            Only used to choose between frameworks that are equivalent. This favors more human-readable target
            frameworks identifiers.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.ShortNameReplacements">
      <summary>
            Rewrite folder short names to the given value.
            Ex: dotnet50 &gt; dotnet
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkMappings.FullNameReplacements">
      <summary>
            Rewrite full framework names to the given value.
            Ex: .NETPlatform,Version=v0.0 &gt; .NETPlatform,Version=v5.0
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetIdentifier(System.String,System.String@)">
      <summary>
            Returns the official framework identifier for an alias or short name.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetShortIdentifier(System.String,System.String@)">
      <summary>
            Gives the short name used for folders in NuGet
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetProfile(System.String,System.String,System.String@)">
      <summary>
            Get the official profile name from the short name.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetShortProfile(System.String,System.String,System.String@)">
      <summary>
            Returns the shortened version of the profile name.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetVersion(System.String,System.Version@)">
      <summary>
            Parses a version string using single digit rules if no dots exist
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetVersionString(System.String,System.Version)">
      <summary>
            Returns a shortened version. If all digits are single digits no dots will be used.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableProfileNumber(System.String,System.Int32@)">
      <summary>
            Tries to parse the portable profile number out of a profile.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableProfile(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework},System.Int32@)">
      <summary>
            Looks up the portable profile number based on the framework list.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableFrameworks(System.Int32,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Returns the frameworks based on a portable profile number.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableFrameworks(System.Int32,System.Boolean,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Returns the frameworks based on a portable profile number.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableFrameworks(System.String,System.Boolean,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Returns the frameworks based on a profile string.
            Profile can be either the number in format: Profile=7, or the shortened NuGet version: net45+win8
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableFrameworks(System.String,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Parses a shortened portable framework profile list.
            Ex: net45+win8
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetPortableCompatibilityMappings(System.Int32,System.Collections.Generic.IEnumerable{NuGet.Frameworks.FrameworkRange}@)">
      <summary>
            Returns ranges of frameworks that are known to be supported by the given portable profile number.
            Ex: Profile7 -&gt; netstandard1.1
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetEquivalentFrameworks(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Returns a list of all possible substitutions where the framework name
            have equivalents.
            Ex: sl3 -&gt; wp8
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetEquivalentFrameworks(NuGet.Frameworks.FrameworkRange,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)">
      <summary>
            Gives all substitutions for a framework range.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetCompatibilityMappings(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.FrameworkRange}@)">
      <summary>
            Returns ranges of frameworks that are known to be supported by the given framework.
            Ex: net45 -&gt; native
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetSubSetFrameworks(System.String,System.Collections.Generic.IEnumerable{System.String}@)">
      <summary>
            Returns all sub sets of the given framework.
            Ex: .NETFramework -&gt; .NETCore
            These will have the same version, but a different framework
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.CompareFrameworks(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            The ascending order of frameworks should be based on the following ordered groups:
            
            1. Non-package-based frameworks in <see cref="P:NuGet.Frameworks.IFrameworkMappings.NonPackageBasedFrameworkPrecedence" />.
            2. Other non-package-based frameworks.
            3. Package-based frameworks in <see cref="P:NuGet.Frameworks.IFrameworkMappings.PackageBasedFrameworkPrecedence" />.
            4. Other package-based frameworks.
            
            For group #1 and #3, the order within the group is based on the order of the respective precedence list.
            For group #2 and #4, the order is the original order in the incoming list. This should later be made
            consistent between different input orderings by using the <see cref="T:NuGet.Frameworks.NuGetFrameworkSorter" />.
            </summary>
      <remarks>netcore50 is a special case since netcore451 is not packages based, but netcore50 is.
            This sort will treat all versions of netcore as non-packages based.</remarks>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.CompareEquivalentFrameworks(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Used to pick between two equivalent frameworks. This is meant to favor the more human-readable
            framework. Note that this comparison does not validate that the provided frameworks are indeed
            equivalent (e.g. with
            <see cref="M:NuGet.Frameworks.IFrameworkNameProvider.TryGetEquivalentFrameworks(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework}@)" />).
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetShortNameReplacement(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Returns folder short names rewrites.
            Ex: dotnet50 -&gt; dotnet
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetFullNameReplacement(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Returns full name rewrites.
            Ex: .NETPlatform,Version=v0.0 -&gt; .NETPlatform,Version=v5.0
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetNetStandardVersions">
      <summary>
            Returns all versions of .NETStandard in ascending order.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.IFrameworkNameProvider.GetCompatibleCandidates">
      <summary>
            Returns a list of frameworks that could be compatible with .NETStandard.
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.IFrameworkSpecific">
      <summary>
            A group or object that is specific to a single target framework
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkSpecific.TargetFramework">
      <summary>
            Target framework
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.IFrameworkTargetable">
      <summary>
            Use this to expose the list of target frameworks an object can be used for.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IFrameworkTargetable.SupportedFrameworks">
      <summary>
            All frameworks supported by the parent
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IPortableFrameworkMappings.ProfileFrameworks">
      <summary>
            Ex: 5 -&gt; net4, win8
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IPortableFrameworkMappings.ProfileOptionalFrameworks">
      <summary>
            Additional optional frameworks supported in a portable profile.
            Ex: 5 -&gt; MonoAndroid1+MonoTouch1
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.IPortableFrameworkMappings.CompatibilityMappings">
      <summary>
            Compatibility mapping for portable profiles. This is a separate compatibility from that in
            <see cref="P:NuGet.Frameworks.IFrameworkMappings.CompatibilityMappings" />.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.FallbackFramework.Fallback">
      <summary>
            List framework to fall back to.
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.FrameworkConstants.CommonFrameworks">
      <summary>
            Interned frameworks that are commonly used in NuGet
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.FrameworkExpander">
      <summary>
            FrameworkExpander finds all equivalent and compatible frameworks for a NuGetFramework
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkExpander.Expand(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Return all possible equivalent, subset, and known compatible frameworks.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkExpander.ExpandInternal(NuGet.Frameworks.NuGetFramework)">
      <summary>
            Finds all expansions using the mapping provider
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkExtensions.IsDesktop(NuGet.Frameworks.NuGetFramework)">
      <summary>
            True if the Framework is .NETFramework
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkExtensions.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework)">
      <summary>
            Return the item with the target framework nearest the project framework
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.FrameworkNameProvider._identifierSynonyms">
      <summary>
            Contains identifier -&gt; identifier
            Ex: .NET Framework -&gt; .NET Framework
            Ex: NET Framework -&gt; .NET Framework
            This includes self mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkNameProvider.TryConvertOrNormalize(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String},System.String@)">
      <summary>
            Converts a key using the mappings, or if the key is already converted, finds the normalized form.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkNameProvider.GetAllEquivalentFrameworks(NuGet.Frameworks.NuGetFramework)">
      <summary>  
            Get all equivalent frameworks including the given framework  
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkNameProvider.AddEquivalentProfiles(System.Collections.Generic.IEnumerable{NuGet.Frameworks.FrameworkSpecificMapping})">
      <summary>
            2 way per framework profile equivalence
            </summary>
      <param name="mappings">
      </param>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkNameProvider.AddEquivalentFrameworks(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework}})">
      <summary>
            2 way framework equivalence
            </summary>
      <param name="mappings">
      </param>
    </member>
    <member name="T:NuGet.Frameworks.FrameworkRange">
      <summary>
            An inclusive range of frameworks
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkRange.Satisfies(NuGet.Frameworks.NuGetFramework)">
      <summary>
            True if the framework version falls between the min and max
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.FrameworkRange.Min">
      <summary>
            Minimum Framework
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.FrameworkRange.Max">
      <summary>
            Maximum Framework
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.FrameworkRange.IncludeMin">
      <summary>
            Minimum version inclusiveness.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.FrameworkRange.IncludeMax">
      <summary>
            Maximum version inclusiveness.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.FrameworkRange.FrameworkIdentifier">
      <summary>
            Framework Identifier of both the Min and Max
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.FrameworkReducer">
      <summary>
            Reduces a list of frameworks into the smallest set of frameworks required.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.#ctor">
      <summary>
            Creates a FrameworkReducer using the default framework mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.#ctor(NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Creates a FrameworkReducer using custom framework mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.GetNearest(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Returns the nearest matching framework that is compatible.
            </summary>
      <param name="framework">Project target framework</param>
      <param name="possibleFrameworks">Possible frameworks to narrow down</param>
      <returns>Nearest compatible framework. If no frameworks are compatible null is returned.</returns>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.ReduceEquivalent(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Remove duplicates found in the equivalence mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.ReduceUpwards(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Reduce to the highest framework
            Ex: net45, net403, net40 -&gt; net45
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.ReduceDownwards(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Reduce to the lowest framework
            Ex: net45, net403, net40 -&gt; net40
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.ExplodePortableFrameworks(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework},System.Boolean)">
      <summary>
            Create lookup of the given PCLs to their actual frameworks
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.ExplodePortableFramework(NuGet.Frameworks.NuGetFramework,System.Boolean)">
      <summary>
            portable-net45+win8 -&gt; net45, win8
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.GetBestPCL(System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework})">
      <summary>
            Order PCLs when there is no other way to decide.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.FrameworkReducer.IsBetterPCL(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Sort PCLs using these criteria
            1. Lowest number of frameworks (highest surface area) wins first
            2. Profile with the highest version numbers wins next
            3. String compare is used as a last resort
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.FrameworkSpecificMapping">
      <summary>
            A keyvalue pair specific to a framework identifier
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.NuGetFramework">
      <summary>
            A portable implementation of the .NET FrameworkName type with added support for NuGet folder names.
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.NuGetFramework.Comparer">
      <summary>
            Full framework comparison of the identifier, version, profile, platform, and platform version
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.NuGetFramework.FrameworkNameComparer">
      <summary>
            Framework name only comparison.
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.NuGetFramework._packagesBased">
      <summary>
            Frameworks that are packages based across all versions.
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.NuGetFramework.UnsupportedFramework">
      <summary>
            An unknown or invalid framework
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.NuGetFramework.AgnosticFramework">
      <summary>
            A framework with no specific target framework. This can be used for content only packages.
            </summary>
    </member>
    <member name="F:NuGet.Frameworks.NuGetFramework.AnyFramework">
      <summary>
            A wildcard matching all frameworks
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.GetDotNetFrameworkName(NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Formatted to a System.Versioning.FrameworkName
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.GetShortFolderName">
      <summary>
            Creates the shortened version of the framework using the default mappings.
            Ex: net45
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.GetShortFolderName(NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Creates the shortened version of the framework using the given mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.Parse(System.String)">
      <summary>
            Creates a NuGetFramework from a folder name using the default mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.Parse(System.String,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Creates a NuGetFramework from a folder name using the given mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.ParseFrameworkName(System.String,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Creates a NuGetFramework from a .NET FrameworkName
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.ParseFolder(System.String)">
      <summary>
            Creates a NuGetFramework from a folder name using the default mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.ParseFolder(System.String,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Creates a NuGetFramework from a folder name using the given mappings.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.TryParseDeprecatedFramework(System.String,NuGet.Frameworks.NuGetFramework@)">
      <summary>
            Attempt to parse a common but deprecated framework using an exact string match
            Support for these should be dropped as soon as possible.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFramework.TryParseCommonFramework(System.String,NuGet.Frameworks.NuGetFramework@)">
      <summary>
            A set of special and common frameworks that can be returned from the list of constants without parsing
            Using the interned frameworks here optimizes comparisons since they can be checked by reference.
            This is designed to optimize
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.Framework">
      <summary>
            Target framework
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.Version">
      <summary>
            Target framework version
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.HasProfile">
      <summary>
            True if the profile is non-empty
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.Profile">
      <summary>
            Target framework profile
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.DotNetFrameworkName">
      <summary>
            Formatted to a System.Versioning.FrameworkName
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.IsPCL">
      <summary>
            Portable class library check
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.IsPackageBased">
      <summary>
            True if the framework is packages based.
            Ex: dotnet, dnxcore, netcoreapp, netstandard, uap, netcore50
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.AllFrameworkVersions">
      <summary>
            True if this framework matches for all versions.
            Ex: net
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.IsUnsupported">
      <summary>
            True if this framework was invalid or unknown. This framework is only compatible with Any and Agnostic.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.IsAgnostic">
      <summary>
            True if this framework is non-specific. Always compatible.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.IsAny">
      <summary>
            True if this is the any framework. Always compatible.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.NuGetFramework.IsSpecificFramework">
      <summary>
            True if this framework is real and not one of the special identifiers.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework,System.Func{``0,NuGet.Frameworks.NuGetFramework})">
      <summary>
            Find the most compatible group based on target framework
            </summary>
      <param name="items">framework specific groups or items</param>
      <param name="framework">project target framework</param>
      <param name="selector">retrieves the framework from the group</param>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider,System.Func{``0,NuGet.Frameworks.NuGetFramework})">
      <summary>
            Find the most compatible group based on target framework
            </summary>
      <param name="items">framework specific groups or items</param>
      <param name="framework">project target framework</param>
      <param name="selector">retrieves the framework from the group</param>
      <param name="frameworkMappings">framework mappings</param>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework)">
      <summary>
            Find the most compatible group based on target framework
            </summary>
      <param name="items">framework specific groups or items</param>
      <param name="framework">project target framework</param>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.GetNearest``1(System.Collections.Generic.IEnumerable{``0},NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Find the most compatible group based on target framework
            </summary>
      <param name="items">framework specific groups or items</param>
      <param name="framework">project target framework</param>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.IsCompatibleWithFallbackCheck(NuGet.Frameworks.NuGetFramework,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Check compatibility with additional checks for the fallback framework.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.NuGetFrameworkUtility.IsNetCore50AndUp(NuGet.Frameworks.NuGetFramework)">
      <summary>
            True if the framework is netcore50 or higher. This is where the framework
            becomes packages based.
            </summary>
    </member>
    <member name="M:NuGet.Frameworks.OneWayCompatibilityMappingEntry.#ctor(NuGet.Frameworks.FrameworkRange,NuGet.Frameworks.FrameworkRange)">
      <summary>
            Creates a one way compatibility mapping.
            Ex: net -supports-&gt; native
            </summary>
      <param name="targetFramework">Project framework</param>
      <param name="supportedFramework">Framework that is supported by the project framework</param>
    </member>
    <member name="P:NuGet.Frameworks.OneWayCompatibilityMappingEntry.TargetFrameworkRange">
      <summary>
            Primary framework range or project target framework that supports the SuppportedFrameworkRange
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.OneWayCompatibilityMappingEntry.SupportedFrameworkRange">
      <summary>
            Framework range that is supported by the TargetFrameworkRange
            </summary>
    </member>
    <member name="T:NuGet.Frameworks.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.FrameworkMismatch">
      <summary>
              Looks up a localized string similar to Frameworks must have the same identifier, profile, and platform..
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.InvalidFrameworkIdentifier">
      <summary>
              Looks up a localized string similar to Invalid framework identifier '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.InvalidFrameworkVersion">
      <summary>
              Looks up a localized string similar to Invalid framework version '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.InvalidPortableFrameworksDueToHyphen">
      <summary>
              Looks up a localized string similar to Invalid portable frameworks '{0}'. A hyphen may not be in any of the portable framework names..
            </summary>
    </member>
    <member name="P:NuGet.Frameworks.Strings.MissingPortableFrameworks">
      <summary>
              Looks up a localized string similar to Invalid portable frameworks for '{0}'. A portable framework must have at least one framework in the profile..
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.LibraryModel615774.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.LibraryModel615774.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.LibraryModel615774.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.LibraryModel615774.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.LibraryModel615774.HashCodeCombiner.GetHashCode``2(``0,``1)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.LibraryModel615774.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.LibraryModel615774.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
      <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
    </member>
    <member name="M:NuGet.Shared.NuGet.LibraryModel615774.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryDependency.HasFlag(NuGet.LibraryModel.LibraryDependencyTypeFlag)">
      <summary>
            Type property flag
            </summary>
    </member>
    <member name="P:NuGet.LibraryModel.LibraryDependency.AutoReferenced">
      <summary>
            True if the PackageReference is added by the SDK and not the user.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryDependencyInfo.CreateUnresolved(NuGet.LibraryModel.LibraryIdentity,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Unresolved
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryDependencyInfo.Create(NuGet.LibraryModel.LibraryIdentity,NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.LibraryModel.LibraryDependency})">
      <summary>
            Resolved
            </summary>
    </member>
    <member name="P:NuGet.LibraryModel.LibraryDependencyInfo.Resolved">
      <summary>
            False if the package could not be found.
            </summary>
    </member>
    <member name="P:NuGet.LibraryModel.LibraryDependencyInfo.Library">
      <summary>
            Original library identity from the nuspec.
            This contains the original casing for the id/version.
            </summary>
    </member>
    <member name="P:NuGet.LibraryModel.LibraryDependencyInfo.Dependencies">
      <summary>
            Dependencies
            </summary>
    </member>
    <member name="P:NuGet.LibraryModel.LibraryDependencyInfo.Framework">
      <summary>
            Target framework used to select the dependencies.
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryDependencyTarget.PackageProjectExternal">
      <summary>
            A package, project, or external project
            </summary>
    </member>
    <member name="T:NuGet.LibraryModel.LibraryDependencyTargetUtils">
      <summary>
            Helper methods for dealing with LibraryDependencyTarget strings.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryDependencyTargetUtils.Parse(System.String)">
      <summary>
            Convert flag string into a LibraryTypeFlag.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryDependencyTargetUtils.GetFlagString(NuGet.LibraryModel.LibraryDependencyTarget)">
      <summary>
            Convert type flags to a friendly string.
            </summary>
    </member>
    <member name="T:NuGet.LibraryModel.LibraryIncludeFlagUtils">
      <summary>
            Helper methods for dealing with include/exclude flag strings.
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryIncludeFlagUtils.DefaultSuppressParent">
      <summary>
            By default build, contentFiles, and analyzers do not flow transitively between projects.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryIncludeFlagUtils.GetFlags(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Convert set of flag strings into a LibraryIncludeFlags.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryIncludeFlagUtils.GetFlagString(NuGet.LibraryModel.LibraryIncludeFlags)">
      <summary>
            Convert library flags to a friendly string.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryIncludeFlagUtils.GetFlags(System.String,NuGet.LibraryModel.LibraryIncludeFlags)">
      <summary>
            Convert set of flag strings into a LibraryIncludeFlags.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryRange.TypeConstraintAllows(NuGet.LibraryModel.LibraryDependencyTarget)">
      <summary>
            True if the type constraint allows the flag.
            </summary>
    </member>
    <member name="M:NuGet.LibraryModel.LibraryRange.TypeConstraintAllowsAnyOf(NuGet.LibraryModel.LibraryDependencyTarget)">
      <summary>
            True if any flags are allowed by the constraint.
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.Project">
      <summary>
            Indicates that the library comes from compiling an XRE-based Project
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.ExternalProject">
      <summary>
            Indicates that the library comes from compiling an external project (such as an MSBuild-based project)
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.Package">
      <summary>
            Indicates that the library comes from a NuGet Package
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.Assembly">
      <summary>
            Indicates that the library comes from a stand-alone .NET Assembly
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.Reference">
      <summary>
            Indicates that the library comes from a .NET Assembly in a globally-accessible
            location such as the GAC or the Framework Reference Assemblies
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.WinMD">
      <summary>
            Indicates that the library comes from a Windows Metadata Assembly (.winmd file)
            </summary>
    </member>
    <member name="F:NuGet.LibraryModel.LibraryType.Unresolved">
      <summary>
            Indicates that the library could not be resolved
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging.Core628388.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging.Core628388.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging.Core628388.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Packaging.Core628388.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging.Core628388.HashCodeCombiner.GetHashCode``2(``0,``1)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging.Core628388.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging.Core628388.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
      <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging.Core628388.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.FrameworkSpecificGroup">
      <summary>
            A group of items/files from a nupkg with the same target framework.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.FrameworkSpecificGroup.#ctor(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Framework specific group
            </summary>
      <param name="targetFramework">group target framework</param>
      <param name="items">group items</param>
    </member>
    <member name="P:NuGet.Packaging.FrameworkSpecificGroup.TargetFramework">
      <summary>
            Group target framework
            </summary>
    </member>
    <member name="P:NuGet.Packaging.FrameworkSpecificGroup.Items">
      <summary>
            Item relative paths
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackageDependencyGroup">
      <summary>
            Package dependencies grouped to a target framework.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageDependencyGroup.#ctor(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependency})">
      <summary>
            Dependency group
            </summary>
      <param name="targetFramework">target framework</param>
      <param name="packages">dependant packages</param>
    </member>
    <member name="P:NuGet.Packaging.PackageDependencyGroup.TargetFramework">
      <summary>
            Dependency group target framework
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageDependencyGroup.Packages">
      <summary>
            Package dependencies
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.IPackageIdentityComparer">
      <summary>
            Compares the id and version of a package
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Core.PackageDependencyComparer.Default">
      <summary>
            Default comparer
            Null ranges and the All range are treated as equal.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageDependencyInfoComparer.Default">
      <summary>
            Default comparer
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.PackageIdentityComparer">
      <summary>
            Compares the Id, Version, and Version release label. Version build metadata is ignored.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentityComparer.#ctor">
      <summary>
            Default version range comparer.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentityComparer.#ctor(NuGet.Versioning.VersionComparison)">
      <summary>
            Compare versions with a specific VersionComparison
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentityComparer.#ctor(NuGet.Versioning.IVersionComparer)">
      <summary>
            Compare versions with a specific IVersionComparer
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentityComparer.Equals(NuGet.Packaging.Core.PackageIdentity,NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            True if the package identities are the same when ignoring build metadata.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentityComparer.GetHashCode(NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            Hash code of the id and version
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentityComparer.Compare(NuGet.Packaging.Core.PackageIdentity,NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            Compares on the Id first, then version
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageIdentityComparer.Default">
      <summary>
            Default comparer that compares on the id, version, and version release labels.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.ContentFilesEntry">
      <summary>
            metadata/contentFiles/files entry from a nuspec
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.ContentFilesEntry.Include">
      <summary>
            Included files
            </summary>
      <remarks>Required</remarks>
    </member>
    <member name="P:NuGet.Packaging.Core.ContentFilesEntry.Exclude">
      <summary>
            Excluded files
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.ContentFilesEntry.BuildAction">
      <summary>
            Build action
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.ContentFilesEntry.CopyToOutput">
      <summary>
            If true the item will be copied to the output folder.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.ContentFilesEntry.Flatten">
      <summary>
            If true the content items will keep the same folder structure in the output
            folder.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.ExtractPackageFileDelegate">
      <summary>
            Callback invoked to extract a package file.
            </summary>
      <param name="sourceFile">The path of the file in the package.</param>
      <param name="targetPath">The path to write to.</param>
      <param name="fileStream">The file <see cref="T:System.IO.Stream" />.</param>
      <returns>The file name if the file was written; otherwise <c>null</c>.</returns>
    </member>
    <member name="T:NuGet.Packaging.Core.IAsyncPackageCoreReader">
      <summary>
            A basic asynchronous package reader that provides the identity, min client version, and file access.
            </summary>
      <remarks>Higher level concepts used for normal development nupkgs should go at a higher level</remarks>
    </member>
    <member name="M:NuGet.Packaging.Core.IAsyncPackageCoreReader.GetIdentityAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets the identity of the package.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.Packaging.Core.PackageIdentity" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.Core.IAsyncPackageCoreReader.GetMinClientVersionAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets the minimum client version needed to consume the package.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.Versioning.NuGetVersion" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.Core.IAsyncPackageCoreReader.GetPackageTypesAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets zero or more package types from the .nuspec.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IReadOnlyList`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.Core.IAsyncPackageCoreReader.GetStreamAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously returns a file stream from the package.
            </summary>
      <param name="path">The file path in the package.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.IO.Stream" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.Core.IAsyncPackageCoreReader.GetFilesAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets all files in the package.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.Core.IAsyncPackageCoreReader.GetFilesAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets files in a folder in the package.
            </summary>
      <param name="folder">A folder path in the package.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> for files under the specified folder.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.Core.IAsyncPackageCoreReader.GetNuspecAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a nuspec stream.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.IO.Stream" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.Core.IAsyncPackageCoreReader.GetNuspecFileAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a nuspec file path.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.String" />
            representing the nuspec file path.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.Core.IAsyncPackageCoreReader.CopyFilesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},NuGet.Packaging.Core.ExtractPackageFileDelegate,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies files from a package to a new location.
            </summary>
      <param name="destination">The destination path to copy to.</param>
      <param name="packageFiles">The package files to copy.</param>
      <param name="extractFile">A package file extraction delegate.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns am
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> for the copied file paths.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Packaging.Core.INuspecCoreReader">
      <summary>
            A basic nuspec reader that understands ONLY the id, version, and min client version of a package.
            </summary>
      <remarks>Higher level concepts used for normal development nupkgs should go at a higher level</remarks>
    </member>
    <member name="M:NuGet.Packaging.Core.INuspecCoreReader.GetId">
      <summary>
            Package Id
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Packaging.Core.INuspecCoreReader.GetVersion">
      <summary>
            Package Version
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.INuspecCoreReader.GetMinClientVersion">
      <summary>
            Minimum client version needed to consume the package.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.INuspecCoreReader.GetPackageTypes">
      <summary>
            Gets zero or more package types from the .nuspec.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.INuspecCoreReader.GetIdentity">
      <summary>
            Id and Version of a package.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.INuspecCoreReader.GetMetadata">
      <summary>
            Package metadata in the nuspec
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.IPackageCoreReader">
      <summary>
            Basic package reader that provides the identity, min client version, and file access.
            </summary>
      <remarks>Higher level concepts used for normal development nupkgs should go at a higher level</remarks>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetIdentity">
      <summary>
            Gets the package identity.
            </summary>
      <returns>A package identity.</returns>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetMinClientVersion">
      <summary>
            Gets the minimum client version needed to consume the package.
            </summary>
      <returns>A NuGet version.</returns>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetPackageTypes">
      <summary>
            Gets zero or more package types from the .nuspec.
            </summary>
      <returns>A readonly list of package types.</returns>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetStream(System.String)">
      <summary>
            Gets a file stream from the package.
            </summary>
      <returns>A stream for a file in the package.</returns>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetFiles">
      <summary>
            Gets all files in the package.
            </summary>
      <returns>An enumerable of files in the package.</returns>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetFiles(System.String)">
      <summary>
            Gets files in a folder in the package.
            </summary>
      <param name="folder">Folder path</param>
      <returns>An enumerable of files under specified folder.</returns>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetNuspec">
      <summary>
            Gets a nuspec stream.
            </summary>
      <returns>A stream for the nuspec.</returns>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.GetNuspecFile">
      <summary>
            Gets a nuspec file path.
            </summary>
      <returns>The nuspec file path.</returns>
    </member>
    <member name="M:NuGet.Packaging.Core.IPackageCoreReader.CopyFiles(System.String,System.Collections.Generic.IEnumerable{System.String},NuGet.Packaging.Core.ExtractPackageFileDelegate,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Copies files from a package to a new location.
            </summary>
      <param name="destination">The destination folder path.</param>
      <param name="packageFiles">The package files to copy.</param>
      <param name="extractFile">A package file extraction delegate.</param>
      <param name="logger">A logger.</param>
      <param name="token">A cancellation token.</param>
      <returns>An enumerable of paths of files copied to the destination.</returns>
    </member>
    <member name="T:NuGet.Packaging.Core.NuspecCoreReader">
      <summary>
            A basic nuspec reader that understand id, version, and a flat list of dependencies.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReader.#ctor(System.IO.Stream)">
      <summary>
            Read a nuspec from a stream.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReader.#ctor(System.Xml.Linq.XDocument)">
      <summary>
            Reads a nuspec from XML
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReader.GetDependencies">
      <summary>
            Returns a flat list of dependencies from a nuspec
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.NuspecCoreReaderBase">
      <summary>
            A very basic Nuspec reader that understands the Id, Version, PackageType, and MinClientVersion of a package.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.#ctor(System.String)">
      <summary>
            Read a nuspec from a path.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.#ctor(System.IO.Stream)">
      <summary>
            Read a nuspec from a stream.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.#ctor(System.IO.Stream,System.Boolean)">
      <summary>
            Read a nuspec from a stream.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.#ctor(System.Xml.Linq.XDocument)">
      <summary>
            Reads a nuspec from XML
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetId">
      <summary>
            Id of the package
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetVersion">
      <summary>
            Version of the package
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetMinClientVersion">
      <summary>
            The minimum client version this package supports.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetPackageTypes">
      <summary>
            Gets zero or more package types from the .nuspec.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.IsServiceable">
      <summary>
            Returns if the package is serviceable.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetDevelopmentDependency">
      <summary>
            The developmentDependency attribute
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetMetadata">
      <summary>
            Nuspec Metadata
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecCoreReaderBase.GetMetadataValue(System.String)">
      <summary>
            Returns a nuspec metadata value or string.Empty.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.NuspecCoreReaderBase.MetadataValues">
      <summary>
            Indexed metadata values of the XML elements in the nuspec.
            If duplicate keys exist only the first is used.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.NuspecCoreReaderBase.Xml">
      <summary>
            Raw XML doc
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.NuspecUtility">
      <summary>
            Until NuspecReader and Manifest are unified, this is a place to share implementations of
            reading and parsing specific elements out of the .nuspec XML.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecUtility.GetPackageTypes(System.Xml.Linq.XElement,System.Boolean)">
      <summary>
            Gets the package types from a .nuspec metadata XML element.
            </summary>
      <param name="metadataNode">The metadata XML element.</param>
      <param name="useMetadataNamespace">
            Whether or not to use the metadata element's namespace when finding the package type
            nodes. If false is specified, only the local names of the package type nodes are used
            for comparison. If true is specified, the package type nodes must have the same
            namespace as the metadata node.
            </param>
      <returns>
            A list of package types. If no package types are found in the metadata node, an empty
            list is returned.
            </returns>
    </member>
    <member name="M:NuGet.Packaging.Core.NuspecUtility.IsServiceable(System.Xml.Linq.XElement)">
      <summary>
            Gets the value of serviceable element from a .nuspec metadata XML element.
            </summary>
      <param name="metadataNode">The metadata XML element.</param>
      <returns>
            true if the serviceable element is set in the .nuspec file as true, else false.
            </returns>
    </member>
    <member name="T:NuGet.Packaging.Core.PackageDependency">
      <summary>
            Represents a package dependency Id and allowed version range.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageDependency.GetHashCode">
      <summary>
            Hash code from the default PackageDependencyComparer
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageDependency.ToString">
      <summary>
            Id and Version range string
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageDependency.Id">
      <summary>
            Dependency package Id
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageDependency.Include">
      <summary>
            Types to include from the dependency package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageDependency.Exclude">
      <summary>
            Types to exclude from the dependency package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageDependency.VersionRange">
      <summary>
            Range of versions allowed for the depenency
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.PackageDependencyInfo">
      <summary>
            Represents a package identity and the dependencies of a package.
            </summary>
      <remarks>
            This class does not support groups of dependencies, the group will need to be selected before
            populating this.
            </remarks>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageDependencyInfo.#ctor(System.String,NuGet.Versioning.NuGetVersion,System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependency})">
      <summary>
            Represents a package identity and the dependencies of a package.
            </summary>
      <param name="id">package name</param>
      <param name="version">package version</param>
      <param name="dependencies">package dependencies</param>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageDependencyInfo.GetHashCode">
      <summary>
            Hash code from the default PackageDependencyInfoComparer
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageDependencyInfo.ToString">
      <summary>
            Example: Id : Dependency1, Dependency2
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageDependencyInfo.Dependencies">
      <summary>
            Package dependencies
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.PackageIdentity">
      <summary>
            Represents the core identity of a nupkg.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.#ctor(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Creates a new package identity.
            </summary>
      <param name="id">name</param>
      <param name="version">version</param>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.Equals(NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            True if the package identities are the same.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.Equals(NuGet.Packaging.Core.PackageIdentity,NuGet.Versioning.VersionComparison)">
      <summary>
            True if the identity objects are equal based on the given comparison mode.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.CompareTo(NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            Sorts based on the id, then version
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.Equals(System.Object)">
      <summary>
            Compare using the default comparer.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.GetHashCode">
      <summary>
            Creates a hash code using the default comparer.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Core.PackageIdentity.ToString">
      <summary>
            PackageIdentity.ToString returns packageId.packageVersion"
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageIdentity.Id">
      <summary>
            Package name
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageIdentity.Version">
      <summary>
            Package Version
            </summary>
      <remarks>can be null</remarks>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageIdentity.HasVersion">
      <summary>
            True if the version is non-null
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.PackageIdentity.Comparer">
      <summary>
            An equality comparer that checks the id, version, and version release label.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.PackageType">
             It is important that this type remains immutable due to the cloning of package specs
            
        </member>
    <member name="F:NuGet.Packaging.Core.PackagingCoreConstants.EmptyFolder">
      <summary>
            _._ denotes an empty folder since OPC does not allow an
            actual empty folder.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Core.PackagingCoreConstants.ForwardSlashEmptyFolder">
      <summary>
            /_._ can be used to check empty folders from package readers where the / is normalized.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Core.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.InvalidPackageTypeVersion">
      <summary>
              Looks up a localized string similar to Nuspec file contains a package type with an invalid package version '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.MissingMetadataNode">
      <summary>
              Looks up a localized string similar to Nuspec file does not contain the '{0}' node..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.MissingNuspec">
      <summary>
              Looks up a localized string similar to Nuspec file does not exist in package..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.MissingPackageTypeName">
      <summary>
              Looks up a localized string similar to Nuspec file contains a package type that is missing the name attribute..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.MultipleNuspecFiles">
      <summary>
              Looks up a localized string similar to Package contains multiple nuspec files..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.MultiplePackageTypes">
      <summary>
              Looks up a localized string similar to Nuspec file contains multiple package types. Zero or one package type nodes are allowed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Core.Strings.StringCannotBeNullOrEmpty">
      <summary>
              Looks up a localized string similar to String argument '{0}' cannot be null or empty.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging644742.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging644742.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging644742.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Packaging644742.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging644742.HashCodeCombiner.GetHashCode``2(``0,``1)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging644742.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging644742.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
      <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
    </member>
    <member name="M:NuGet.Shared.NuGet.Packaging644742.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
    </member>
    <member name="T:NuGet.RuntimeModel.IObjectWriter">
      <summary>
            Provides functionality for writing an object graph.
            The output format is defined by implementors.
            </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.IObjectWriter.WriteObjectStart(System.String)">
      <summary>
             Writes the start of a nested object.
            
             This new object becomes the scope for all other method calls until either WriteObjectStart
             is called again to start a new nested object or WriteObjectEnd is called.
            
             Every call to WriteObjectStart must be balanced by a corresponding call to WriteObjectEnd.
             </summary>
      <param name="name">The name of the object.  Throws if <c>null</c>.</param>
    </member>
    <member name="M:NuGet.RuntimeModel.IObjectWriter.WriteObjectEnd">
      <summary>
             Writes the end of a nested object.
            
             The parent object for this object becomes the scope for subsequent method calls.
             If this object is the root object, no further writing is allowed.
            
             Every call to WriteObjectStart must be balanced by a corresponding call to WriteObjectEnd.
             </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.IObjectWriter.WriteNameValue(System.String,System.Int32)">
      <summary>
            Writes a name-value pair.
            </summary>
      <param name="name">The name of the datum.  Throws if <c>null</c>.</param>
      <param name="value">The datum.</param>
    </member>
    <member name="M:NuGet.RuntimeModel.IObjectWriter.WriteNameValue(System.String,System.Boolean)">
      <summary>
            Writes a name-value pair.
            </summary>
      <param name="name">The name of the datum.  Throws if <c>null</c>.</param>
      <param name="value">The datum.</param>
    </member>
    <member name="M:NuGet.RuntimeModel.IObjectWriter.WriteNameValue(System.String,System.String)">
      <summary>
            Writes a name-value pair.
            </summary>
      <param name="name">The name of the datum.  Throws if <c>null</c>.</param>
      <param name="value">The datum.</param>
    </member>
    <member name="M:NuGet.RuntimeModel.IObjectWriter.WriteNameArray(System.String,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Writes a name-collection pair.
            </summary>
      <param name="name">The name of the data.  Throws if <c>null</c>.</param>
      <param name="values">The data.</param>
    </member>
    <member name="T:NuGet.RuntimeModel.JsonObjectWriter">
      <summary>
             Generates JSON from an object graph.
            
             This is non-private only to facilitate unit testing.
             </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.JsonObjectWriter.GetJson">
      <summary>
             Gets the JSON for the object.
            
             Once <see cref="M:NuGet.RuntimeModel.JsonObjectWriter.GetJson" /> is called, no further writing is allowed.
             </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.JsonObjectWriter.GetJObject">
      <summary>
            Gets the JObject (in-memory JSON model) for the object.
            
            Once <see cref="M:NuGet.RuntimeModel.JsonObjectWriter.GetJObject" /> is called, no further writing is allowed.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.RuntimeModel.JsonObjectWriter.WriteTo(Newtonsoft.Json.JsonTextWriter)">
      <summary>
             Writes the result to a <c>JsonTextWriter</c>.
            
             Once WriteTo is called, no further writing is allowed.
             </summary>
    </member>
    <member name="P:NuGet.RuntimeModel.RuntimeDependencySet.Id">
      <summary>
            Package Id
            </summary>
    </member>
    <member name="P:NuGet.RuntimeModel.RuntimeDependencySet.Dependencies">
      <summary>
            Package dependencies
            </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.RuntimeDescription.Merge(NuGet.RuntimeModel.RuntimeDescription,NuGet.RuntimeModel.RuntimeDescription)">
      <summary>
            Merges the content of the other runtime description in to this runtime description
            </summary>
      <param name="other">The other description to merge in to this description</param>
    </member>
    <member name="P:NuGet.RuntimeModel.RuntimeDescription.RuntimeDependencySets">
      <summary>
            RID specific package dependencies.
            </summary>
    </member>
    <member name="T:NuGet.RuntimeModel.RuntimeGraph.Cache`1">
      <summary>
            Helper for renting hashsets and lists.
            </summary>
    </member>
    <member name="T:NuGet.RuntimeModel.RuntimeGraph.RuntimeDependencyKey">
      <summary>
            RID + package id
            </summary>
    </member>
    <member name="T:NuGet.RuntimeModel.RuntimeGraph.RuntimeCompatKey">
      <summary>
            RID -&gt; RID compatibility key
            </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.RuntimeGraph.Merge(NuGet.RuntimeModel.RuntimeGraph,NuGet.RuntimeModel.RuntimeGraph)">
      <summary>
            Merges the content of the other runtime graph in to this runtime graph
            </summary>
      <param name="other">The other graph to merge in to this graph</param>
    </member>
    <member name="M:NuGet.RuntimeModel.RuntimeGraph.ExpandRuntime(System.String)">
      <summary>
            Find all compatible RIDs including the current RID.
            </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.RuntimeGraph.ExpandRuntimeInternal(System.String)">
      <summary>
            Expand runtimes in a BFS walk. This ensures that nearest RIDs are returned first.
            Ordering is important for finding the nearest runtime dependency.
            </summary>
    </member>
    <member name="M:NuGet.RuntimeModel.RuntimeGraph.AreCompatible(System.String,System.String)">
      <summary>
            Determines if two runtime identifiers are compatible, based on the import graph
            </summary>
      <param name="criteria">The criteria being tested</param>
      <param name="provided">The value the criteria is being tested against</param>
      <returns>
            true if an asset for the runtime in <paramref name="provided" /> can be installed in a project
            targetting <paramref name="criteria" />, false otherwise
            </returns>
    </member>
    <member name="M:NuGet.RuntimeModel.RuntimeGraph.FindRuntimeDependenciesInternal(NuGet.RuntimeModel.RuntimeGraph.RuntimeDependencyKey)">
      <summary>
            Find all possible dependencies for package id.
            </summary>
    </member>
    <member name="T:NuGet.RuntimeModel.RuntimePackageDependency">
      <summary>
            A package dependency for a specific RID.
            </summary>
    </member>
    <member name="P:NuGet.RuntimeModel.RuntimePackageDependency.Id">
      <summary>
            Dependency package id.
            </summary>
    </member>
    <member name="P:NuGet.RuntimeModel.RuntimePackageDependency.VersionRange">
      <summary>
            Dependency version constraint.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.IAsyncPackageContentReader">
      <summary>
            An asynchronous package content reader.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IAsyncPackageContentReader.GetFrameworkItemsAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously returns all framework references found in the nuspec.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="!:OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.IAsyncPackageContentReader.GetBuildItemsAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously returns all items under the build folder.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="!:OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.IAsyncPackageContentReader.GetToolItemsAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously returns all items under the tools folder.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="!:OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.IAsyncPackageContentReader.GetContentItemsAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously returns all items found in the content folder.
            </summary>
      <remarks>
            Some legacy behavior has been dropped here due to the mix of content folders and target framework
            folders here.
            </remarks>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="!:OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.IAsyncPackageContentReader.GetLibItemsAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously returns all lib items without any filtering.
            </summary>
      <remarks>Use GetReferenceItemsAsync(...) for the filtered list.</remarks>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="!:OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.IAsyncPackageContentReader.GetReferenceItemsAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously returns lib items + filtering based on the nuspec and other NuGet rules.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="!:OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.IAsyncPackageContentReader.GetPackageDependenciesAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously returns package dependencies.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="!:OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Packaging.INuspecReader">
      <summary>
            A development package nuspec reader
            </summary>
    </member>
    <member name="M:NuGet.Packaging.INuspecReader.GetLanguage">
      <summary>
            The locale ID for the package, such as en-us.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetFrameworkItems">
      <summary>
            Returns all framework references found in the nuspec.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetBuildItems">
      <summary>
            Returns all items under the build folder.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetToolItems">
      <summary>
            Returns all items under the tools folder.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetContentItems">
      <summary>
            Returns all items found in the content folder.
            </summary>
      <remarks>
            Some legacy behavior has been dropped here due to the mix of content folders and target framework
            folders here.
            </remarks>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetLibItems">
      <summary>
            Returns all lib items without any filtering. Use GetReferenceItems for the filtered list.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetReferenceItems">
      <summary>
            Returns lib items + filtering based on the nuspec and other NuGet rules.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageContentReader.GetPackageDependencies">
      <summary>
            Returns package dependencies.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.IPackageDownloader">
      <summary>
            A package downloader.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageDownloader.CopyNupkgFileToAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies a .nupkg to a target file path.
            </summary>
      <param name="destinationFilePath">The destination file path.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.Boolean" />
            indicating whether or not the copy was successful.</returns>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="destinationFilePath" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.IPackageDownloader.GetPackageHashAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package hash.
            </summary>
      <param name="hashAlgorithm">The hash algorithm.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.String" />
            representing the package hash.</returns>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="hashAlgorithm" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.IPackageDownloader.SetExceptionHandler(System.Func{System.Exception,System.Threading.Tasks.Task{System.Boolean}})">
      <summary>
            Sets an exception handler for package downloads.
            </summary>
      <remarks>The exception handler returns a task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.Boolean" />
            indicating whether or not the exception was handled.  To handle an exception and stop its
            propagation, the task should return <c>true</c>.  Otherwise, the exception will be rethrown.</remarks>
      <param name="handleExceptionAsync">An exception handler.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="handleExceptionAsync" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Packaging.IPackageDownloader.SetThrottle(System.Threading.SemaphoreSlim)">
      <summary>
            Sets a throttle for package downloads.
            </summary>
      <param name="throttle">A throttle.  Can be <c>null</c>.</param>
    </member>
    <member name="P:NuGet.Packaging.IPackageDownloader.ContentReader">
      <summary>
            Gets an asynchronous package content reader.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
    </member>
    <member name="P:NuGet.Packaging.IPackageDownloader.CoreReader">
      <summary>
            Gets an asynchronous package core reader.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
    </member>
    <member name="T:NuGet.Packaging.IPackageResolver">
      <summary>
            Core package resolver
            </summary>
    </member>
    <member name="M:NuGet.Packaging.IPackageResolver.Resolve(System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageIdentity},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo},System.Threading.CancellationToken)">
      <summary>
            Resolve a set of packages
            </summary>
      <param name="targets">Package or packages to install</param>
      <param name="availablePackages">All relevant packages. This list must include the target packages.</param>
      <returns>A set of packages meeting the package dependency requirements</returns>
    </member>
    <member name="M:NuGet.Packaging.IPackageResolver.Resolve(System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageIdentity},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo},System.Collections.Generic.IEnumerable{NuGet.Packaging.PackageReference},System.Threading.CancellationToken)">
      <summary>
            Resolve a set of packages
            </summary>
      <param name="targets">Package or packages to install</param>
      <param name="availablePackages">
            All relevant packages. This list must include the target packages and
            installed packages.
            </param>
      <param name="installedPackages">
            Packages already installed into the project. These will be favored as
            dependency options.
            </param>
      <returns>A set of packages meeting the package dependency requirements</returns>
    </member>
    <member name="M:NuGet.Packaging.IPackageResolver.Resolve(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo},System.Threading.CancellationToken)">
      <summary>
            Resolve a set of packages
            </summary>
      <param name="targets">Package or packages to install</param>
      <param name="availablePackages">All relevant packages. This list must include the target packages.</param>
      <returns>A set of packages meeting the package dependency requirements</returns>
    </member>
    <member name="M:NuGet.Packaging.IPackageResolver.Resolve(System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo},System.Collections.Generic.IEnumerable{NuGet.Packaging.PackageReference},System.Threading.CancellationToken)">
      <summary>
            Resolve a set of packages
            </summary>
      <param name="targets">Package or packages to install</param>
      <param name="availablePackages">
            All relevant packages. This list must include the target packages and
            installed packages.
            </param>
      <param name="installedPackages">
            Packages already installed into the project. These will be favored as
            dependency options.
            </param>
      <returns>A set of packages meeting the package dependency requirements</returns>
    </member>
    <member name="T:NuGet.Packaging.MinClientVersionException">
      <summary>
            Custom exception type for a package that has a higher minClientVersion than the current client.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.FallbackPackagePathInfo.PathResolver">
      <summary>
            Path resolver for the root package folder containing this package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.FallbackPackagePathInfo.Id">
      <summary>
            Package id.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.FallbackPackagePathInfo.Version">
      <summary>
            Package version.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.FallbackPackagePathResolver.#ctor(NuGet.Common.INuGetPathContext)">
      <summary>
            Creates a package folder path resolver that scans multiple folders to find a package.
            </summary>
      <param name="pathContext">NuGet paths loaded from NuGet.Config settings.</param>
    </member>
    <member name="M:NuGet.Packaging.FallbackPackagePathResolver.GetPackageDirectory(System.String,System.String)">
      <summary>
            Returns the root directory of an installed package.
            </summary>
      <param name="packageId">Package id.</param>
      <param name="version">Package version.</param>
      <returns>Returns the path if the package exists in any of the folders. Null if the package does not exist.</returns>
    </member>
    <member name="M:NuGet.Packaging.FallbackPackagePathResolver.GetPackageDirectory(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Returns the root directory of an installed package.
            </summary>
      <param name="packageId">Package id.</param>
      <param name="version">Package version.</param>
      <returns>Returns the path if the package exists in any of the folders. Null if the package does not exist.</returns>
    </member>
    <member name="M:NuGet.Packaging.FallbackPackagePathResolver.GetPackageInfo(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Returns the package info along with a path resolver specific to the folder where the package exists.
            </summary>
      <param name="packageId">Package id.</param>
      <param name="version">Package version.</param>
      <returns>Returns the package info if the package exists in any of the folders. Null if the package does not exist.</returns>
    </member>
    <member name="T:NuGet.Packaging.LocalPackageArchiveDownloader">
      <summary>
            A package downloader for local archive packages.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.LocalPackageArchiveDownloader.#ctor(System.String,System.String,NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger)">
      <summary>
            Initializes a new <see cref="T:NuGet.Packaging.LocalPackageArchiveDownloader" /> class.
            </summary>
      <param name="source">A package source.</param>
      <param name="packageFilePath">A source package archive file path.</param>
      <param name="packageIdentity">A package identity.</param>
      <param name="logger">A logger.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageFilePath" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageIdentity" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="M:NuGet.Packaging.LocalPackageArchiveDownloader.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.LocalPackageArchiveDownloader.CopyNupkgFileToAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies a .nupkg to a target file path.
            </summary>
      <param name="destinationFilePath">The destination file path.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.Boolean" />
            indicating whether or not the copy was successful.</returns>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="destinationFilePath" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.LocalPackageArchiveDownloader.GetPackageHashAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package hash.
            </summary>
      <param name="hashAlgorithm">The hash algorithm.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.String" />
            representing the package hash.</returns>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="hashAlgorithm" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Packaging.LocalPackageArchiveDownloader.SetExceptionHandler(System.Func{System.Exception,System.Threading.Tasks.Task{System.Boolean}})">
      <summary>
            Sets an exception handler for package downloads.
            </summary>
      <remarks>The exception handler returns a task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.Boolean" />
            indicating whether or not the exception was handled.  To handle an exception and stop its
            propagation, the task should return <c>true</c>.  Otherwise, the exception will be rethrown.</remarks>
      <param name="handleExceptionAsync">An exception handler.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="handleExceptionAsync" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Packaging.LocalPackageArchiveDownloader.SetThrottle(System.Threading.SemaphoreSlim)">
      <summary>
            Sets a throttle for package downloads.
            </summary>
      <param name="throttle">A throttle.  Can be <c>null</c>.</param>
    </member>
    <member name="P:NuGet.Packaging.LocalPackageArchiveDownloader.ContentReader">
      <summary>
            Gets an asynchronous package content reader.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
    </member>
    <member name="P:NuGet.Packaging.LocalPackageArchiveDownloader.CoreReader">
      <summary>
            Gets an asynchronous package core reader.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
    </member>
    <member name="T:NuGet.Packaging.MinClientVersionUtility">
      <summary>
            Helpers for dealing with the NuGet client version and package minClientVersions.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.MinClientVersionUtility.VerifyMinClientVersion(NuGet.Packaging.Core.NuspecCoreReaderBase)">
      <summary>
            Check the package minClientVersion and throw if it is greater than the current client version.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.MinClientVersionUtility.IsMinClientVersionCompatible(NuGet.Packaging.Core.NuspecCoreReaderBase)">
      <summary>
            Verify minClientVersion.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.MinClientVersionUtility.IsMinClientVersionCompatible(NuGet.Versioning.NuGetVersion)">
      <summary>
            Verify minClientVersion.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.MinClientVersionUtility.GetNuGetClientVersion">
      <summary>
            Read the NuGet client version from the assembly info as a NuGetVersion.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.NuspecReader">
      <summary>
            Reads .nuspec files
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.#ctor(System.String)">
      <summary>
            Nuspec file reader.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.#ctor(System.String,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Nuspec file reader.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.#ctor(System.IO.Stream)">
      <summary>
            Nuspec file reader
            </summary>
      <param name="stream">Nuspec file stream.</param>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.#ctor(System.Xml.Linq.XDocument)">
      <summary>
            Nuspec file reader
            </summary>
      <param name="xml">Nuspec file xml data.</param>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.#ctor(System.IO.Stream,NuGet.Frameworks.IFrameworkNameProvider,System.Boolean)">
      <summary>
            Nuspec file reader
            </summary>
      <param name="stream">Nuspec file stream.</param>
      <param name="frameworkProvider">Framework mapping provider for NuGetFramework parsing.</param>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.#ctor(System.Xml.Linq.XDocument,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Nuspec file reader
            </summary>
      <param name="xml">Nuspec file xml data.</param>
      <param name="frameworkProvider">Framework mapping provider for NuGetFramework parsing.</param>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetDependencyGroups">
      <summary>
            Read package dependencies for all frameworks
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetDependencyGroups(System.Boolean)">
      <summary>
            Read package dependencies for all frameworks
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetReferenceGroups">
      <summary>
            Reference item groups
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetFrameworkReferenceGroups">
      <summary>
            Framework reference groups
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetLanguage">
      <summary>
            Package language
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetLicenseUrl">
      <summary>
            Package License Url
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetContentFiles">
      <summary>
            Build action groups
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetTitle">
      <summary>
            Package title.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetAuthors">
      <summary>
            Package authors.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetTags">
      <summary>
            Package tags.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetOwners">
      <summary>
            Package owners.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetDescription">
      <summary>
            Package description.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetReleaseNotes">
      <summary>
            Package release notes.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetSummary">
      <summary>
            Package summary.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetProjectUrl">
      <summary>
            Package project url.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetIconUrl">
      <summary>
            Package icon url.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetCopyright">
      <summary>
            Copyright information.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetRepositoryMetadata">
      <summary>
            Source control repository information.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.NuspecReader.GetRequireLicenseAcceptance">
      <summary>
            Require license acceptance when installing the package.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackageArchiveReader">
      <summary>
            Reads a development nupkg
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.#ctor(System.IO.Stream)">
      <summary>
            Nupkg package reader
            </summary>
      <param name="stream">Nupkg data stream.</param>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.#ctor(System.IO.Stream,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Nupkg package reader
            </summary>
      <param name="stream">Nupkg data stream.</param>
      <param name="frameworkProvider">Framework mapping provider for NuGetFramework parsing.</param>
      <param name="compatibilityProvider">Framework compatibility provider.</param>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.#ctor(System.IO.Stream,System.Boolean)">
      <summary>
            Nupkg package reader
            </summary>
      <param name="stream">Nupkg data stream.</param>
      <param name="leaveStreamOpen">If true the nupkg stream will not be closed by the zip reader.</param>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.#ctor(System.IO.Stream,System.Boolean,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Nupkg package reader
            </summary>
      <param name="stream">Nupkg data stream.</param>
      <param name="leaveStreamOpen">leave nupkg stream open</param>
      <param name="frameworkProvider">Framework mapping provider for NuGetFramework parsing.</param>
      <param name="compatibilityProvider">Framework compatibility provider.</param>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.#ctor(System.IO.Compression.ZipArchive)">
      <summary>
            Nupkg package reader
            </summary>
      <param name="zipArchive">ZipArchive containing the nupkg data.</param>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.#ctor(System.IO.Compression.ZipArchive,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Nupkg package reader
            </summary>
      <param name="zipArchive">ZipArchive containing the nupkg data.</param>
      <param name="frameworkProvider">Framework mapping provider for NuGetFramework parsing.</param>
      <param name="compatibilityProvider">Framework compatibility provider.</param>
    </member>
    <member name="M:NuGet.Packaging.PackageArchiveReader.ValidatePackageEntriesAsync(System.Threading.CancellationToken)">
      <summary>
            Validate all files in package are not traversed outside of the expected extraction path.
            Eg: file entry like ../../foo.dll can get outside of the expected extraction path.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageArchiveReader.SigningSpecifications">
      <summary>
            Signature specifications.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageArchiveReader.ZipReadStream">
      <summary>
            Stream underlying the ZipArchive. Used to do signature verification on a SignedPackageArchive.
            If this is null then we cannot perform signature verification.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.EmptyFrameworkFolderFile">
      <summary>
            Represents an empty framework folder in NuGet 2.0+ packages. 
            An empty framework folder is represented by a file named "_._".
            </summary>
    </member>
    <member name="P:NuGet.Packaging.IPackageFile.Path">
      <summary>
            Gets the full path of the file inside the package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.IPackageFile.EffectivePath">
      <summary>
            Gets the path that excludes the root folder (content/lib/tools) and framework folder (if present).
            </summary>
      <example>
            If a package has the Path as 'content\[net40]\scripts\jQuery.js', the EffectivePath 
            will be 'scripts\jQuery.js'.
            
            If it is 'tools\init.ps1', the EffectivePath will be 'init.ps1'.
            </example>
    </member>
    <member name="P:NuGet.Packaging.IPackageMetadata.FrameworkReferences">
      <summary>
            Specifies assemblies from GAC that the package depends on.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.IPackageMetadata.PackageAssemblyReferences">
      <summary>
            Returns sets of References specified in the manifest.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.IPackageMetadata.DependencyGroups">
      <summary>
            Specifies sets other packages that the package depends on.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.IPackageMetadata.ContentFiles">
      <summary>
            Returns sets of Content Files specified in the manifest.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Manifest.Save(System.IO.Stream)">
      <summary>
            Saves the current manifest to the specified stream.
            </summary>
      <param name="stream">The target stream.</param>
    </member>
    <member name="M:NuGet.Packaging.Manifest.Save(System.IO.Stream,System.Int32)">
      <summary>
            Saves the current manifest to the specified stream.
            </summary>
      <param name="stream">The target stream.</param>
      <param name="minimumManifestVersion">The minimum manifest version that this class must use when saving.</param>
    </member>
    <member name="M:NuGet.Packaging.ManifestMetadata.#ctor(NuGet.Packaging.IPackageMetadata)">
      <summary>
            Constructs a ManifestMetadata instance from an IPackageMetadata instance
            </summary>
    </member>
    <member name="F:NuGet.Packaging.ManifestSchemaUtility.SchemaVersionV1">
      <summary>
            Baseline schema 
            </summary>
    </member>
    <member name="F:NuGet.Packaging.ManifestSchemaUtility.SchemaVersionV2">
      <summary>
            Added copyrights, references and release notes
            </summary>
    </member>
    <member name="F:NuGet.Packaging.ManifestSchemaUtility.SchemaVersionV3">
      <summary>
            Used if the version is a semantic version.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.ManifestSchemaUtility.SchemaVersionV4">
      <summary>
            Added 'targetFramework' attribute for 'dependency' elements.
            Allow framework folders under 'content' and 'tools' folders. 
            </summary>
    </member>
    <member name="F:NuGet.Packaging.ManifestSchemaUtility.SchemaVersionV5">
      <summary>
            Added 'targetFramework' attribute for 'references' elements.
            Added 'minClientVersion' attribute
            </summary>
    </member>
    <member name="F:NuGet.Packaging.ManifestSchemaUtility.SchemaVersionV6">
      <summary>
            Allows XDT transformation
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageBuilder.ResolvePackagePath(System.String,System.String,System.String,System.String)">
      <summary>
            Determins the path of the file inside a package.
            For recursive wildcard paths, we preserve the path portion beginning with the wildcard.
            For non-recursive wildcard paths, we use the file name from the actual file path on disk.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageBuilder.IsKnownFolder(System.String)">
      <summary>
            Returns true if the path uses a known folder root.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageBuilder.ParseTags(System.String)">
      <summary>
            Tags come in this format. tag1 tag2 tag3 etc..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageBuilder.Properties">
      <summary>
            Exposes the additional properties extracted by the metadata 
            extractor or received from the command line.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageBuilder.ContentFiles">
      <summary>
            ContentFiles section from the manifest for content v2
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReferenceSet.#ctor(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Creates a new Package Reference Set
            </summary>
      <param name="references">IEnumerable set of string references</param>
    </member>
    <member name="M:NuGet.Packaging.PackageReferenceSet.#ctor(System.String,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Creates a new Package Reference Set
            </summary>
      <param name="targetFramework">The target framework to use, pass Any for AnyFramework. Does not allow null.</param>
      <param name="references">IEnumerable set of string references</param>
    </member>
    <member name="M:NuGet.Packaging.PackageReferenceSet.#ctor(NuGet.Frameworks.NuGetFramework,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Creates a new Package Reference Set
            </summary>
      <param name="targetFramework">The target framework to use.</param>
      <param name="references">IEnumerable set of string references</param>
    </member>
    <member name="P:NuGet.Packaging.PhysicalPackageFile.SourcePath">
      <summary>
            Path on disk
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PhysicalPackageFile.TargetPath">
      <summary>
            Path in package
            </summary>
    </member>
    <member name="M:NuGet.Packaging.FrameworkNameUtility.ParseFrameworkFolderName(System.String,System.Boolean,System.String@)">
      <summary>
            Parses the specified string into FrameworkName object.
            </summary>
      <param name="path">The string to be parse.</param>
      <param name="strictParsing">if set to <c>true</c>, parse the first folder of path even if it is unrecognized framework.</param>
      <param name="effectivePath">returns the path after the parsed target framework</param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Packaging.PackageHelper.GetSatellitePackageInfoAsync(NuGet.Packaging.Core.IAsyncPackageCoreReader,System.Threading.CancellationToken)">
      <summary>
            A package is deemed to be a satellite package if it has a language property set, the id of the package is
            of the format [.*].[Language]
            and it has at least one dependency with an id that maps to the runtime package .
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageHelper.GetInstalledPackageFilesAsync(NuGet.Packaging.PackageArchiveReader,NuGet.Packaging.Core.PackageIdentity,NuGet.Packaging.PackagePathResolver,NuGet.Packaging.PackageSaveMode,System.Threading.CancellationToken)">
      <summary>
            This returns all the installed package files (does not include satellite files)
            </summary>
    </member>
    <member name="F:NuGet.Packaging.PackageSaveMode.Defaultv2">
      <summary>
            Default package save mode for v2 (packages.config)-style restore.
            This includes <see cref="F:NuGet.Packaging.PackageSaveMode.Files" /> and <see cref="F:NuGet.Packaging.PackageSaveMode.Nupkg" />.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.PackageSaveMode.Defaultv3">
      <summary>
            Default package save mode for v3 (project.json)-style restore.
            This includes <see cref="F:NuGet.Packaging.PackageSaveMode.Files" />, <see cref="F:NuGet.Packaging.PackageSaveMode.Nuspec" />, and <see cref="F:NuGet.Packaging.PackageSaveMode.Nupkg" />.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.XmlDocFileSaveMode.None">
      <summary>
            Treat XML doc files as regular files (legacy behavior).
            </summary>
    </member>
    <member name="F:NuGet.Packaging.XmlDocFileSaveMode.Skip">
      <summary>
            Do not extract XML documentation files
            </summary>
    </member>
    <member name="F:NuGet.Packaging.XmlDocFileSaveMode.Compress">
      <summary>
            Compress XML doc files in a zip archive.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.ZipArchiveExtensions">
      <summary>
            Nupkg reading helper methods
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageExtractor.InstallFromSourceAsync(System.String,NuGet.Packaging.Core.PackageIdentity,System.Func{System.IO.Stream,System.Threading.Tasks.Task},NuGet.Packaging.VersionFolderPathResolver,NuGet.Packaging.PackageExtractionContext,System.Threading.CancellationToken,System.Guid)">
      <summary>
            Uses a copy function to install a package to a global packages directory.
            </summary>
      <param name="copyToAsync">
            A function which should copy the package to the provided destination stream.
            </param>
      <param name="packageExtractionContext">
            The version folder path context, which encapsulates all of the parameters to observe
            while installing the package.
            </param>
      <param name="token">The cancellation token.</param>
      <returns>
            True if the package was installed. False if the package already exists and therefore
            resulted in no copy operation.
            </returns>
    </member>
    <member name="M:NuGet.Packaging.PackageExtractor.DeleteTargetAndTempPaths(System.String,System.String)">
      <summary>
            Delete the target directory path and the temp nupkg path in case of a failed extraction.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackageFolderReader">
      <summary>
            Reads an unzipped nupkg folder.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.#ctor(System.String)">
      <summary>
            Package folder reader
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.#ctor(System.IO.DirectoryInfo)">
      <summary>
            Package folder reader
            </summary>
      <param name="folder">root directory of an extracted nupkg</param>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.#ctor(System.String,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Package folder reader
            </summary>
      <param name="folderPath">root directory of an extracted nupkg</param>
      <param name="frameworkProvider">framework mappings</param>
      <param name="compatibilityProvider">framework compatibility provider</param>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.#ctor(System.IO.DirectoryInfo,NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Package folder reader
            </summary>
      <param name="folder">root directory of an extracted nupkg</param>
      <param name="frameworkProvider">framework mappings</param>
      <param name="compatibilityProvider">framework compatibility provider</param>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.GetStream(System.String)">
      <summary>
            Opens a local file in read only mode.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.IsFileInRoot(System.String)">
      <summary>
            True if the path does not contain /
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.IsNupkg(System.String)">
      <summary>
            True if the path ends with .nupkg
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageFolderReader.GetRelativePath(System.IO.DirectoryInfo,System.IO.FileInfo)">
      <summary>
            Build the relative path in the same format that ZipArchive uses
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackagePathResolver">
      <summary>
            A V2 path resolver.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackageReaderBase">
      <summary>
            Abstract class that both the zip and folder package readers extend
            This class contains the path conventions for both zip and folder readers
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReaderBase.#ctor(NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Packaging.PackageReaderBase" /> class.
            </summary>
      <param name="frameworkProvider">A framework mapping provider.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="frameworkProvider" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Packaging.PackageReaderBase.#ctor(NuGet.Frameworks.IFrameworkNameProvider,NuGet.Frameworks.IFrameworkCompatibilityProvider)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Packaging.PackageReaderBase" /> class.
            </summary>
      <param name="frameworkProvider">A framework mapping provider.</param>
      <param name="compatibilityProvider">A framework compatibility provider.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="frameworkProvider" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="compatibilityProvider" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Packaging.PackageReaderBase.GetSupportedFrameworks">
      <summary>
            Frameworks mentioned in the package.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReaderBase.IsAllowedBuildFile(System.String,System.String)">
      <summary>
            only packageId.targets and packageId.props should be used from the build folder
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReaderBase.IsReferenceAssembly(System.String)">
      <summary>
            True only for assemblies that should be added as references to msbuild projects
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReaderBase.ValidatePackageEntry(System.String,System.String,NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            Validate file entry in package is not traversed outside of the expected extraction path.
            Eg: file entry like ../../foo.dll can get outside of the expected extraction path.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageReaderBase.NuspecReader">
      <summary>
            Nuspec reader
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackageReference">
      <summary>
            Represents a package element in the packages.config file
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReference.#ctor(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Creates a new packages config entry
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReference.#ctor(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,System.Boolean)">
      <summary>
            Creates a new packages config entry
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReference.#ctor(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Creates a new packages config entry
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackageReference.#ctor(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,System.Boolean,System.Boolean,System.Boolean,NuGet.Versioning.VersionRange)">
      <summary>
            Creates a new packages config entry
            </summary>
      <param name="identity">Package id and version</param>
      <param name="targetFramework">Package target framework installed to the project</param>
      <param name="userInstalled">True if the user installed this package directly</param>
      <param name="developmentDependency">True if the package is a development dependency</param>
      <param name="requireReinstallation">True if this package needs to be reinstalled</param>
      <param name="allowedVersions">Restrict package versions to the allowedVersions range</param>
    </member>
    <member name="M:NuGet.Packaging.PackageReference.ToString">
      <summary>
            Displays the identity and target framework of the reference.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.PackageIdentity">
      <summary>
            Id and Version of the package
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.AllowedVersions">
      <summary>
            The allowed range of versions that this package can be upgraded/downgraded to.
            </summary>
      <remarks>This is null if unbounded</remarks>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.HasAllowedVersions">
      <summary>
            True if allowedVersions exists.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.TargetFramework">
      <summary>
            Installed target framework version of the package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.IsDevelopmentDependency">
      <summary>
            Development dependency
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.IsUserInstalled">
      <summary>
            True if the user installed or updated this package directly.
            False if this package was installed as a dependency by another package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageReference.RequireReinstallation">
      <summary>
            Require reinstallation
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfig.HasAttributeValue(System.Xml.Linq.XElement,System.String,System.String,System.Xml.Linq.XElement@)">
      <summary>
            Determine if the package node has the attribute value as the targetValue.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfig.BoolAttribute(System.Xml.Linq.XElement,System.String,System.Boolean)">
      <summary>
            Get a boolean attribute value, or false if it does not exist
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackagesConfigReader">
      <summary>
            Reads packages.config
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.#ctor(System.Xml.Linq.XDocument)">
      <summary>
            Packages.config reader
            </summary>
      <param name="xml">Packages.config XML</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.#ctor(NuGet.Frameworks.IFrameworkNameProvider,System.Xml.Linq.XDocument)">
      <summary>
            Packages.config reader
            </summary>
      <param name="frameworkMappings">Additional target framework mappings for parsing target frameworks</param>
      <param name="xml">Packages.config XML</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.#ctor(System.IO.Stream)">
      <summary>
            Packages.config reader
            </summary>
      <param name="stream">Stream containing packages.config</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.#ctor(System.IO.Stream,System.Boolean)">
      <summary>
            Packages.config reader
            </summary>
      <param name="stream">Stream containing packages.config</param>
      <param name="leaveStreamOpen">True will leave the stream open</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.#ctor(NuGet.Frameworks.IFrameworkNameProvider,System.IO.Stream,System.Boolean)">
      <summary>
            Packages.config reader
            </summary>
      <param name="stream">Stream containing packages.config</param>
      <param name="leaveStreamOpen">True will leave the stream open</param>
      <param name="frameworkMappings">Additional target framework mappings for parsing target frameworks</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.GetMinClientVersion">
      <summary>
            Reads the minimum client version from packages.config
            </summary>
      <returns>Minimum client version or the default of 2.5.0</returns>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.GetPackages">
      <summary>
            Reads all package node entries in the config.
            If duplicate package ids exist an exception will be thrown.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigReader.GetPackages(System.Boolean)">
      <summary>
            Reads all package node entries in the config.
            </summary>
      <param name="allowDuplicatePackageIds">If True validation will be performed to ensure that 
            only one entry exists for each unique package id.</param>
    </member>
    <member name="T:NuGet.Packaging.PackagesConfigWriter">
      <summary>
            Writes the packages.config XML file to a stream
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.#ctor(System.String,System.Boolean)">
      <summary>
            Create a packages.config writer using file path
            </summary>
      <param name="fullPath">The full path to write the XML packages.config file into, or load existing packages.config from</param>
      <param name="createNew">Whether to create a new packages.config file, or load an existing one</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.#ctor(System.String,System.Boolean,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Create a packages.config writer using file path
            </summary>
      <param name="fullPath">The full path to write the XML packages.config file into, or load existing packages.config from</param>
      <param name="createNew">Whether to create a new packages.config file, or load an existing one</param>
      <param name="frameworkMappings">Framework mappings</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.#ctor(System.IO.Stream,System.Boolean)">
      <summary>
            Create a packages.config writer using stream
            </summary>
      <param name="stream">Stream to write the XML packages.config file into, or load existing packages.config from</param>
      <param name="createNew">Whether to create a new packages.config file, or load an existing one</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.#ctor(System.IO.Stream,System.Boolean,NuGet.Frameworks.IFrameworkNameProvider)">
      <summary>
            Create a packages.config writer using stream
            </summary>
      <param name="stream">Stream to write the XML packages.config file into, or load existing packages.config from</param>
      <param name="createNew">Whether to create a new packages.config file, or load an existing one</param>
      <param name="frameworkMappings">Framework mappings</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.WriteMinClientVersion(NuGet.Versioning.NuGetVersion)">
      <summary>
            Write a minimum client version to packages.config
            </summary>
      <param name="version">Minumum version of the client required to parse and use this file.</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.AddPackageEntry(System.String,NuGet.Versioning.NuGetVersion,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Add a package entry
            </summary>
      <param name="packageId">Package Id</param>
      <param name="version">Package Version</param>
      <param name="targetFramework">Package targetFramework that's compatible with current project</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.AddPackageEntry(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Adds a basic package entry to the file
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.AddPackageEntry(NuGet.Packaging.PackageReference)">
      <summary>
            Adds a package entry to the file
            </summary>
      <param name="entry">Package reference entry</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.UpdatePackageEntry(NuGet.Packaging.PackageReference,NuGet.Packaging.PackageReference)">
      <summary>
            Update a package entry to the file
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.UpdateOrAddPackageEntry(System.Xml.Linq.XDocument,NuGet.Packaging.PackageReference)">
      <summary>
            Update a package entry using the original entry as a base if it exists.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.RemovePackageEntry(System.String,NuGet.Versioning.NuGetVersion,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Remove a package entry
            </summary>
      <param name="packageId">Package Id</param>
      <param name="version">Package version</param>
      <param name="targetFramework">Package targetFramework</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.RemovePackageEntry(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Remove a package identity from the file
            </summary>
      <param name="identity">Package identity</param>
      <param name="targetFramework">Package targetFramework</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.RemovePackageEntry(NuGet.Packaging.PackageReference)">
      <summary>
            Removes a package entry from the file
            </summary>
      <param name="entry">Package reference entry</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.WriteFile(System.String)">
      <summary>
            Write the XDocument to the packages.config and disallow further changes.
            </summary>
      <param name="fullPath">the full path to packages.config file</param>
    </member>
    <member name="M:NuGet.Packaging.PackagesConfigWriter.Dispose">
      <summary>
            Write the XDocument to the stream and close it to disallow further changes.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.PackagingConstants.ManifestExtension">
      <summary>
            Represents the ".nuspec" extension.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.RepositorySignatureInfoProvider">
      <summary>
            RepositorySignatureInfoProvdier is a static cache for repository signature information for package source.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.RepositorySignatureInfoProvider.TryGetRepositorySignatureInfo(System.String,NuGet.Packaging.RepositorySignatureInfo@)">
      <summary>
            Try to get repository signature information for the source.
            </summary>
      <param name="source">Package source URL.</param>
      <param name="repositorySignatureInfo">Contains the RepositorySignatureInfo when the method returns. It is null if repository signature information is unavailable.</param>
      <returns>True if the repository signature information was found. Otherwise, False.</returns>
    </member>
    <member name="M:NuGet.Packaging.RepositorySignatureInfoProvider.AddOrUpdateRepositorySignatureInfo(System.String,NuGet.Packaging.RepositorySignatureInfo)">
      <summary>
            Add or update the repository signature information for the source.
            </summary>
      <param name="source">Package source URL.</param>
      <param name="repositorySignatureInfo">RepositorySignatureInfo for the source url.</param>
    </member>
    <member name="T:NuGet.Packaging.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ArgumentCannotBeNullOrEmpty">
      <summary>
              Looks up a localized string similar to The argument cannot be null or empty..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.AuthorPrimarySignatureFriendlyName">
      <summary>
              Looks up a localized string similar to author primary signature.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.CertificateChainBuildFailed">
      <summary>
              Looks up a localized string similar to A complete certificate chain could not be built for the signing certificate..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.CertificateChainValidationFailed">
      <summary>
              Looks up a localized string similar to Certificate chain validation failed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.CertUtilityCertificateHash">
      <summary>
              Looks up a localized string similar to {0} hash: {1}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.CertUtilityCertificateHashSha1">
      <summary>
              Looks up a localized string similar to SHA1 hash: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.CertUtilityCertificateIssuer">
      <summary>
              Looks up a localized string similar to Issued by: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.CertUtilityCertificateSubjectName">
      <summary>
              Looks up a localized string similar to Subject Name: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.CertUtilityCertificateValidity">
      <summary>
              Looks up a localized string similar to Valid from: {0} to {1}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.CertUtilityMultipleCertificatesFooter">
      <summary>
              Looks up a localized string similar to ... {0} more..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.CertUtilityMultipleCertificatesHeader">
      <summary>
              Looks up a localized string similar to The following certificates meet all given criteria:.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.CommitmentTypeIndicationAttributeInvalid">
      <summary>
              Looks up a localized string similar to The commitment-type-indication attribute is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.CommitmentTypeIndicationAttributeInvalidCombination">
      <summary>
              Looks up a localized string similar to The commitment-type-indication attribute contains an invalid combination of values..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Error_InvalidTargetFramework">
      <summary>
              Looks up a localized string similar to Unsupported targetFramework value '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Error_NoClientAllowList">
      <summary>
              Looks up a localized string similar to A list of trusted signers is required by the client but none was found..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Error_NoMatchingClientCertificate">
      <summary>
              Looks up a localized string similar to The package signature certificate fingerprint does not match any certificate fingerprint in client allow list..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Error_NoMatchingRepositoryCertificate">
      <summary>
              Looks up a localized string similar to The package signature certificate fingerprint does not match any certificate fingerprint in repository allow list..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Error_NoRepoAllowList">
      <summary>
              Looks up a localized string similar to A repository announced that their packages should be signed but an empty list of trusted certificates was found..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Error_NotOnePrimarySignature">
      <summary>
              Looks up a localized string similar to The package signature file does not contain exactly one primary signature..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Error_NotOneRepositoryCounterSignature">
      <summary>
              Looks up a localized string similar to The package signature contains multiple repository countersignatures..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Error_RepositorySignatureMustNotHaveARepositoryCountersignature">
      <summary>
              Looks up a localized string similar to A repository primary signature must not have a repository countersignature..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorAuthorTargetCannotBeACountersignature">
      <summary>
              Looks up a localized string similar to Cannot target author signatures that are countersignatures..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorByteSignatureNotFound">
      <summary>
              Looks up a localized string similar to Byte signature not found in package archive:  0x{0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorByteSignatureTooBig">
      <summary>
              Looks up a localized string similar to Byte signature too big to seek in current stream position..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorDuplicatePackages">
      <summary>
              Looks up a localized string similar to There are duplicate packages: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorInvalidAllowedVersions">
      <summary>
              Looks up a localized string similar to Invalid allowedVersions for package id '{0}': '{1}'.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorInvalidCertificateChainUnspecifiedReason">
      <summary>
              Looks up a localized string similar to Certificate chain validation failed for an unspecified reason..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorInvalidMinClientVersion">
      <summary>
              Looks up a localized string similar to Invalid minClientVersion: '{0}'.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorInvalidPackageArchive">
      <summary>
              Looks up a localized string similar to Invalid package archive..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorInvalidPackageVersion">
      <summary>
              Looks up a localized string similar to Invalid package version for package id '{0}': '{1}'.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorInvalidPackageVersionForDependency">
      <summary>
              Looks up a localized string similar to Invalid package version for a dependency with id '{0}' in package '{1}': '{2}'.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorManifestFileNotFound">
      <summary>
              Looks up a localized string similar to Manifest file not found at '{0}'.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorMultipleTimestamps">
      <summary>
              Looks up a localized string similar to Multiple timestamps are not accepted..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorNoTimestamp">
      <summary>
              Looks up a localized string similar to The signature should be timestamped to enable long-term signature validity after the certificate has expired..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorNullOrEmptyPackageId">
      <summary>
              Looks up a localized string similar to Null or empty package id.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorPackageNotSigned">
      <summary>
              Looks up a localized string similar to The package is not signed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorPackageSignatureInvalid">
      <summary>
              Looks up a localized string similar to The package signature is invalid or cannot be verified on this platform..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorUnableCheckPackageEntries">
      <summary>
              Looks up a localized string similar to An unexpected error occurred while checking package entries..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorUnableToDeleteFile">
      <summary>
              Looks up a localized string similar to Unable to delete temporary file '{0}'. Error: '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorUnsafePackageEntry">
      <summary>
              Looks up a localized string similar to The package '{0}' contains an entry which is unsafe for extraction..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ErrorZip64NotSupported">
      <summary>
              Looks up a localized string similar to Signed Zip64 packages are not supported..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ExactlyOneAttributeRequired">
      <summary>
              Looks up a localized string similar to Exactly one {0} attribute is required..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.ExactlyOneAttributeValueRequired">
      <summary>
              Looks up a localized string similar to The {0} attribute must have exactly one attribute value..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.FailedFileTime">
      <summary>
              Looks up a localized string similar to Failed to update file time for {0}: {1}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.FailToLoadPackagesConfig">
      <summary>
              Looks up a localized string similar to Fail to load packages.config as XML file. Please check it. .
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.FailToWritePackagesConfig">
      <summary>
              Looks up a localized string similar to Failed to write packages.config as XML file '{0}'. Error: '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.FallbackFolderNotFound">
      <summary>
              Looks up a localized string similar to Unable to find fallback package folder '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidArgument">
      <summary>
              Looks up a localized string similar to The argument is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidArgumentCombination">
      <summary>
              Looks up a localized string similar to Invalid combination of arguments {0} and {1}..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidAsn1">
      <summary>
              Looks up a localized string similar to The ASN.1 data is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidNuspecElement">
      <summary>
              Looks up a localized string similar to {0} This validation error occurred in a '{1}' element..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidNuspecEntry">
      <summary>
              Looks up a localized string similar to The nuspec contains an invalid entry '{0}' in package '{1}' ..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidPackageFrameworkFolderName">
      <summary>
              Looks up a localized string similar to The framework in the folder name of '{0}' in package '{1}' could not be parsed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidPackageNupkg">
      <summary>
              Looks up a localized string similar to The file is not a valid nupkg. File path: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidPackageSignature">
      <summary>
              Looks up a localized string similar to Package {0} signature is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidPackageSignatureFile">
      <summary>
              Looks up a localized string similar to The package contains an invalid package signature file..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidPackageSignatureFileEntry">
      <summary>
              Looks up a localized string similar to The package signature file entry is invalid. {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidPackageSignatureFileEntryCentralDirectoryHeader">
      <summary>
              Looks up a localized string similar to The central directory header field '{0}' has an invalid value ({1})..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidPackageSignatureFileEntryLocalFileHeader">
      <summary>
              Looks up a localized string similar to The local file header field '{0}' has an invalid value ({1})..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidPrimarySignature">
      <summary>
              Looks up a localized string similar to The primary signature is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidRepositoryCountersignature">
      <summary>
              Looks up a localized string similar to The repository countersignature is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidSignatureContent">
      <summary>
              Looks up a localized string similar to The package signature content is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidTimestampSignature">
      <summary>
              Looks up a localized string similar to The timestamp signature is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.InvalidUrl">
      <summary>
              Looks up a localized string similar to The URL value is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Log_InstallingPackage">
      <summary>
              Looks up a localized string similar to Installing {0} {1}..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.MinClientVersionAlreadyExist">
      <summary>
              Looks up a localized string similar to MinClientVersion already exists in packages.config.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.MissingNuspec">
      <summary>
              Looks up a localized string similar to Nuspec file does not exist in package..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.MultipleAttributesDisallowed">
      <summary>
              Looks up a localized string similar to Multiple {0} attributes are not allowed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.MultipleNuspecFiles">
      <summary>
              Looks up a localized string similar to Package contains multiple nuspec files..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.MultiplePackageSignatureFiles">
      <summary>
              Looks up a localized string similar to The package contains multiple package signature files..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.MustContainAbsolutePath">
      <summary>
              Looks up a localized string similar to '{0}' must contain an absolute path '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.NoPackageSignatureFile">
      <summary>
              Looks up a localized string similar to The package does not contain a valid package signature file..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.NoRepositoryCountersignature">
      <summary>
              Looks up a localized string similar to Verification settings require a repository countersignature, but the package does not have a repository countersignature..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.NuGetPackageOwners">
      <summary>
              Looks up a localized string similar to nuget-package-owners: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.NuGetPackageOwnersInvalid">
      <summary>
              Looks up a localized string similar to The nuget-package-owners attribute is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.NuGetPackageOwnersInvalidValue">
      <summary>
              Looks up a localized string similar to One or more package owner values are invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.NuGetV3ServiceIndexUrl">
      <summary>
              Looks up a localized string similar to nuget-v3-service-index-url: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.NuGetV3ServiceIndexUrlInvalid">
      <summary>
              Looks up a localized string similar to The nuget-v3-service-index-url attribute is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.NuGetV3ServiceIndexUrlInvalidValue">
      <summary>
              Looks up a localized string similar to The nuget-v3-service-index-url attribute value is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PackageEntryAlreadyExist">
      <summary>
              Looks up a localized string similar to Package entry already exists in packages.config. Id: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PackageEntryNotExist">
      <summary>
              Looks up a localized string similar to Package entry does not exists in packages.config. Id: {0}, Version: {1}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PackageMinVersionNotSatisfied">
      <summary>
              Looks up a localized string similar to The '{0}' package requires NuGet client version '{1}' or above, but the current NuGet version is '{2}'. To upgrade NuGet, please go to http://docs.nuget.org/consume/installing-nuget.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PackageSignatureVerificationLog">
      <summary>
              Looks up a localized string similar to PackageSignatureVerificationLog: PackageIdentity: {0} Source: {1} PackageSignatureValidity: {2}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PackagesNodeNotExist">
      <summary>
              Looks up a localized string similar to Packages node does not exists in packages.config at {0}..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PackageStreamShouldBeSeekable">
      <summary>
              Looks up a localized string similar to Package stream should be seekable.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PrimarySignatureFriendlyName">
      <summary>
              Looks up a localized string similar to primary signature.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.PrimarySignatureHasNoTimestamp">
      <summary>
              Looks up a localized string similar to The primary signature does not have a timestamp..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.RangeOutOfBoundsForArray">
      <summary>
              Looks up a localized string similar to Arguments {0} and {1} were out of bounds for the array..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.RepositoryCountersignatureFriendlyName">
      <summary>
              Looks up a localized string similar to repository countersignature.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.RepositoryCountersignatureHasNoCertificate">
      <summary>
              Looks up a localized string similar to The repository countersignature does not have a signing certificate..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.RepositoryCountersignatureHasNoTimestamp">
      <summary>
              Looks up a localized string similar to The repository countersignature does not have a timestamp..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.RepositoryPrimarySignatureFriendlyName">
      <summary>
              Looks up a localized string similar to repository primary signature.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignatureContainsInvalidAttribute">
      <summary>
              Looks up a localized string similar to Package signature contains an invalid attribute: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignatureDebug_HashOidFound">
      <summary>
              Looks up a localized string similar to Signature hash OID found: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignatureFailureInvalidHashAlgorithmOid">
      <summary>
              Looks up a localized string similar to The package hash uses an unsupported hash algorithm..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignatureFriendlyName">
      <summary>
              Looks up a localized string similar to signature.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignatureHashAlgorithm">
      <summary>
              Looks up a localized string similar to Signature Hash Algorithm: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignatureInvalidGeneralPurposeBits">
      <summary>
              Looks up a localized string similar to Invalid general purpose bit flags. Expected '{0}', actual '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignaturePackageIntegrityFailure">
      <summary>
              Looks up a localized string similar to The package integrity check failed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignatureType">
      <summary>
              Looks up a localized string similar to Signature type: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignedPackageAlreadySigned">
      <summary>
              Looks up a localized string similar to The package already contains a signature. Please remove the existing signature before adding a new signature..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignedPackageArchiveIOExtraRead">
      <summary>
              Looks up a localized string similar to Package stream read position cannot be longer than the length of the stream..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignedPackageArchiveIOInvalidRead">
      <summary>
              Looks up a localized string similar to Package stream read position cannot be before the current position in the stream..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignedPackageNotSignedOnRemove">
      <summary>
              Looks up a localized string similar to The package is not signed. Unable to remove signature from an unsigned package..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignedPackageNotSignedOnVerify">
      <summary>
              Looks up a localized string similar to The package is not signed. Unable to verify signature from an unsigned package..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignedPackagePackageAlreadyCountersigned">
      <summary>
              Looks up a localized string similar to The package already contains a repository countersignature. Please remove the existing signature before adding a new repository countersignature..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignedPackageUnableToAccessSignature">
      <summary>
              Looks up a localized string similar to The package was not opened correctly to perform signature operations. Please use a Stream-based constructor to have access to signature attributes of the package..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignError_TimestampCertificateFailsPublicKeyLengthRequirement">
      <summary>
              Looks up a localized string similar to The timestamp certificate does not meet a minimum public key length requirement..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignError_TimestampGeneralizedTimeInvalid">
      <summary>
              Looks up a localized string similar to The timestamp's generalized time is outside the timestamping certificate's validity period..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignError_TimestampIntegrityCheckFailed">
      <summary>
              Looks up a localized string similar to The timestamp integrity check failed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignError_TimestampNoCertificate">
      <summary>
              Looks up a localized string similar to The timestamp does not have a signing certificate..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignError_TimestampNotYetValid">
      <summary>
              Looks up a localized string similar to The timestamp signing certificate is not yet valid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignError_TimestampSignatureValidationFailed">
      <summary>
              Looks up a localized string similar to The timestamp signature validation failed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SignFailureCertificateInvalidProviderType">
      <summary>
              Looks up a localized string similar to The following certificate cannot be used for package signing as the private key provider is unsupported:.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningCannotBeDoneInPlace">
      <summary>
              Looks up a localized string similar to {0} and {1} should be different. Package signing cannot be done in place..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningCertificateAttributeMustNotBePresent">
      <summary>
              Looks up a localized string similar to The signing-certificate attribute is not allowed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningCertificateCertificateNotFound">
      <summary>
              Looks up a localized string similar to A certificate referenced by the signing-certificate attribute could not be found..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningCertificateInvalid">
      <summary>
              Looks up a localized string similar to The signing-certificate attribute is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningCertificateV1OrV2AttributeMustBePresent">
      <summary>
              Looks up a localized string similar to Either the signing-certificate or signing-certificate-v2 attribute must be present..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningCertificateV2CertificateNotFound">
      <summary>
              Looks up a localized string similar to A certificate referenced by the signing-certificate-v2 attribute could not be found..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningCertificateV2Invalid">
      <summary>
              Looks up a localized string similar to The signing-certificate-v2 attribute is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningCertificateV2NotExactlyOneAttributeValue">
      <summary>
              Looks up a localized string similar to The signing-certificate-v2 attribute does not have exactly one attribute value..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningCertificateV2UnsupportedHashAlgorithm">
      <summary>
              Looks up a localized string similar to The signing-certificate-v2 attribute uses an unsupported hash algorithm..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningError_CertificateFailsPublicKeyLengthRequirement">
      <summary>
              Looks up a localized string similar to The signing certificate does not meet a minimum public key length requirement..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningError_CertificateHasLifetimeSigningEKU">
      <summary>
              Looks up a localized string similar to The lifetime signing EKU in the signing certificate is not supported..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningError_CertificateHasUnsupportedSignatureAlgorithm">
      <summary>
              Looks up a localized string similar to The signing certificate has an unsupported signature algorithm..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.SigningError_NotYetValid">
      <summary>
              Looks up a localized string similar to The signing certificate is not yet valid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.StreamMustBeReadable">
      <summary>
              Looks up a localized string similar to The stream must be readable..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.StreamMustBeSeekable">
      <summary>
              Looks up a localized string similar to The stream must be seekable..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.StringCannotBeNullOrEmpty">
      <summary>
              Looks up a localized string similar to String argument '{0}' cannot be null or empty.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.TimestampCertificateInvalid">
      <summary>
              Looks up a localized string similar to The timestamp service's certificate has a valid time in the future: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.TimestampCertificateUnsupportedSignatureAlgorithm">
      <summary>
              Looks up a localized string similar to The timestamp certificate has an unsupported signature algorithm ({0}). The following algorithms are supported: {1}..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.TimestampFailureInvalidHttpScheme">
      <summary>
              Looks up a localized string similar to The timestamper URL '{0}' has an invalid URI scheme. The supported schemes are '{1}' and '{2}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.TimestampFailureNonceMismatch">
      <summary>
              Looks up a localized string similar to The timestamp response is invalid.  Nonces did not match..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.TimestampResponseExceptionGeneral">
      <summary>
              Looks up a localized string similar to Timestamp service's response does not meet the NuGet package signature specification: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.TimestampResponseUnsupportedDigestAlgorithm">
      <summary>
              Looks up a localized string similar to The timestamp response has an unsupported digest algorithm ({0}). The following algorithms are supported: {1}..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.TimestampValue">
      <summary>
              Looks up a localized string similar to Timestamp: {0}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.UnableToAddEntry">
      <summary>
              Looks up a localized string similar to An error occurred while updating packages.config. The file was closed before the entry could be added..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.UnableToParseClientVersion">
      <summary>
              Looks up a localized string similar to Unable to parse the current NuGet client version..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.UnableToReadPackageHashInformation">
      <summary>
              Looks up a localized string similar to Package hash information could not be read from the package signature..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.UnexpectedPackageSignatureVerificationError">
      <summary>
              Looks up a localized string similar to An unexpected error occurred while verifying a package signature..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.UnrecognizedEnumValue">
      <summary>
              Looks up a localized string similar to The enum value '{0}' is unrecognized..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.UnrelatedSignatures">
      <summary>
              Looks up a localized string similar to The primary signature and repository countersignature are unrelated..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.UnsupportedAsn1">
      <summary>
              Looks up a localized string similar to The ASN.1 data is unsupported..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.UnsupportedSignatureFormatVersion">
      <summary>
              Looks up a localized string similar to The package signature format version is not supported. Updating your client may solve this problem..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerificationCertDisplay">
      <summary>
              Looks up a localized string similar to Verifying the {0} with certificate: {1}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerificationTimestamperCertDisplay">
      <summary>
              Looks up a localized string similar to Verifying {0}'s timestamp with timestamping service certificate: {1}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.Verify_ErrorNoCertificate">
      <summary>
              Looks up a localized string similar to The {0} does not have a signing certificate..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyChainBuildingIssue">
      <summary>
              Looks up a localized string similar to The {0} found a chain building issue: {1}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_CertificateFailsPublicKeyLengthRequirement">
      <summary>
              Looks up a localized string similar to The {0}'s certificate does not meet a minimum public key length requirement..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_CertificateHasLifetimeSigningEKU">
      <summary>
              Looks up a localized string similar to The lifetime signing EKU in the {0}'s certificate is not supported..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_CertificateHasUnsupportedSignatureAlgorithm">
      <summary>
              Looks up a localized string similar to The {0}'s certificate has an unsupported signature algorithm..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_CertificateNotYetValid">
      <summary>
              Looks up a localized string similar to The {0}'s certificate is not yet valid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_InvalidCertificateChain">
      <summary>
              Looks up a localized string similar to The {0}'s certificate chain validation failed with error(s): {1}.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_SignatureNotTimeValid">
      <summary>
              Looks up a localized string similar to The {0} validity period has expired..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_SignatureVerificationFailed">
      <summary>
              Looks up a localized string similar to The {0} validation failed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_TimestampCertificateFailsPublicKeyLengthRequirement">
      <summary>
              Looks up a localized string similar to The {0}'s timestamp certificate does not meet a minimum public key length requirement..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_TimestampGeneralizedTimeInvalid">
      <summary>
              Looks up a localized string similar to The {0}'s timestamp's generalized time is outside the timestamping certificate's validity period..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_TimestampIntegrityCheckFailed">
      <summary>
              Looks up a localized string similar to The {0}'s timestamp integrity check failed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_TimestampInvalid">
      <summary>
              Looks up a localized string similar to The {0} contains an invalid timestamp..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_TimestampMessageImprintUnsupportedHashAlgorithm">
      <summary>
              Looks up a localized string similar to The {0} timestamp's message imprint uses an unsupported hash algorithm..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_TimestampNoCertificate">
      <summary>
              Looks up a localized string similar to The {0}'s timestamp does not have a signing certificate..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_TimestampNotYetValid">
      <summary>
              Looks up a localized string similar to The {0}'s timestamp signing certificate is not yet valid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_TimestampSignatureValidationFailed">
      <summary>
              Looks up a localized string similar to The {0}'s timestamp signature validation failed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_TimestampUnsupportedSignatureAlgorithm">
      <summary>
              Looks up a localized string similar to The {0}'s timestamp certificate has an unsupported signature algorithm..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Strings.VerifyError_TimestampVerifyChainBuildingIssue">
      <summary>
              Looks up a localized string similar to The {0}'s timestamp found a chain building issue: {1}.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.TopologicalSortUtility.SortPackagesByDependencyOrder``1(System.Collections.Generic.IEnumerable{``0},System.StringComparer,System.Func{``0,System.String},System.Func{``0,System.String[]})">
      <summary>
            Order dependencies by children first.
            </summary>
      <param name="items">Items to sort.</param>
      <param name="comparer">Comparer for Ids.</param>
      <param name="getId">Retrieve the id of the item.</param>
      <param name="getDependencies">Retrieve dependency ids.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Packaging.TopologicalSortUtility.SortPackagesByDependencyOrder(System.Collections.Generic.IEnumerable{NuGet.Packaging.Core.PackageDependencyInfo})">
      <summary>
            Order dependencies by children first.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.TopologicalSortUtility.SortPackagesByDependencyOrder(System.Collections.Generic.List{NuGet.Packaging.TopologicalSortUtility.ItemDependencyInfo},System.StringComparer)">
      <summary>
            Order dependencies by children first.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.VersionFolderPathResolver">
      <summary>
            A V3 path resolver.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Packaging.VersionFolderPathResolver" /> class.
            </summary>
      <param name="rootPath">The packages directory root folder.</param>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.#ctor(System.String,System.Boolean)">
      <summary>
            Initializes a new <see cref="T:NuGet.Packaging.VersionFolderPathResolver" /> class.
            </summary>
      <param name="rootPath">The packages directory root folder.</param>
      <param name="isLowercase">
        <c>true</c> if package ID's and versions are made lowercase;
            otherwise <c>false</c>.</param>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.GetInstallPath(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Gets the package install path.
            </summary>
      <param name="packageId">The package ID.</param>
      <param name="version">The package version.</param>
      <returns>The package install path.</returns>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.GetVersionListPath(System.String)">
      <summary>
            Gets the package version list path.
            </summary>
      <param name="packageId">The package ID.</param>
      <returns>The package version list path.</returns>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.GetPackageFilePath(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Gets the package file path.
            </summary>
      <param name="packageId">The package ID.</param>
      <param name="version">The package version.</param>
      <returns>The package file path.</returns>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.GetManifestFilePath(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Gets the manifest file path.
            </summary>
      <param name="packageId">The package ID.</param>
      <param name="version">The package version.</param>
      <returns>The manifest file path.</returns>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.GetHashPath(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Gets the hash file path.
            </summary>
      <param name="packageId">The package ID.</param>
      <param name="version">The package version.</param>
      <returns>The hash file path.</returns>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.GetHashFileName(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Gets the hash file name.
            </summary>
      <param name="packageId">The package ID.</param>
      <param name="version">The package version.</param>
      <returns>The hash file name.</returns>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.GetVersionListDirectory(System.String)">
      <summary>
            Gets the version list directory.
            </summary>
      <param name="packageId">The package ID.</param>
      <returns>The version list directory.</returns>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.GetPackageDirectory(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Gets the package directory.
            </summary>
      <param name="packageId">The package ID.</param>
      <param name="version">The package version.</param>
      <returns>The package directory.</returns>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.GetPackageFileName(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Gets the package file name.
            </summary>
      <param name="packageId">The package ID.</param>
      <param name="version">The package version.</param>
      <returns>The package file name.</returns>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.GetPackageDownloadMarkerFileName(System.String)">
      <summary>
            Gets the package download marker file name.
            </summary>
      <param name="packageId">The package ID.</param>
      <returns>The package download marker file name.</returns>
    </member>
    <member name="M:NuGet.Packaging.VersionFolderPathResolver.GetManifestFileName(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Gets the manifest file name.
            </summary>
      <param name="packageId">The package ID.</param>
      <param name="version">The package version.</param>
      <returns>The manifest file name.</returns>
    </member>
    <member name="P:NuGet.Packaging.VersionFolderPathResolver.RootPath">
      <summary>
            Gets the packages directory root folder.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.VersionFolderPathResolver.IsLowerCase">
      <summary>
            Gets a flag indicating whether or not package ID's and versions are made lowercase.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata">
      <summary>
            This class is used to hold metadata about the central directory archive structure
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.Position">
      <summary>
            Position in bytes of the corresponding central directory header relative to the start of the archive
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.OffsetToLocalFileHeader">
      <summary>
            Offset in bytes to the corresponding file header relative to the start of the archive
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.FileEntryTotalSize">
      <summary>
            Total size of corresponding file entry in bytes
            This should include size of local file header + encryption header + file data + data descriptor
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.IsPackageSignatureFile">
      <summary>
            Flag indicating if the entry is the package signature file
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.HeaderSize">
      <summary>
            Size of central directory header, in bytes.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.ChangeInOffset">
      <summary>
            Value used to identify how much the position of the OffsetToFileHeader property will change by
            the presence of a signature file in bytes
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.CentralDirectoryHeaderMetadata.IndexInHeaders">
      <summary>
            Index in which the central directory record was read from the archive.
            This index represents the order of the central directory record as it is in the file.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.Crc32">
      <summary>
            Helper to calculate CRC-32 for data.
            Derivative of a .NET core implementation - https://source.dot.net/#System.IO.Compression.Tests/Common/System/IO/Compression/CRC.cs
            This is public to allow testing.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.Crc32.CalculateCrc(System.Byte[])">
      <summary>
            Calculates a 32 bit cyclic redundancy code for the input data.
            </summary>
      <param name="data">Byte[] of the data.</param>
      <returns>32 bit cyclic redundancy code for the input data in uint.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.ReadAndWriteUntilPosition(System.IO.BinaryReader,System.IO.BinaryWriter,System.Int64)">
      <summary>
            Read bytes from a BinaryReader and write them to the BinaryWriter and stop when the provided position
            is the current position of the BinaryReader's base stream. It does not read the byte in the provided position.
            </summary>
      <param name="reader">Read bytes from this stream.</param>
      <param name="writer">Write bytes to this stream.</param>
      <param name="position">Position to stop copying data.</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.ReadAndHashUntilPosition(System.IO.BinaryReader,System.Security.Cryptography.HashAlgorithm,System.Int64)">
      <summary>
            Read bytes from a BinaryReader and hash them with a given HashAlgorithm and stop when the provided position
            is the current position of the BinaryReader's base stream. It does not hash the byte in the provided position.
            </summary>
      <param name="reader">Read bytes from this stream</param>
      <param name="hashAlgorithm">HashAlgorithm used to hash contents</param>
      <param name="position">Position to stop copying data</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.HashBytes(System.Security.Cryptography.HashAlgorithm,System.Byte[])">
      <summary>
            Hashes given byte array with a specified HashAlgorithm
            </summary>
      <param name="hashAlgorithm">HashAlgorithm used to hash contents</param>
      <param name="bytes">Content to hash</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.ReadSignedArchiveMetadata(System.IO.BinaryReader)">
      <summary>
            Read ZIP's offsets and positions of offsets.
            </summary>
      <param name="reader">binary reader to zip archive</param>
      <returns>metadata with offsets and positions for entries</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.AssertSignatureEntryMetadata(System.IO.BinaryReader,NuGet.Packaging.Signing.SignedPackageArchiveMetadata)">
      <summary>
            Asserts the validity of central directory header and local file header for the package signature file entry.
            </summary>
      <param name="reader">BinaryReader on the package.</param>
      <param name="metadata">Metadata for the package signature file's central directory header.</param>
      <exception cref="T:NuGet.Packaging.Signing.SignatureException">Thrown if either header is invalid.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.WriteSignatureIntoZip(System.IO.MemoryStream,System.IO.BinaryReader,System.IO.BinaryWriter)">
      <summary>
            Writes the signature data into the zip using the writer.
            The reader is used to read the exisiting zip. 
            </summary>
      <param name="signatureStream">MemoryStream of the signature to be inserted into the zip.</param>
      <param name="reader">BinaryReader to be used to read the existing zip data.</param>
      <param name="writer">BinaryWriter to be used to write the signature into the zip.</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.WriteLocalFileHeaderIntoZip(System.IO.BinaryWriter,System.Byte[],System.UInt32,System.UInt32)">
      <summary>
            Writes a local file header into a zip using the writer starting at the writer.BaseStream.Position.
            </summary>
      <param name="writer">BinaryWriter to be used to write file.</param>
      <param name="fileData">Byte[] of the corresponding file to be written into the zip.</param>
      <param name="crc32">CRC-32 for the file.</param>
      <param name="dosDateTime">Last modified DateTime for the file data.</param>
      <returns>Number of total bytes written into the zip.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.WriteFileIntoZip(System.IO.BinaryWriter,System.Byte[])">
      <summary>
            Writes a file into a zip using the writer starting at the writer.BaseStream.Position.
            </summary>
      <param name="writer">BinaryWriter to be used to write file.</param>
      <param name="fileData">Byte[] of the file to be written into the zip.</param>
      <returns>Number of total bytes written into the zip.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.WriteCentralDirectoryHeaderIntoZip(System.IO.BinaryWriter,System.Byte[],System.UInt32,System.UInt32,System.Int64)">
      <summary>
            Writes a central directory header into a zip using the writer starting at the writer.BaseStream.Position.
            </summary>
      <param name="writer">BinaryWriter to be used to write file.</param>
      <param name="fileData">Byte[] of the file to be written into the zip.</param>
      <param name="crc32">CRC-32 checksum for the file.</param>
      <param name="dosDateTime">Last modified DateTime for the file data.</param>
      <param name="fileOffset">Offset, in bytes, for the local file header of the corresponding file from the start of the archive.</param>
      <returns>Number of total bytes written into the zip.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.ReadAndWriteUpdatedEndOfCentralDirectoryRecordIntoZip(System.IO.BinaryReader,System.IO.BinaryWriter,System.SByte,System.Int64,System.Int64)">
      <summary>
            Writes the end of central directory header into a zip using the writer starting at the writer.BaseStream.Position.
            The new end of central directory record will be based on the one at reader.BaseStream.Position.
            </summary>
      <param name="reader">BinaryReader to be used to read the existing end of central directory record.</param>
      <param name="writer">BinaryWriter to be used to write the updated end of central directory record.</param>
      <param name="entryCountChange">The change to central directory header counts.</param>
      <param name="sizeOfSignatureCentralDirectoryRecord">Size of the central directory header for the signature file.</param>
      <param name="sizeOfSignatureFileHeaderAndData">Size of the signature file and the corresponding local file header.</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveIOUtility.DateTimeToDosTime(System.DateTime)">
      <summary>
            Converts a DateTime value into a unit in the MS-DOS date time format.
            Reference - https://docs.microsoft.com/en-us/cpp/c-runtime-library/32-bit-windows-time-date-formats
            Reference - https://source.dot.net/#System.IO.Compression/System/IO/Compression/ZipHelper.cs,91
            </summary>
      <param name="dateTime">DateTime value to be converted.</param>
      <returns>uint representing the MS-DOS equivalent date time.</returns>
    </member>
    <member name="T:NuGet.Packaging.Signing.SignedPackageArchiveMetadata">
      <summary>
            This class is used to hold metadata about the signed package archive being verified.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageArchiveMetadata.CentralDirectoryHeaders">
      <summary>
            List of central directory metadata ordered by the same order the central directory headers are in the archive
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageArchiveMetadata.StartOfLocalFileHeaders">
      <summary>
            Offset, in bytes, to the first file header relative to the start of the archive. Should typically be 0.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageArchiveMetadata.EndOfCentralDirectory">
      <summary>
            Offset, in bytes, to the end of central directory headers relative to the start of the archive.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageArchiveMetadata.SignatureCentralDirectoryHeaderIndex">
      <summary>
            Index of the signature central directory header in CentralDirectoryHeaders.
            If the CentralDirectoryHeaders list is ordered by IndexInHeaders this index indicates the position on the list for the signature.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveUtility.IsSigned(System.IO.BinaryReader)">
      <summary>
            Utility method to know if a zip archive is signed.
            </summary>
      <param name="reader">Binary reader pointing to a zip archive.</param>
      <returns>true if the given archive is signed</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveUtility.OpenPackageSignatureFileStream(System.IO.BinaryReader)">
      <summary>
            Opens a read-only stream for the package signature file.
            </summary>
      <remarks>Callers should first verify that a package is signed before calling this method.</remarks>
      <param name="reader">A binary reader for a signed package.</param>
      <returns>A readable stream.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="reader" /> is <c>null</c>.</exception>
      <exception cref="T:NuGet.Packaging.Signing.SignatureException">Thrown if a package signature file is invalid or missing.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveUtility.RemoveRepositorySignaturesAsync(System.IO.Stream,System.IO.Stream,System.Threading.CancellationToken)">
      <summary>
            Removes repository primary signature (if it exists) or any repository countersignature (if it exists).
            </summary>
      <param name="input">A readable stream for a signed package.</param>
      <param name="output">A read/write stream for receiving an updated package.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A flag indicating whether or not a signature was removed.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveUtility.SignZip(System.IO.MemoryStream,System.IO.BinaryReader,System.IO.BinaryWriter)">
      <summary>
            Signs a Zip with the contents in the SignatureStream using the writer.
            The reader is used to read the exisiting contents for the Zip.
            </summary>
      <param name="signatureStream">MemoryStream of the signature to be inserted into the zip.</param>
      <param name="reader">BinaryReader to be used to read the existing zip data.</param>
      <param name="writer">BinaryWriter to be used to write the signature into the zip.</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchiveUtility.VerifySignedPackageIntegrity(System.IO.BinaryReader,System.Security.Cryptography.HashAlgorithm,System.Byte[])">
      <summary>
            Verifies that a signed package archive's signature is valid and it has not been tampered with.
            </summary>
      <param name="reader">Signed package to verify</param>
      <param name="hashAlgorithm">Hash algorithm to be used to hash data.</param>
      <param name="expectedHash">Hash value of the original data.</param>
      <returns>True if package archive's hash matches the expected hash</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.AuthorSignPackageRequest.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2,NuGet.Common.HashAlgorithmName)">
      <summary>
            Instantiates a new instance of the <see cref="T:NuGet.Packaging.Signing.AuthorSignPackageRequest" /> class.
            </summary>
      <param name="certificate">The signing certificate.</param>
      <param name="hashAlgorithm">The signature and timestamp hash algorithm.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="certificate" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="hashAlgorithm" />
            is invalid.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.AuthorSignPackageRequest.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2,NuGet.Common.HashAlgorithmName,NuGet.Common.HashAlgorithmName)">
      <summary>
            Instantiates a new instance of the <see cref="T:NuGet.Packaging.Signing.AuthorSignPackageRequest" /> class.
            </summary>
      <param name="certificate">The signing certificate.</param>
      <param name="signatureHashAlgorithm">The signature hash algorithm.</param>
      <param name="timestampHashAlgorithm">The timestamp hash algorithm.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="certificate" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="signatureHashAlgorithm" />
            is invalid.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="timestampHashAlgorithm" />
            is invalid.</exception>
    </member>
    <member name="P:NuGet.Packaging.Signing.AuthorSignPackageRequest.SignatureType">
      <summary>
            Gets the signature type.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.ISignatureProvider">
      <summary>
            Creates Signatures that can be added to packages.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.ISignatureProvider.CreatePrimarySignatureAsync(NuGet.Packaging.Signing.SignPackageRequest,NuGet.Packaging.Signing.SignatureContent,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Create a signature.
            </summary>
      <param name="request">Signing request with all the information needed to create signature.</param>
      <param name="signatureContent">SignatureContent containing the Hash of the package and the signature version.</param>
      <param name="logger">Logger</param>
      <param name="token">Cancellation token.</param>
      <returns>A signature for the package.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.ISignatureProvider.CreateRepositoryCountersignatureAsync(NuGet.Packaging.Signing.RepositorySignPackageRequest,NuGet.Packaging.Signing.PrimarySignature,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Create a repository countersignature.
            </summary>
      <param name="request">Signing request with all the information needed to create signature.</param>
      <param name="primarySignature">Primary signature to be countersigned.</param>
      <param name="logger">Logger</param>
      <param name="token">Cancellation token.</param>
      <returns>A signature for the package.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.RepositorySignPackageRequest.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate2,NuGet.Common.HashAlgorithmName,NuGet.Common.HashAlgorithmName,System.Uri,System.Collections.Generic.IReadOnlyList{System.String})">
      <summary>
            Instantiates a new instance of the <see cref="T:NuGet.Packaging.Signing.RepositorySignPackageRequest" /> class.
            </summary>
      <param name="certificate">The signing certificate.</param>
      <param name="signatureHashAlgorithm">The signature hash algorithm.</param>
      <param name="timestampHashAlgorithm">The timestamp hash algorithm.</param>
      <param name="v3ServiceIndexUrl">The V3 service index URL.</param>
      <param name="packageOwners">A read-only list of package owners.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="certificate" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="signatureHashAlgorithm" />
            is invalid.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="timestampHashAlgorithm" />
            is invalid.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="v3ServiceIndexUrl" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="v3ServiceIndexUrl" />
            is neither absolute nor HTTPS.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageOwners" />
            is either empty or contains an invalid value.</exception>
    </member>
    <member name="P:NuGet.Packaging.Signing.RepositorySignPackageRequest.V3ServiceIndexUrl">
      <summary>
            Gets the repository V3 service index URL.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.RepositorySignPackageRequest.PackageOwners">
      <summary>
            Gets a read-only list of package owners.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.RepositorySignPackageRequest.SignatureType">
      <summary>
            Gets the signature type.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SigningOptions.#ctor(System.Lazy{System.IO.Stream},System.Lazy{System.IO.Stream},System.Boolean,NuGet.Packaging.Signing.ISignatureProvider,NuGet.Common.ILogger)">
      <summary>Instantiates a new <see cref="T:NuGet.Packaging.Signing.SigningOptions" /> object.</summary>
      <param name="inputPackageStream">A readable stream for the package that will be used as input for any
            signing operation.</param>
      <param name="outputPackageStream">A readable and writeable stream for the output package for any signing
            operation.</param>
      <param name="overwrite">A flag indicating if an existing signature should be overwritten.</param>
      <param name="signatureProvider">A provider to create a Signature that can be added to the package.</param>
      <param name="logger">A logger.</param>
      <remarks>Signing operations cannot be done in place; therefore, <paramref name="inputPackageStream" />
            and <paramref name="outputPackageStream" /> should be different streams.</remarks>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="inputPackageStream" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="outputPackageStream" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="signatureProvider" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="inputPackageStream" /> and
            <paramref name="outputPackageStream" /> are the same object.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.SigningOptions.CreateFromFilePaths(System.String,System.String,System.Boolean,NuGet.Packaging.Signing.ISignatureProvider,NuGet.Common.ILogger)">
      <summary>Creates a new <see cref="T:NuGet.Packaging.Signing.SigningOptions" /> object from file paths.</summary>
      <param name="inputPackageFilePath">The file path of the package that will be used as input for any
            signing operation.</param>
      <param name="outputPackageFilePath">The file path of the package that will be the output for any signing
            operation.</param>
      <param name="overwrite">A flag indicating if an existing signature should be overwritten.</param>
      <param name="signatureProvider">A provider to create a Signature that can be added to the package.</param>
      <param name="logger">A logger.</param>
      <remarks>Signing operations cannot be done in place; therefore, <paramref name="inputPackageFilePath" />
            and <paramref name="outputPackageFilePath" /> should be different file paths.</remarks>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="inputPackageFilePath" /> is <c>null</c>,
            an empty string, or equivalent to <paramref name="outputPackageFilePath" />.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="inputPackageFilePath" /> is <c>null</c>,
            an empty string, or equivalent to <paramref name="outputPackageFilePath" />.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="signatureProvider" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /> is <c>null</c>.</exception>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningOptions.InputPackageStream">
      <summary>
            Readable stream for the package that will be used as an input for any signing operation.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningOptions.OutputPackageStream">
      <summary>
            Readable and writeable stream for the output package for any signing operation.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningOptions.Overwrite">
      <summary>
            Switch used to indicate if an existing signature should be overwritten.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningOptions.SignatureProvider">
      <summary>
            Provider to create a Signature that can be added to the package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningOptions.Logger">
      <summary>
            Logger to be used to display the logs during the execution of signing actions.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.SignPackageRequest">
      <summary>
            Contains a request for generating package signature.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignPackageRequest.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignPackageRequest.SignatureHashAlgorithm">
      <summary>
            Hash algorithm used to create the package signature.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignPackageRequest.TimestampHashAlgorithm">
      <summary>
            Hash algorithm used to timestamp the signed package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignPackageRequest.Certificate">
      <summary>
            Certificate used to sign the package.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignPackageRequest.AdditionalCertificates">
      <summary>
            Gets a collection of additional certificates for building a chain for the signing certificate.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignPackageRequest.SignatureType">
      <summary>
            Gets the signature type.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignPackageRequest.PrivateKey">
      <summary>
            PrivateKey is only used in mssign command.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.X509SignatureProvider">
      <summary>
            Sign a manifest hash with an X509Certificate2.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.X509SignatureProvider.CreatePrimarySignatureAsync(NuGet.Packaging.Signing.SignPackageRequest,NuGet.Packaging.Signing.SignatureContent,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Sign the package stream hash with an X509Certificate2.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.X509SignatureProvider.CreateRepositoryCountersignatureAsync(NuGet.Packaging.Signing.RepositorySignPackageRequest,NuGet.Packaging.Signing.PrimarySignature,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Countersign the primary signature with a X509Certificate2.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.KeyPairFileReader.ReadSection">
      <summary>
            Read a section of key value pairs from the file.
            Throw for invalid formats.
            </summary>
      <remarks>Returns an empty set if the file has reached the end.</remarks>
    </member>
    <member name="M:NuGet.Packaging.Signing.KeyPairFileUtility.GetValueOrThrow(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
      <summary>
            Throw if the expected value does not exist.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.KeyPairFileWriter.WritePair(System.String,System.String)">
      <summary>
            Write key:value with EOL to the manifest stream.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.KeyPairFileWriter.WriteSectionBreak">
      <summary>
            Write an empty line.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.KeyPairFileWriter.WriteEOL">
      <summary>
            Write an end of line to the manifest writer.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.KeyPairFileWriter.FormatItem(System.String,System.String)">
      <summary>
            key:value
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.SignatureContent">
      <summary>
            SignedCms.ContentInfo.Content for the primary signature.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignatureContent.Save(System.IO.Stream)">
      <summary>
            Write the content to a stream.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignatureContent.GetBytes">
      <summary>
            Write the content to byte array.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignatureContent.Load(System.Byte[],NuGet.Packaging.Signing.SigningSpecifications)">
      <summary>
            Load from a byte array.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignatureContent.Load(System.IO.Stream,NuGet.Packaging.Signing.SigningSpecifications)">
      <summary>
            Load content from a stream.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureContent.HashAlgorithm">
      <summary>
            Hashing algorithm used.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureContent.HashValue">
      <summary>
            Base64 package stream hash.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.ISignedPackage">
      <summary>
            A package that can read and write signatures.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.ISignedPackageReader">
      <summary>
            A readonly package that can provide signatures and a sign manifest from a package.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.ISignedPackageReader.GetPrimarySignatureAsync(System.Threading.CancellationToken)">
      <summary>
            Get package signature.
            </summary>
      <remarks>Returns a null if the package is unsigned.</remarks>
    </member>
    <member name="M:NuGet.Packaging.Signing.ISignedPackageReader.IsSignedAsync(System.Threading.CancellationToken)">
      <summary>
            Check if a package contains signing information.
            </summary>
      <returns>True if the package is signed.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.ISignedPackageReader.GetArchiveHashAsync(NuGet.Common.HashAlgorithmName,System.Threading.CancellationToken)">
      <summary>
            Gets the hash of an archive to be embedded in the package signature.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.ISignedPackageReader.ValidateIntegrityAsync(NuGet.Packaging.Signing.SignatureContent,System.Threading.CancellationToken)">
      <summary>
            Checks for the integrity of a package
            </summary>
      <param name="signatureContent">SignatureContent with expected hash value and hash algorithm used</param>
      <returns>
      </returns>
    </member>
    <member name="T:NuGet.Packaging.Signing.ISignedPackageWriter">
      <summary>
            A writer that only allows editing for the package signature.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.ISignedPackageWriter.RemoveSignatureAsync(System.Threading.CancellationToken)">
      <summary>
            Removes a signature if it exists.
            </summary>
      <param name="token">CancellationToken</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.ISignedPackageWriter.AddSignatureAsync(System.IO.Stream,System.Threading.CancellationToken)">
      <summary>
            Adds a signature in the package.
            Throws exception if the package is already signed.
            </summary>
      <param name="packageSignatureProvider">A stream of the signature to be added to the package.</param>
      <param name="token">Cancellation token.</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.ISignedPackageWriter.IsZip64Async(System.Threading.CancellationToken)">
      <summary>
            Check if a package is Zip64.
            </summary>
      <param name="token">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.Boolean" />
            indicating whether the package is signed.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="token" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Packaging.Signing.SignedPackageArchive">
      <summary>
            A nupkg that supports both reading and writing signatures.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchive.AddSignatureAsync(System.IO.Stream,System.Threading.CancellationToken)">
      <summary>
            Adds a signature to a package if it is not already signed.
            </summary>
      <param name="signatureStream">Stream of the signature SignedCms object to be added to the package.</param>
      <param name="token">Cancellation Token.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageArchive.RemoveSignatureAsync(System.Threading.CancellationToken)">
      <summary>
            Remove a signature from the package, if it exists.
            </summary>
      <param name="token">Cancellation token.</param>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageArchive.ZipWriteStream">
      <summary>
            Stream underlying the ZipArchive. Used to do signature verification on a SignedPackageArchive.
            If this is null then we cannot perform signature verification.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureException.Results">
      <summary>
            Individual trust results.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.SignatureLog">
      <summary>
            Log message for signature verification.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignatureLog.AsRestoreLogMessage">
      <summary>
            Converts an SignatureLog into a Restore
            This is needed when an SignatureLog needs to be logged and loggers do not have visibility to SignatureLog.
            </summary>
      <returns>RestoreLogMessage equivalent to the SignatureLog.</returns>
    </member>
    <member name="T:NuGet.Packaging.Signing.AlgorithmIdentifier">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.CommitmentTypeIndication">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.CommitmentTypeQualifier">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.EssCertId">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.EssCertIdV2">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.GeneralName">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.IssuerSerial">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.NuGetPackageOwners">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.NuGetV3ServiceIndexUrl">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.PolicyInformation">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.PolicyQualifierInfo">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="M:NuGet.Packaging.Signing.PrimarySignature.Save(System.IO.Stream)">
      <summary>
            Save the signed cms signature to a stream.
            </summary>
      <param name="stream">
      </param>
    </member>
    <member name="M:NuGet.Packaging.Signing.PrimarySignature.GetBytes">
      <summary>
            Retrieve the bytes of the signed cms signature.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.PrimarySignature.Load(System.Security.Cryptography.Pkcs.SignedCms)">
      <summary>
            Create a signature based on a valid signed cms
            </summary>
      <param name="cms">signature data</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.PrimarySignature.Load(System.Byte[])">
      <summary>
            Create a signature based on a valid byte array to be decoded as a signed cms
            </summary>
      <param name="data">signature data</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.PrimarySignature.Load(System.IO.Stream)">
      <summary>
            Create a signature based on a valid byte stream to be decoded as a signed cms
            </summary>
      <param name="stream">signature data</param>
    </member>
    <member name="P:NuGet.Packaging.Signing.PrimarySignature.SignedCms">
      <summary>
            A SignedCms object holding the signature and SignerInfo.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.PrimarySignature.SignatureContent">
      <summary>
            Signature content.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.Signature">
      <summary>
            Package signature information.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.Signature.TryGetValidTimestamp(NuGet.Packaging.Signing.SignedPackageVerifierSettings,NuGet.Common.HashAlgorithmName,System.Collections.Generic.List{NuGet.Packaging.Signing.SignatureLog},NuGet.Packaging.Signing.SignatureVerificationStatusFlags@,NuGet.Packaging.Signing.Timestamp@)">
      <summary>
            Get a valid timestamp from the unsigned attributes if present
            </summary>
      <param name="settings">Specify what is allowed in the validation for timestamp</param>
      <param name="fingerprintAlgorithm">fingerprint algorithm for displaying timestamp's certificate information</param>
      <param name="issues">List of log messages.</param>
      <param name="verificationFlags">Flags that specify the status of the verification</param>
      <param name="validTimestamp">TTimestamp found in the signature that passes validation with the given <see cref="!:settings" /></param>
      <remarks>If <see cref="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowNoTimestamp" /> is set to true this method return true with a <see cref="!:validTimestamp" /> set to null.</remarks>
      <returns>true if a valid timestamp was found</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.Signature.Verify(NuGet.Packaging.Signing.Timestamp,NuGet.Packaging.Signing.SignatureVerifySettings,NuGet.Common.HashAlgorithmName,System.Security.Cryptography.X509Certificates.X509Certificate2Collection)">
      <summary>
            Verify if the signature object meets the specification trust and validity requirements.
            </summary>
      <param name="timestamp">Timestamp for this signature, if signature is not timestamped it can be null.</param>
      <param name="allowUntrusted">Setting that tells if a signature that does not meet any soft failure requirements can still be allowed. Used to know if warnings or errors should be logged for an issue.</param>
      <param name="allowUnknownRevocation">Setting that tells if unkown revocation is valid when building the chain.</param>
      <param name="allowUntrustedSelfSignedCertificate">Setting that tells if an untrusted self-signed certificate should be allowed as the signing certificate.</param>
      <param name="fingerprintAlgorithm">Algorithm used to calculate and display the certificate's fingerprint.</param>
      <param name="certificateExtraStore">Collection of certificates to help the chain building engine as an extra store.</param>
      <param name="issues">List of log messages.</param>
      <remarks>This is only public for ease of testing</remarks>
      <returns>Status of trust for signature.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.Signature.GetTimestamps(System.Security.Cryptography.Pkcs.SignerInfo,System.String)">
      <summary>
            Get timestamps from the signer info
            </summary>
      <param name="signer">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NuGet.Packaging.Signing.Signature.Type">
      <summary>
            Indicates if this is an author or repository signature.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.Signature.Timestamps">
      <summary>
            Signature timestamps.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.Signature.SignerInfo">
      <summary>
            SignerInfo for this signature.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.SignaturePlacement">
      <summary>
            Indicates signature placement.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignaturePlacement.PrimarySignature">
      <summary>
            The primary signature.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignaturePlacement.Countersignature">
      <summary>
            A countersignature on the primary signature.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignaturePlacement.Any">
      <summary>
            A primary signature or a countersignature.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.SignatureType">
      <summary>
            Indicates author or repository signing.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureType.Unknown">
      <summary>
            Default unknown value.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureType.Author">
      <summary>
            Signed by the author.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureType.Repository">
      <summary>
            Signed by the repository.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.SignatureVerifySettings">
      <summary>
            Settings to customize Signature.Verify behavior.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureVerifySettings.AllowIllegal">
      <summary>
            Allow packages with signatures that do not conform to the specification.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureVerifySettings.AllowUntrusted">
      <summary>
            Specifies that a signing certificate's chain that chains to an untrusted root is allowed
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureVerifySettings.AllowUnknownRevocation">
      <summary>
            Specifies that a signing certificate's chain with unknown revocation is allowed.
            If set to true, offline revocation is allowed.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureVerifySettings.ReportUnknownRevocation">
      <summary>
            Indicates if unknown revocation status should be reported.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureVerifySettings.Default">
      <summary>
            Get default settings values for relaxed verification on a signature
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.SigningCertificate">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.SigningCertificateV2">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.SigningSpecifications">
      <summary>
            Abstract class representing which paths may be used for signing in a package.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SigningSpecifications.V1">
      <summary>
            v1.0.0 signing settings.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SigningSpecifications.#ctor">
      <summary>
            Initialize a signing specification with a root folder.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningSpecifications.Version">
      <summary>
            Gets the signature format version.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningSpecifications.SignaturePath">
      <summary>
            Returns the path for the signature file.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningSpecifications.AllowedHashAlgorithms">
      <summary>
            Returns the set of allowed hash algorithms.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningSpecifications.AllowedHashAlgorithmOids">
      <summary>
            Returns the set of allowed hash algorithm Oids.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningSpecifications.AllowedSignatureAlgorithms">
      <summary>
            Returns the set of allowed signature algorithms.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningSpecifications.AllowedSignatureAlgorithmOids">
      <summary>
            Returns the set of allowed signature algorithm Oids.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningSpecifications.RSAPublicKeyMinLength">
      <summary>
            Returns minumum length required for RSA public keys.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningSpecifications.Encoding">
      <summary>
            Encoding used to generate the signature.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SigningSpecificationsV1._allowedHashAlgorithms">
      <summary>
            Allowed digest algorithms for signature and timestamp hashing.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SigningSpecificationsV1._allowedHashAlgorithmOids">
      <summary>
            Allowed digest algorithm Oids for signature and timestamp hashing.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SigningSpecificationsV1._allowedSignatureAlgorithms">
      <summary>
            Allowed signature algorithms.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SigningSpecificationsV1._allowedSignatureAlgorithmOids">
      <summary>
            Allowed signature algorithm Oids.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SigningSpecificationsV1.Version">
      <summary>
            Gets the signature format version.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.Accuracy">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.Extension">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.Extensions">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.MessageImprint">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.Rfc3161TimestampProvider">
      <summary>
            A provider for RFC 3161 timestamps
            https://tools.ietf.org/html/rfc3161
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.Rfc3161TimestampProvider.TimestampSignatureAsync(NuGet.Packaging.Signing.PrimarySignature,NuGet.Packaging.Signing.TimestampRequest,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Timestamps data present in the TimestampRequest.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.Rfc3161TimestampProvider.GetTimestamp(NuGet.Packaging.Signing.TimestampRequest,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Timestamps data present in the TimestampRequest.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.Rfc3161TimestampProvider.GetNameOrOidString(System.Security.Cryptography.Oid)">
      <summary>
            Returns the FriendlyName of an Oid. If FriendlyName is null, then the Oid string is returned.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.Rfc3161TimestampRequest">
      <summary>
            Class representing a Rfc3161TimestampRequest.
            This class should be removed once we can reference it throught the .NET Core framework.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.Rfc3161TimestampToken">
      <summary>
            Class representing a Rfc3161TimestampToken.
            This class should be removed once we can reference it throught the .NET Core framework.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo">
      <summary>
            Represents an RFC3161 TSTInfo.
            This class should be removed once we can reference it throught the .NET Core framework.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.Rfc3161TimestampTokenInfo.GetSerialNumber">
      <summary>
            Gets the serial number for the request in the big-endian byte order.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.Rfc3161TimestampUtils">
      <summary>
            Internally used by Rfc3161TimestampProvider.
            This class should be removed once we can reference it throught the .NET Core framework.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.Rfc3161TimestampVerificationUtility">
      <summary>
            Provides convinience method for verification of a RFC 3161 Timestamp.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.Rfc3161TimestampWin32">
      <summary>
            Internally used by Rfc3161TimestampProvider.
            This class should be removed once we can reference it throught the .NET Core framework.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.Timestamp.#ctor">
      <summary>
            Default constructor. Limits are set to current time.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.Timestamp.#ctor(System.Security.Cryptography.Pkcs.SignedCms)">
      <summary>
            SignedCms containing a time stamp authority token reponse
            </summary>
      <param name="timestampCms">SignedCms from Time Stamp Authority</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.Timestamp.Verify(NuGet.Packaging.Signing.Signature,NuGet.Packaging.Signing.SignedPackageVerifierSettings,NuGet.Common.HashAlgorithmName,System.Collections.Generic.List{NuGet.Packaging.Signing.SignatureLog})">
      <summary>
            Verify if the timestamp object meets the specification requirements.
            </summary>
      <param name="signature">Signature which this timestamp is for.</param>
      <param name="allowIgnoreTimestamp">Setting that tells if a timestamp can be ignored if it doesn't meet the requirements. Used to know if warnings or errors should be logged for an issue.</param>
      <param name="allowUnknownRevocation">Setting that tells if unkown revocation is valid when building the chain.</param>
      <param name="issues">List of log messages.</param>
      <returns>true if the timestamp meets the requierements, false otherwise.</returns>
    </member>
    <member name="P:NuGet.Packaging.Signing.Timestamp.UpperLimit">
      <summary>
            Upper limit of Timestamp.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.Timestamp.LowerLimit">
      <summary>
            Lower limit of Timestamp.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.Timestamp.GeneralizedTime">
      <summary>
            Time timestamp was created by the Time Stamp Authority.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.Timestamp.SignedCms">
      <summary>
            A SignedCms object holding the timestamp and SignerInfo.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.Timestamp.SignerInfo">
      <summary>
            SignerInfo for this timestamp.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.Timestamp.TstInfo">
      <summary>
            Timestamp token info for this timestamp.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.TimestampException">
      <summary>
            Exceptions that are generated while creating a package timestamp.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.TimestampRequest">
      <summary>
            Request for timestamping a signature
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.TimestampRequest.SigningSpecifications">
      <summary>
            Signing Specification for this timestamp request.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.TimestampRequest.HashedMessage">
      <summary>
            Gets the hashed message to be timestamped.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.TimestampRequest.HashAlgorithm">
      <summary>
            Gets the hash algorithm used to generate <see cref="P:NuGet.Packaging.Signing.TimestampRequest.HashedMessage" />.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.TimestampRequest.Target">
      <summary>
            Gets the target signature for the timestamp
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.TstInfo">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.CreateCommitmentTypeIndication(NuGet.Packaging.Signing.SignatureType)">
      <summary>
            Create a CommitmentTypeIndication attribute.
            https://tools.ietf.org/html/rfc5126.html#section-5.11.1
            </summary>
      <param name="type">The signature type.</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.GetSignatureType(System.Security.Cryptography.CryptographicAttributeObjectCollection)">
      <summary>
            Gets the signature type from one or more commitment-type-indication attributes.
            </summary>
      <param name="signedAttributes">A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> signed attributes collection.</param>
      <remarks>Unknown OIDs are ignored.</remarks>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="signedAttributes" /> is <c>null</c>.</exception>
      <exception cref="T:NuGet.Packaging.Signing.SignatureException">Thrown if one or more attributes are invalid.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.CreateNuGetV3ServiceIndexUrl(System.Uri)">
      <summary>
            Creates a nuget-v3-service-index-url attribute.
            </summary>
      <param name="v3ServiceIndexUrl">The V3 service index HTTPS URL.</param>
      <returns>An attribute object.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="v3ServiceIndexUrl" /> is null.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="v3ServiceIndexUrl" /> is neither absolute
            nor HTTPS.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.GetNuGetV3ServiceIndexUrl(System.Security.Cryptography.CryptographicAttributeObjectCollection)">
      <summary>
            Gets the V3 service index HTTPS URL from the nuget-v3-service-index-url attribute.
            </summary>
      <param name="signedAttributes">A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> signed attributes collection.</param>
      <returns>The V3 service index HTTPS URL.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="signedAttributes" />
            is <c>null</c>.</exception>
      <exception cref="T:NuGet.Packaging.Signing.SignatureException">Thrown if either exactly one attribute is not present or if
            the attribute does not contain exactly one attribute value.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.CreateNuGetPackageOwners(System.Collections.Generic.IReadOnlyList{System.String})">
      <summary>
            Creates a nuget-package-owners attribute.
            </summary>
      <param name="packageOwners">A read-only list of package owners.</param>
      <returns>An attribute object.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageOwners" /> is either <c>null</c>
            or empty or if any package owner name is invalid.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.GetNuGetPackageOwners(System.Security.Cryptography.CryptographicAttributeObjectCollection)">
      <summary>
            Gets a read-only list of package owners from an optional nuget-package-owners attribute.
            </summary>
      <param name="signedAttributes">A <see cref="T:System.Security.Cryptography.Pkcs.SignerInfo" /> signed attributes collection.</param>
      <returns>A read-only list of package owners or <c>null</c>.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="signedAttributes" /> is <c>null</c>.</exception>
      <exception cref="T:NuGet.Packaging.Signing.SignatureException">Thrown if the attribute does not contain exactly one
            attribute value.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.GetSignatureType(System.String)">
      <summary>
            Oid -&gt; SignatureType
            </summary>
      <param name="oid">The commitment-type-indication value.</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.GetSignatureTypeOid(NuGet.Packaging.Signing.SignatureType)">
      <summary>
            SignatureType -&gt; Oid
            </summary>
      <param name="signatureType">The signature type.</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.CreateSigningCertificateV2(System.Security.Cryptography.X509Certificates.X509Certificate2,NuGet.Common.HashAlgorithmName)">
      <summary>
            Create a signing-certificate-v2 from a certificate.
            </summary>
      <param name="certificate">The signing certificate.</param>
      <param name="hashAlgorithm">The hash algorithm for the signing-certificate-v2 attribute.</param>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.GetAttributeOrDefault(System.Security.Cryptography.CryptographicAttributeObjectCollection,System.String)">
      <summary>
            Returns the first attribute if the Oid is found.
            Returns null if the attribute is not found.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.ThrowInvalidAttributeException(System.Security.Cryptography.CryptographicAttributeObject)">
      <summary>
            Throw a signature exception due to an invalid attribute. This is used for unusual situations
            where the format is corrupt.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.ToList(System.Security.Cryptography.AsnEncodedDataCollection)">
      <summary>
            Enumerate AsnEncodedDataCollection
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.GetCommitmentTypeIndicationRawValues(System.Security.Cryptography.CryptographicAttributeObject)">
      <summary>
            Attribute -&gt; SignatureType values with no validation.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.GetAttribute(System.Security.Cryptography.CryptographicAttributeObjectCollection,System.String)">
      <summary>
            Gets 0 or 1 attribute with the specified OID.  If more than one attribute is found, an exception is thrown.
            </summary>
      <param name="attributes">A collection of attributes.</param>
      <param name="oid">The attribute OID to search for.</param>
      <returns>Either a <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> or <c>null</c>, if no attribute was found.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="attributes" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="oid" /> is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.Security.Cryptography.CryptographicException">Thrown if multiple attribute instances with the specified OID were found.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.AttributeUtility.GetAttributes(System.Security.Cryptography.CryptographicAttributeObjectCollection,System.String)">
      <summary>
            Gets 0 or 1 or many attributes with the specified OID.
            </summary>
      <param name="attributes">A collection of attributes.</param>
      <param name="oid">The attribute OID to search for.</param>
      <returns>Either a <see cref="T:System.Security.Cryptography.CryptographicAttributeObject" /> or <c>null</c>, if no attribute was found.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="attributes" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="oid" /> is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.CertificateChainUtility.GetCertificateChain(System.Security.Cryptography.X509Certificates.X509Certificate2,System.Security.Cryptography.X509Certificates.X509Certificate2Collection,NuGet.Common.ILogger,NuGet.Packaging.Signing.CertificateType)">
      <summary>
            Create a list of certificates in chain order with the leaf first and root last.
            </summary>
      <param name="certificate">The certificate for which a chain should be built.</param>
      <param name="extraStore">A certificate store containing additional certificates necessary
            for chain building.</param>
      <param name="logger">A logger.</param>
      <param name="certificateType">The certificate type.</param>
      <returns>A certificate chain.</returns>
      <remarks>This is intended to be used only during signing and timestamping operations,
            not verification.</remarks>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="certificate" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="extraStore" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="certificateType" /> is undefined.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.CertificateChainUtility.GetCertificateChain(System.Security.Cryptography.X509Certificates.X509Chain)">
      <summary>
            Create an ordered list of certificates. The leaf node is returned first.
            </summary>
      <param name="x509Chain">Certificate chain to be converted to list.</param>
      <remarks>This does not check validity or trust. It returns the chain as-is.</remarks>
    </member>
    <member name="M:NuGet.Packaging.Signing.CertificateUtility.X509Certificate2ToString(System.Security.Cryptography.X509Certificates.X509Certificate2,NuGet.Common.HashAlgorithmName)">
      <summary>
            Converts a X509Certificate2 to a human friendly string of the following format -
            Subject Name: CN=name
            SHA1 hash: hash
            Issued by: CN=issuer
            Valid from: issue date time to expiry date time in local time
            </summary>
      <param name="cert">X509Certificate2 to be converted to string.</param>
      <param name="fingerprintAlgorithm">Algorithm used to calculate certificate fingerprint</param>
      <returns>string representation of the X509Certificate2.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.CertificateUtility.X509Certificate2CollectionToString(System.Security.Cryptography.X509Certificates.X509Certificate2Collection,NuGet.Common.HashAlgorithmName)">
      <summary>
             Converts a X509Certificate2Collection to a human friendly string of the following format -
             Subject Name: CN=name
             SHA1 hash: hash
             Issued by: CN=issuer
             Valid from: issue date time to expiry date time in local time
            
             Subject Name: CN=name
             SHA1 hash: hash
             Issued by: CN=issuer
             Valid from: issue date time to expiry date time in local time
            
             ... N more.
             </summary>
      <param name="certCollection">X509Certificate2Collection to be converted to string.</param>
      <param name="fingerprintAlgorithm">Algorithm used to calculate certificate fingerprint</param>
      <returns>string representation of the X509Certificate2Collection.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.CertificateUtility.IsSignatureAlgorithmSupported(System.Security.Cryptography.X509Certificates.X509Certificate2)">
      <summary>
            Determines if a certificate's signature algorithm is supported.
            </summary>
      <param name="certificate">Certificate to validate</param>
      <returns>True if the certificate's signature algorithm is supported.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.CertificateUtility.IsCertificatePublicKeyValid(System.Security.Cryptography.X509Certificates.X509Certificate2)">
      <summary> 
            Validates the public key requirements for a certificate 
            </summary>
      <param name="certificate">Certificate to validate</param>
      <returns>True if the certificate's public key is valid within NuGet signature requirements</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.CertificateUtility.HasLifetimeSigningEku(System.Security.Cryptography.X509Certificates.X509Certificate2)">
      <summary>
            Validates if the certificate contains the lifetime signing EKU
            </summary>
      <param name="certificate">Certificate to validate</param>
      <returns>True if the certificate has the lifetime signing EKU</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.CertificateUtility.HasExtendedKeyUsage(System.Security.Cryptography.X509Certificates.X509Certificate2,System.String)">
      <summary>
            Checks if an X509Certificate2 contains a particular Extended Key Usage (EKU).
            </summary>
      <param name="certificate">X509Certificate2 to be checked.</param>
      <param name="ekuOid">String OID of the Extended Key Usage</param>
      <returns>A bool indicating if the X509Certificate2 contains specified OID in its Extended Key Usage.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.CertificateUtility.IsValidForPurposeFast(System.Security.Cryptography.X509Certificates.X509Certificate2,System.String)">
      <summary>
            Checks if an X509Certificate2 is valid for a particular purpose.
            </summary>
      <remarks>
            This must not be used in evaluation of a signed package.
            A more accurate test is building a chain with the specified EKU asserted in the application policy.
            </remarks>
      <param name="certificate">X509Certificate2 to be checked.</param>
      <param name="ekuOid">String OID of the Extended Key Usage</param>
      <returns>A bool indicating if the X509Certificate2 contains specified OID string in its Extended Key Usage.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.CertificateUtility.GetHash(System.Security.Cryptography.X509Certificates.X509Certificate2,NuGet.Common.HashAlgorithmName)">
      <summary>
            Gets the certificate fingerprint with the given hashing algorithm
            </summary>
      <param name="certificate">X509Certificate2 to be compute fingerprint</param>
      <param name="hashAlgorithm">Hash algorithm for fingerprint</param>
      <returns>A byte array representing the certificate hash.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.CertificateUtility.IsSelfIssued(System.Security.Cryptography.X509Certificates.X509Certificate2)">
      <summary>
            Determines if a certificate is self-issued.
            </summary>
      <remarks>Warning:  this method does not evaluate certificate trust, revocation status, or validity!
            This method attempts to build a chain for the provided certificate, and although revocation status
            checking is explicitly skipped, the underlying chain building engine may go online to fetch
            additional information (e.g.:  the issuer's certificate).  This method is not a guaranteed offline
            check.</remarks>
      <param name="certificate">The certificate to check.</param>
      <returns>
        <c>true</c> if the certificate is self-issued; otherwise, <c>false</c>.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="certificate" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Packaging.Signing.RepositorySignatureInfoUtility.GetSignedPackageVerifierSettings(NuGet.Packaging.RepositorySignatureInfo,NuGet.Packaging.Signing.SignedPackageVerifierSettings)">
      <summary>
            Gets SignedPackageVerifierSettings from a given RepositorySignatureInfo. 
            </summary>
      <param name="repoSignatureInfo">RepositorySignatureInfo to be used.</param>
      <param name="fallbackSettings">SignedPackageVerifierSettings to be used if RepositorySignatureInfo is unavailable.</param>
      <returns>SignedPackageVerifierSettings based on the RepositorySignatureInfo and SignedPackageVerifierSettings.</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignatureUtility.GetCertificateChain(NuGet.Packaging.Signing.PrimarySignature)">
      <summary>
            Gets certificates in the certificate chain for the primary signature.
            </summary>
      <param name="primarySignature">The primary signature.</param>
      <returns>A non-empty, read-only list of X.509 certificates ordered from signing certificate to root.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="primarySignature" /> is <c>null</c>.</exception>
      <remarks>
            WARNING:  This method does not perform revocation, trust, or certificate validity checking.
            </remarks>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignatureUtility.GetCertificateChain(NuGet.Packaging.Signing.PrimarySignature,NuGet.Packaging.Signing.RepositoryCountersignature)">
      <summary>
            Gets certificates in the certificate chain for the repository countersignature.
            </summary>
      <param name="primarySignature">The primary signature.</param>
      <param name="repositoryCountersignature">The repository countersignature.</param>
      <returns>A non-empty, read-only list of X.509 certificates ordered from signing certificate to root.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="primarySignature" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="repositoryCountersignature" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="repositoryCountersignature" /> is
            unrelated to <paramref name="primarySignature" />.</exception>
      <remarks>
            WARNING:  This method does not perform revocation, trust, or certificate validity checking.
            </remarks>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignatureUtility.GetTimestampCertificateChain(NuGet.Packaging.Signing.PrimarySignature)">
      <summary>
            Gets certificates in the certificate chain for a timestamp on the primary signature.
            </summary>
      <param name="primarySignature">The primary signature.</param>
      <returns>A non-empty, read-only list of X.509 certificates ordered from signing certificate to root.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="primarySignature" /> is <c>null</c>.</exception>
      <exception cref="T:NuGet.Packaging.Signing.SignatureException">Thrown if <paramref name="primarySignature" /> does not have a valid
            timestamp.</exception>
      <remarks>
            WARNING:  This method does not perform revocation, trust, or certificate validity checking.
            </remarks>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignatureUtility.GetTimestampCertificateChain(NuGet.Packaging.Signing.PrimarySignature,NuGet.Packaging.Signing.RepositoryCountersignature)">
      <summary>
            Gets certificates in the certificate chain for a timestamp on the repository countersignature.
            </summary>
      <param name="primarySignature">The primary signature.</param>
      <param name="repositoryCountersignature">The repository countersignature.</param>
      <returns>A non-empty, read-only list of X.509 certificates ordered from signing certificate to root.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="primarySignature" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="repositoryCountersignature" /> is <c>null</c>.</exception>
      <exception cref="T:NuGet.Packaging.Signing.SignatureException">Thrown if <paramref name="repositoryCountersignature" /> does not have a valid
            timestamp.</exception>
      <remarks>
            WARNING:  This method does not perform revocation, trust, or certificate validity checking.
            </remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.SigningUtility">
      <summary>
            Utility methods for signing.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SigningUtility.SignAsync(NuGet.Packaging.Signing.SigningOptions,NuGet.Packaging.Signing.SignPackageRequest,System.Threading.CancellationToken)">
      <summary>
            Add a signature to a package.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.X509ChainHolder">
      <summary>
            Creates and performs cleanup on an <see cref="T:System.Security.Cryptography.X509Certificates.X509Chain" /> instance.
            </summary>
      <remarks>
            Certificates held by individual X509ChainElement objects should be disposed immediately after use to minimize
            finalizer impact.
            </remarks>
    </member>
    <member name="M:NuGet.Packaging.Signing.AllowListVerificationProvider.VerifyAllowList(NuGet.Packaging.Signing.AllowListVerificationProvider.CertificateListVerificationRequest,System.Boolean)">
      <summary>
            Verify an allow list with a given request
            </summary>
      <param name="request">Information about the allow list verification to perform</param>
      <remarks>This method should never return a status unknown. Min is used to take the most severe status in <see cref="M:NuGet.Packaging.Signing.AllowListVerificationProvider.GetValidity(System.Collections.Generic.IEnumerable{NuGet.Packaging.Signing.PackageVerificationResult})" />
            therefore, if unknown is returned the verification process will return an unknown status for the whole operation</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.IPackageSignatureVerifier">
      <summary>
            Loads trust providers and verifies package signatures.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.IPackageSignatureVerifier.VerifySignaturesAsync(NuGet.Packaging.Signing.ISignedPackageReader,NuGet.Packaging.Signing.SignedPackageVerifierSettings,System.Threading.CancellationToken,System.Guid)">
      <summary>
            Verifies package signature.
            </summary>
      <param name="package">Package to be verified.</param>
      <param name="settings">SignedPackageVerifierSettings to be used when verifying the package.</param>
      <param name="token">Cancellation Token.</param>
      <param name="telemetryOperationId">Guid of the parent event.</param>
      <returns>VerifySignaturesResult containing the result of the verify operation.</returns>
    </member>
    <member name="T:NuGet.Packaging.Signing.ISignatureVerificationProvider">
      <summary>
            Providers signature trust information.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.ISignatureVerificationProvider.GetTrustResultAsync(NuGet.Packaging.Signing.ISignedPackageReader,NuGet.Packaging.Signing.PrimarySignature,NuGet.Packaging.Signing.SignedPackageVerifierSettings,System.Threading.CancellationToken)">
      <summary>
            Check if <paramref name="signature" /> is trusted by the provider.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.PackageSignatureVerifier.IsValid(System.Collections.Generic.IEnumerable{NuGet.Packaging.Signing.PackageVerificationResult},NuGet.Packaging.Signing.SignedPackageVerifierSettings)">
      <summary>
            True if a provider trusts the package signature.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.PackageVerificationResult">
      <summary>
            Represents a signature check result and any additional information
            needed to display to the user.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.PackageVerificationResult.#ctor(NuGet.Packaging.Signing.SignatureVerificationStatus,System.Collections.Generic.IEnumerable{NuGet.Packaging.Signing.SignatureLog})">
      <summary>
            PackageVerificationResult
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.PackageVerificationResult.Trust">
      <summary>
            Trust result
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.PackageVerificationResult.Issues">
      <summary>
            List of issues found in the verification process
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationBehavior.Never">
      <summary>
            Do not verify a signature.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationBehavior.IfExists">
      <summary>
            Verify a signature if and only if it exists.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationBehavior.IfExistsAndIsNecessary">
      <summary>
            Verify a signature if and only if it exists and is necessary
            (e.g.:  trust evaluation of another signature depends on it).
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationBehavior.Always">
      <summary>
            Verify a signature always.  If the signature is not present, it is an error.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.SignatureVerificationStatus">
      <summary>
            Represents the trust result of a signature.
            </summary>
      <remarks>The order of the elements on this enum is important.
            It should be ordered from most severe to valid.
            When a verification with multiple steps wants to be strict it should take the min
            out of each step as the status for the whole verification.</remarks>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatus.Unknown">
      <summary>
            Default unknown value.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatus.Suspect">
      <summary>
            Invalid package signature.
            </summary>
      <remarks>This could happen because the package integrity check fails or the certificate is revoked.</remarks>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatus.Disallowed">
      <summary>
            The signature is disallowed based on verification settings.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatus.Valid">
      <summary>
            Signature is valid for the verification step.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.NoErrors">
      <summary>
            There was no error found
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.NoSignature">
      <summary>
            A signature was not found
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.NoCertificate">
      <summary>
            Signer certificate was not found
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.MultipleSignatures">
      <summary>
            Multiple signatures were found
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.SignatureCheckFailed">
      <summary>
            A call to SignedCms.CheckSignature failed
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.SignatureAlgorithmUnsupported">
      <summary>
            Signature algorithm is not supported
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.CertificatePublicKeyInvalid">
      <summary>
            Public key does not conform with the requirements of the spec
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.HasLifetimeSigningEku">
      <summary>
            Signing certificate has lifetimeSigningEku
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.CertificateValidityInTheFuture">
      <summary>
            Signer certificate's validity is in the future
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.CertificateExpired">
      <summary>
            Signing certificate has expired
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.HashAlgorithmUnsupported">
      <summary>
            Hashing algorithm is not supported
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.MessageImprintUnsupportedAlgorithm">
      <summary>
            Message imprint uses a hash algorithm that is not supported
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.IntegrityCheckFailed">
      <summary>
            Integrity check of the signature failed
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.ChainBuildingFailure">
      <summary>
            Chain building failures.
            Some specific chain building failures (like revocation, revocation status unavailable, certificate expired, etc.)
            are not covered by this flag because they are covered specially by another status flag.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.UnknownRevocation">
      <summary>
            Revocation information was unavailable or was offline for the signer certificate
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.CertificateRevoked">
      <summary>
            Signing certificate was revoked
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.UntrustedRoot">
      <summary>
            Signing certificate chains to a certificate untrusted by the computer performing the verification
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.GeneralizedTimeOutsideValidity">
      <summary>
            The Timestamp's generalized time was outside certificate's validity period
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.NoValidTimestamp">
      <summary>
            A valid timestamp was not found.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.MultipleTimestamps">
      <summary>
            Multiple timestamps were found.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.Suspect">
      <summary>
            Flags which indicate that the signed package is suspect.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.Illegal">
      <summary>
            Flags which indicate that the signed package is illegal.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.SignatureVerificationStatusFlags.Untrusted">
      <summary>
            Flags which indicate that the signed package is untrusted.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureVerificationSummary.SignatureType">
      <summary>
            Type of the signature that was verified
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureVerificationSummary.Status">
      <summary>
            Status of the verification
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureVerificationSummary.Flags">
      <summary>
            Reasons for the status.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureVerificationSummary.Timestamp">
      <summary>
            Timestamp used to validate certificate.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignatureVerificationSummary.ExpirationTime">
      <summary>
            Expiration Date and Time for signature
            </summary>
      <remarks>This field will only be set if the certificate is expired.</remarks>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerificationResult.Signature">
      <summary>
            Signature
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.SignedPackageVerifierSettings">
      <summary>
            Feed settings used to verify packages.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageVerifierSettings.GetDefault(System.Collections.Generic.IReadOnlyList{NuGet.Packaging.Signing.VerificationAllowListEntry},System.Collections.Generic.IReadOnlyList{NuGet.Packaging.Signing.VerificationAllowListEntry})">
      <summary>
            Default settings.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageVerifierSettings.GetAcceptModeDefaultPolicy(System.Collections.Generic.IReadOnlyList{NuGet.Packaging.Signing.VerificationAllowListEntry},System.Collections.Generic.IReadOnlyList{NuGet.Packaging.Signing.VerificationAllowListEntry})">
      <summary>
            The aceept mode policy.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageVerifierSettings.GetRequireModeDefaultPolicy(System.Collections.Generic.IReadOnlyList{NuGet.Packaging.Signing.VerificationAllowListEntry},System.Collections.Generic.IReadOnlyList{NuGet.Packaging.Signing.VerificationAllowListEntry})">
      <summary>
            The require mode policy.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.SignedPackageVerifierSettings.GetVerifyCommandDefaultPolicy(System.Collections.Generic.IReadOnlyList{NuGet.Packaging.Signing.VerificationAllowListEntry},System.Collections.Generic.IReadOnlyList{NuGet.Packaging.Signing.VerificationAllowListEntry})">
      <summary>
            Default policy for nuget.exe verify --signatures command.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowUnsigned">
      <summary>
            Allow packages that do not contain signatures.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowIllegal">
      <summary>
            Allow packages with signatures that do not conform to the specification.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowUntrusted">
      <summary>
            Allow packages that have not been explicitly trusted by the consumer.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowIgnoreTimestamp">
      <summary>
            Allow ignoring timestamp.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowMultipleTimestamps">
      <summary>
            Allow more than one timestamp.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowNoTimestamp">
      <summary>
            Allow no timestamp.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowUnknownRevocation">
      <summary>
            Treat unknown revocation status as a warning instead of an error during verification.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.ReportUnknownRevocation">
      <summary>
            Report unknown revocation status.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowNoRepositoryCertificateList">
      <summary>
            Allow an empty or null RepositoryCertificateList.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.AllowNoClientCertificateList">
      <summary>
            Allow an empty or null ClientCertificateList.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.VerificationTarget">
      <summary>
            Gets the verification target(s).
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.SignaturePlacement">
      <summary>
            Gets the placement of verification target(s).
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.RepositoryCountersignatureVerificationBehavior">
      <summary>
            Gets the repository countersignature verification behavior.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.RepositoryCertificateList">
      <summary>
            Allowlist of repository certificates hashes.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.SignedPackageVerifierSettings.ClientCertificateList">
      <summary>
            Allowlist of client side certificate hashes.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.VerificationAllowListEntry.Target">
      <summary>
            Target type of signature to verify.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.VerificationAllowListEntry.Placement">
      <summary>
            Signature placement to verify.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.VerificationTarget">
      <summary>
            Indicates the type of signature a verification is targeting
            </summary>
      <remarks>This target makes no assumption about the placement of the signature.
            It only refers to author or repository type of signature.
            If a specific placement is needed use the <see cref="T:NuGet.Packaging.Signing.SignaturePlacement" /> enum.</remarks>
    </member>
    <member name="F:NuGet.Packaging.Signing.VerificationTarget.Unknown">
      <summary>
            Target unknown primary signatures.
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.VerificationTarget.Author">
      <summary>
            Target author signatures
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.VerificationTarget.Repository">
      <summary>
            Target repository signatures
            </summary>
    </member>
    <member name="F:NuGet.Packaging.Signing.VerificationTarget.All">
      <summary>
            Target all available signatures.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.VerifySignaturesResult">
      <summary>
            Collection of signature verification results.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.VerifySignaturesResult.Valid">
      <summary>
            True if signature is valid.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.VerifySignaturesResult.Signed">
      <summary>
            True if the package is signed.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.VerifySignaturesResult.Results">
      <summary>
            Individual trust results.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.DerEncoding.DerEncoder">
      <summary>
            Writes data encoded via the Distinguished Encoding Rules for Abstract
            Syntax Notation 1 (ASN.1) data.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeBoolean(System.Boolean)">
      <summary>
            Encode the segments { tag, length, value } of a boolean.
            </summary>
      <param name="value">The boolean to encode</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeUnsignedInteger(System.UInt32)">
      <summary>
            Encode the segments { tag, length, value } of an unsigned integer.
            </summary>
      <param name="value">The value to encode.</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeUnsignedInteger(System.Byte[])">
      <summary>
            Encode the segments { tag, length, value } of an unsigned integer.
            </summary>
      <param name="bigEndianBytes">The value to encode, in big integer representation.</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeUnsignedInteger(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Encode the segments { tag, length, value } of an unsigned integer represented within a bounded array.
            </summary>
      <param name="bigEndianBytes">The value to encode, in big integer representation.</param>
      <param name="offset">The offset into bigEndianBytes to read</param>
      <param name="count">The count of bytes to read, must be greater than 0</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeBitString(System.Byte[][][])">
      <summary>
            Encode the segments { tag, length, value } of a BIT STRING which is wrapped over
            other DER-encoded data.
            </summary>
      <param name="childSegments">
      </param>
      <remarks>
            Despite containing other DER-encoded data this does not get the constructed bit,
            because it doesn't when encoding public keys in SubjectPublicKeyInfo</remarks>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeBitString(System.Byte[])">
      <summary>
            Encode the segments { tag, length, value } of a bit string where all bits are significant.
            </summary>
      <param name="data">The data to encode</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeBitString(System.Int32,System.Byte[])">
      <summary>
            Encode the segments { tag, length, value } of a bit string where the least significant
            <paramref name="unusedBits" /> of the last byte are padding.
            </summary>
      <param name="unusedBits">The number of padding bits (0-7) in the last byte</param>
      <param name="data">The data to encode</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeNamedBitList(System.Byte[],System.Int32)">
      <summary>
            Encode the segments { tag, length, value } of a bit string value based upon a NamedBitList.
            ((<paramref name="bigEndianBytes" />[0] &gt;&gt; 7) &amp; 1) is considered the "leading" bit, proceeding
            through the array for up to <paramref name="namedBitsCount" />.
            </summary>
      <param name="bigEndianBytes">
            The data in big endian order, the most significant bit of byte 0 is the leading bit
            (corresponds to the named value for "bit 0"). Any bits beyond <paramref name="namedBitsCount" />
            are ignored, and any missing bits are assumed to be unset.
            </param>
      <param name="namedBitsCount">
            The total number of named bits.  Since the bits are numbered with a zero index, this should be
            one higher than the largest defined bit. (namedBitsCount=10 covers bits 0-9)
            </param>
      <returns>
            A triplet of { tag }, { length }, { data }.  All trailing unset named bits are removed. 
            </returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeOctetString(System.Byte[])">
      <summary>
            Encode the segments { tag, length, value } of an octet string (byte array).
            </summary>
      <param name="data">The data to encode</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.EncodeOid(System.String)">
      <summary>
            Encode an object identifier (Oid).
            </summary>
      <returns>The encoded OID</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeOid(System.Security.Cryptography.Oid)">
      <summary>
            Encode the segments { tag, length, value } of an object identifier (Oid).
            </summary>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeOid(System.String)">
      <summary>
            Encode the segments { tag, length, value } of an object identifier (Oid).
            </summary>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeUtf8String(System.Char[])">
      <summary>
            Encode a character string as a UTF8String value.
            </summary>
      <param name="chars">The characters to be encoded.</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeUtf8String(System.Char[],System.Int32,System.Int32)">
      <summary>
            Encode a substring as a UTF8String value.
            </summary>
      <param name="chars">The characters whose substring is to be encoded.</param>
      <param name="offset">The character offset into <paramref name="chars" /> at which to start.</param>
      <param name="count">The total number of characters from <paramref name="chars" /> to read.</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.ConstructSegmentedSequence(System.Byte[][][])">
      <summary>
            Make a constructed SEQUENCE of the byte-triplets of the contents, but leave
            the value in a segmented form (to be included in a larger SEQUENCE).
            </summary>
      <param name="items">Series of Tag-Length-Value triplets to build into one sequence.</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.ConstructSegmentedContextSpecificValue(System.Int32,System.Byte[][][])">
      <summary>
            Make a context-specific tagged value which is constructed of other DER encoded values.
            Logically the same as a SEQUENCE, but providing context as to data interpretation (and usually
            indicates an optional element adjacent to another SEQUENCE).
            </summary>
      <param name="contextId">The value's context ID</param>
      <param name="items">Series of Tag-Length-Value triplets to build into one sequence.</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.ConstructSegmentedSet(System.Byte[][][])">
      <summary>
            Make a constructed SET of the byte-triplets of the contents, but leave
            the value in a segmented form (to be included in a larger SEQUENCE).
            </summary>
      <param name="items">Series of Tag-Length-Value triplets to build into one set.</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.ConstructSegmentedPresortedSet(System.Byte[][][])">
      <summary>
            Make a constructed SET of the byte-triplets of the contents, but leave
            the value in a segmented form (to be included in a larger SEQUENCE).
            
            This method assumes that the data is presorted, and writes it as-is.
            </summary>
      <param name="items">Series of Tag-Length-Value triplets to build into one set.</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.IsValidPrintableString(System.Char[])">
      <summary>
            Test to see if the input characters contains only characters permitted by the ASN.1
            PrintableString restricted character set.
            </summary>
      <param name="chars">The characters to test.</param>
      <returns>
        <c>true</c> if all of the characters in <paramref name="chars" /> are valid PrintableString characters,
            <c>false</c> otherwise.
            </returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.IsValidPrintableString(System.Char[],System.Int32,System.Int32)">
      <summary>
            Test to see if the input substring contains only characters permitted by the ASN.1
            PrintableString restricted character set.
            </summary>
      <param name="chars">The character string to test.</param>
      <param name="offset">The starting character position within <paramref name="chars" />.</param>
      <param name="count">The number of characters from <paramref name="chars" /> to read.</param>
      <returns>
        <c>true</c> if all of the indexed characters in <paramref name="chars" /> are valid PrintableString
            characters, <c>false</c> otherwise.
            </returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodePrintableString(System.Char[])">
      <summary>
            Encode a character string as a PrintableString value.
            </summary>
      <param name="chars">The characters to be encoded.</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodePrintableString(System.Char[],System.Int32,System.Int32)">
      <summary>
            Encode a substring as a PrintableString value.
            </summary>
      <param name="chars">The character string whose substring is to be encoded.</param>
      <param name="offset">The character offset into <paramref name="chars" /> at which to start.</param>
      <param name="count">The total number of characters from <paramref name="chars" /> to read.</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeIA5String(System.Char[])">
      <summary>
            Encode a string of characters as a IA5String value.
            </summary>
      <param name="chars">The characters to be encoded.</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.SegmentedEncodeIA5String(System.Char[],System.Int32,System.Int32)">
      <summary>
            Encode a substring as a IA5String value.
            </summary>
      <param name="chars">The characters whose substring is to be encoded.</param>
      <param name="offset">The character offset into <paramref name="chars" /> at which to start.</param>
      <param name="count">The total number of characters from <paramref name="chars" /> to read.</param>
      <returns>The encoded segments { tag, length, value }</returns>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.ConstructSequence(System.Byte[][][])">
      <summary>
            Make a constructed SEQUENCE of the byte-triplets of the contents.
            Each byte[][] should be a byte[][3] of {tag (1 byte), length (1-5 bytes), payload (variable)}.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerEncoder.ConstructSequence(System.Collections.Generic.IEnumerable{System.Byte[][]})">
      <summary>
            Make a constructed SEQUENCE of the byte-triplets of the contents.
            Each byte[][] should be a byte[][3] of {tag (1 byte), length (1-5 bytes), payload (variable)}.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.DerEncoding.DerGeneralizedTime">
      <remarks>This is public only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Packaging.Signing.DerEncoding.DerSequenceReader">
      <summary>
            Reads data encoded via the Distinguished Encoding Rules for Abstract
            Syntax Notation 1 (ASN.1) data.
            </summary>
    </member>
    <member name="M:NuGet.Packaging.Signing.DerEncoding.DerSequenceReader.ReadNextEncodedValue">
      <summary>
            Returns the next value encoded (this includes tag and length)
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Signing.DerEncoding.SR">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.DerEncoding.SR.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.DerEncoding.SR.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.DerEncoding.SR.Argument_InvalidOidValue">
      <summary>
              Looks up a localized string similar to The OID value was invalid..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.DerEncoding.SR.Cryptography_Der_Invalid_Encoding">
      <summary>
              Looks up a localized string similar to ASN1 corrupted data..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Signing.DerEncoding.SR.Cryptography_Invalid_IA5String">
      <summary>
              Looks up a localized string similar to The string contains a character not in the 7 bit ASCII character set..
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Rules.AnalysisResources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.AssemblyDirectlyUnderLibWarning">
      <summary>
              Looks up a localized string similar to The assembly '{0}' is placed directly under 'lib' folder. It is recommended that assemblies be placed inside a framework-specific folder. Move it into a framework-specific folder..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.AssemblyOutsideLibWarning">
      <summary>
              Looks up a localized string similar to The assembly '{0}' is not inside the 'lib' folder and hence it won't be added as a reference when the package is installed into a project. Move it into the 'lib' folder if it needs to be referenced..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.DefaultSpecValueWarning">
      <summary>
              Looks up a localized string similar to The value "{0}" for {1} is a sample value and should be removed. Replace it with an appropriate value or remove it and rebuild your package..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.FilePathTooLongWarning">
      <summary>
              Looks up a localized string similar to The file '{0}' path, name, or both are too long. Your package might not work without long file path support. Please shorten the file path or file name..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.InvalidFrameworkWarning">
      <summary>
              Looks up a localized string similar to The folder '{0}' under 'lib' is not recognized as a valid framework name or a supported culture identifier. Rename it to a valid framework name or culture identifier..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.InvalidPrereleaseDependencyWarning">
      <summary>
              Looks up a localized string similar to A stable release of a package should not have a prerelease dependency. Either modify the version spec of dependency "{0}" or update the version field in the nuspec..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.LegacyVersionWarning">
      <summary>
              Looks up a localized string similar to The package version '{0}' uses SemVer 2.0.0 or components of SemVer 1.0.0 that are not supported on legacy clients. Change the package version to a SemVer 1.0.0 string. If the version contains a release label it must start with a letter. This message can be ignored if the package is not intended for older clients..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.Migrator_AssemblyDirectlyUnderLibWarning">
      <summary>
              Looks up a localized string similar to The assembly 'lib\{0}' will be ignored when the package is installed after the migration..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.Migrator_PackageHasContentFolder">
      <summary>
              Looks up a localized string similar to 'content' assets will not be available when the package is installed after the migration..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.Migrator_PackageHasInstallScript">
      <summary>
              Looks up a localized string similar to install.ps1 script will be ignored when the package is installed after the migration..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.Migrator_XdtTransformInPackage">
      <summary>
              Looks up a localized string similar to XDT transform file '{0}' will not be applied when the package is installed after the migration..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.MisplacedInitScriptWarning">
      <summary>
              Looks up a localized string similar to The file '{0}' will be ignored by NuGet because it is not directly under 'tools' folder. Place the file directly under 'tools' folder..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.MisplacedTransformFileWarning">
      <summary>
              Looks up a localized string similar to The transform file '{0}' is outside the 'content' folder and hence will not be transformed during installation of this package. Move it into the 'content' folder..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.PlaceholderFileInPackageWarning">
      <summary>
              Looks up a localized string similar to An empty folder placeholder file '{0}' is in a non-empty folder and should be removed..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.ScriptOutsideToolsWarning">
      <summary>
              Looks up a localized string similar to The script file '{0}' is outside the 'tools' folder and hence will not be executed during installation of this package. Move it into the 'tools' folder..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.UnrecognizedScriptWarning">
      <summary>
              Looks up a localized string similar to The script file '{0}' is not recognized by NuGet and hence will not be executed during installation of this package. Rename it to install.ps1, uninstall.ps1 or init.ps1 and place it directly under 'tools'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.UnspecifiedDependencyVersionWarning">
      <summary>
              Looks up a localized string similar to The version of dependency '{0}' is not specified. Specify the version of dependency and rebuild your package..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.AnalysisResources.WinRTObsoleteWarning">
      <summary>
              Looks up a localized string similar to The file at '{0}' uses the obsolete 'WinRT' as the framework folder. Replace 'WinRT' or 'WinRT45' with 'NetCore45'..
            </summary>
    </member>
    <member name="T:NuGet.Packaging.Rules.LegacyVersionRule">
      <summary>
            Warn if the version is not parsable by older nuget clients.
            </summary>
      <remarks>This rule should be removed once more users move to SemVer 2.0.0 capable clients.</remarks>
    </member>
    <member name="P:NuGet.Packaging.Rules.MisplacedAssemblyOutsideLibRule.ValidFolders">
      <summary>
            Folders that are expected to have .dll and .winmd files
            </summary>
    </member>
    <member name="P:NuGet.Packaging.Rules.MisplacedAssemblyUnderLibRule.ValidFolders">
      <summary>
            Folders that are expected to have .dll and .winmd files
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageExtraction.PackageExtractionBehavior.XmlDocFileSaveMode">
      <summary>
            Gets or sets the <see cref="!:PackageExtraction.XmlDocFileSaveMode" />.
            </summary>
    </member>
    <member name="T:NuGet.Packaging.PackageCreation.Resources.NuGetResources">
      <summary>
               A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.ResourceManager">
      <summary>
               Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Culture">
      <summary>
               Overrides the current thread's CurrentUICulture property for all
               resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.CannotCreateEmptyPackage">
      <summary>
               Looks up a localized string similar to Cannot create a package that has no dependencies nor content..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.DependencyHasInvalidVersion">
      <summary>
               Looks up a localized string similar to Dependency '{0}' has an invalid version..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.DuplicateDependenciesDefined">
      <summary>
               Looks up a localized string similar to '{0}' already has a dependency defined for '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.IncompatibleSchema">
      <summary>
               Looks up a localized string similar to The schema version of '{0}' is incompatible with version {1} of NuGet. Please upgrade NuGet to the latest version from http://go.microsoft.com/fwlink/?LinkId=213942..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.InvalidPackageId">
      <summary>
               Looks up a localized string similar to The package ID '{0}' contains invalid characters. Examples of valid package IDs include 'MyPackage' and 'MyPackage.Sample'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_DependenciesHasMixedElements">
      <summary>
               Looks up a localized string similar to &lt;dependencies&gt; element must not contain both &lt;group&gt; and &lt;dependency&gt; child elements..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_ExcludeContainsInvalidCharacters">
      <summary>
               Looks up a localized string similar to Exclude path '{0}' contains invalid characters..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_IdMaxLengthExceeded">
      <summary>
               Looks up a localized string similar to Id must not exceed 100 characters..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_InvalidMinClientVersion">
      <summary>
               Looks up a localized string similar to The 'minClientVersion' attribute in the package manifest has invalid value. It must be a valid version string..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_InvalidReference">
      <summary>
               Looks up a localized string similar to Invalid assembly reference '{0}'. Ensure that a file named '{0}' exists in the lib directory..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_InvalidReferenceFile">
      <summary>
               Looks up a localized string similar to Assembly reference '{0}' contains invalid characters..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_ReferencesHasMixedElements">
      <summary>
               Looks up a localized string similar to &lt;references&gt; element must not contain both &lt;group&gt; and &lt;reference&gt; child elements..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_ReferencesIsEmpty">
      <summary>
               Looks up a localized string similar to The element package\metadata\references\group must contain at least one &lt;reference&gt; child element..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_RequiredElementMissing">
      <summary>
               Looks up a localized string similar to The required element '{0}' is missing from the manifest..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_RequiredMetadataMissing">
      <summary>
               Looks up a localized string similar to {0} is required..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_RequireLicenseAcceptanceRequiresLicenseUrl">
      <summary>
               Looks up a localized string similar to Enabling license acceptance requires a license url..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_SourceContainsInvalidCharacters">
      <summary>
               Looks up a localized string similar to Source path '{0}' contains invalid characters..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_TargetContainsInvalidCharacters">
      <summary>
               Looks up a localized string similar to Target path '{0}' contains invalid characters..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.Manifest_UriCannotBeEmpty">
      <summary>
               Looks up a localized string similar to {0} cannot be empty..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.PackageAuthoring_FileNotFound">
      <summary>
               Looks up a localized string similar to File not found: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Packaging.PackageCreation.Resources.NuGetResources.UnknownSchemaVersion">
      <summary>
               Looks up a localized string similar to Unknown schema version '{0}'..
            </summary>
    </member>
    <member name="M:NuGet.ContentModel.ContentItemCollection.IsValidAsset(System.String)">
      <summary>
            False if the path would not match any patterns.
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.ContentItemCollection.HasContract">
      <summary>
            True if lib/contract exists
            </summary>
    </member>
    <member name="T:NuGet.ContentModel.ContentPropertyDefinition">
      <summary>
            Defines a property that can be used in Content Model query patterns
            <seealso cref="T:NuGet.ContentModel.PatternSet" /></summary>
    </member>
    <member name="P:NuGet.ContentModel.ContentPropertyDefinition.CompareTest">
      <summary>
            Find the nearest compatible candidate.
            </summary>
    </member>
    <member name="T:NuGet.ContentModel.PatternSet">
      <summary>
            A set of patterns that can be used to query a set of file paths for items matching a provided criteria.
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.PatternSet.GroupPatterns">
      <summary>
            Patterns used to select a group of items that matches the criteria
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.PatternSet.GroupExpressions">
      <summary>
            Pattern expressions.
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.PatternSet.PathPatterns">
      <summary>
            Patterns used to select individual items that match the criteria
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.PatternSet.PathExpressions">
      <summary>
            Path expressions.
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.PatternSet.PropertyDefinitions">
      <summary>
            Property definitions used for matching patterns
            </summary>
    </member>
    <member name="T:NuGet.ContentModel.PatternDefinition">
      <summary>
            A pattern that can be used to match file paths given a provided criteria.
            </summary>
      <remarks>
            The pattern is defined as a sequence of literal path strings that must match exactly and property
            references,
            wrapped in {} characters, which are tested for compatibility with the consumer-provided criteria.
            <seealso cref="T:NuGet.ContentModel.ContentPropertyDefinition" /></remarks>
    </member>
    <member name="P:NuGet.ContentModel.PatternDefinition.Table">
      <summary>
            Replacement token table.
            </summary>
    </member>
    <member name="T:NuGet.ContentModel.PatternTable">
      <summary>
            Replacement token table organized by property.
            </summary>
    </member>
    <member name="M:NuGet.ContentModel.PatternTable.TryLookup(System.String,System.String,System.Object@)">
      <summary>
            Lookup a token and get the replacement if it exists.
            </summary>
      <param name="propertyName">Property moniker</param>
      <param name="name">Token name</param>
      <param name="value">Replacement value</param>
    </member>
    <member name="P:NuGet.ContentModel.PatternTableEntry.PropertyName">
      <summary>
            PropertyName moniker
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.PatternTableEntry.Name">
      <summary>
            Item name
            </summary>
    </member>
    <member name="P:NuGet.ContentModel.PatternTableEntry.Value">
      <summary>
            Item replacement value
            </summary>
    </member>
    <member name="T:NuGet.Client.AnyFramework">
      <summary>
            An internal NuGetFramework marker for ManagedCodeConventions.
            Most conventions disallow the string 'any' as a txm, so to allow
            it for conventions with no txm in the path we use this special type.
            </summary>
    </member>
    <member name="T:NuGet.Client.ManagedCodeConventions">
      <summary>
            Defines all the package conventions used by Managed Code packages
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.AnyTargettedFile">
      <summary>
            Pattern used to locate all files targetted at a specific runtime and/or framework
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.RuntimeAssemblies">
      <summary>
            Pattern used to locate all files designed for loading as managed code assemblies at run-time
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.CompileRefAssemblies">
      <summary>
            Pattern used to locate ref assemblies for compile.
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.CompileLibAssemblies">
      <summary>
            Pattern used to locate lib assemblies for compile.
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.NativeLibraries">
      <summary>
            Pattern used to locate all files designed for loading as native code libraries at run-time
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.ResourceAssemblies">
      <summary>
            Pattern used to locate all files designed for loading as managed code resource assemblies at run-time
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.MSBuildFiles">
      <summary>
            Pattern used to identify MSBuild targets and props files
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.MSBuildMultiTargetingFiles">
      <summary>
            Pattern used to identify MSBuild global targets and props files
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.ContentFiles">
      <summary>
            Pattern used to identify content files
            </summary>
    </member>
    <member name="P:NuGet.Client.ManagedCodeConventions.ManagedCodePatterns.ToolsAssemblies">
      <summary>
            Pattern used to identify Tools assets for global tools
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.ProjectModel835040.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.ProjectModel835040.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.ProjectModel835040.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.ProjectModel835040.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.ProjectModel835040.HashCodeCombiner.GetHashCode``2(``0,``1)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.ProjectModel835040.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.ProjectModel835040.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
      <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
    </member>
    <member name="M:NuGet.Shared.NuGet.ProjectModel835040.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.CircularMemoryStream">
      <summary>
            A circular memory stream backed by a fixed-size byte buffer.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.DependencyGraphSpec.WithProjectClosure(System.String)">
      <summary>
            Retrieve a DependencyGraphSpec with the project closure.
            </summary>
      <param name="projectUniqueName">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.ProjectModel.DependencyGraphSpec.GetClosure(System.String)">
      <summary>
            Retrieve the full project closure including the root project itself.
            </summary>
      <remarks>Results are not sorted in any form.</remarks>
    </member>
    <member name="M:NuGet.ProjectModel.DependencyGraphSpec.SortPackagesByDependencyOrder(System.Collections.Generic.IEnumerable{NuGet.ProjectModel.PackageSpec})">
      <summary>
            Order dependencies by children first.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.DependencyGraphSpec.GetPackageSpecId(NuGet.ProjectModel.PackageSpec)">
      <summary>
            PackageSpec -&gt; id
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.DependencyGraphSpec.GetPackageSpecDependencyIds(NuGet.ProjectModel.PackageSpec)">
      <summary>
            PackageSpec -&gt; Project dependency ids
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.DependencyGraphSpec.Restore">
      <summary>
            Projects to restore.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.DependencyGraphSpec.Projects">
      <summary>
            All project specs.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.DependencyGraphSpec.Json">
      <summary>
            File json.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.ExternalProjectReference">
      <summary>
            Represents a reference to a project produced by an external build system, such as msbuild.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.ExternalProjectReference.#ctor(System.String,NuGet.ProjectModel.PackageSpec,System.String,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Represents a reference to a project produced by an external build system, such as msbuild.
            </summary>
      <param name="uniqueName">unique project name or full path</param>
      <param name="packageSpec">project.json package spec.</param>
      <param name="msbuildProjectPath">project file if one exists</param>
      <param name="projectReferences">unique names of the referenced projects</param>
    </member>
    <member name="M:NuGet.ProjectModel.ExternalProjectReference.#ctor(System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Represents a reference to a project produced by an external build system, such as msbuild.
            </summary>
      <param name="uniqueName">unique project name or full path</param>
      <param name="packageSpecPath">project.json file path or null if none exists</param>
      <param name="msbuildProjectPath">project file if one exists</param>
      <param name="projectReferences">unique names of the referenced projects</param>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.UniqueName">
      <summary>
            Unique name of the external project
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.PackageSpec">
      <summary>
            The path to the project.json file representing the NuGet dependencies of the project
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.ExternalProjectReferences">
      <summary>
            A list of other external projects this project references. Uses the UniqueName.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.MSBuildProjectPath">
      <summary>
            Path to msbuild project file. Ex: xproj, csproj
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.ProjectJsonPath">
      <summary>
            Path to project.json
            </summary>
      <remarks>This may be null for projects that do not contain project.json.</remarks>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.PackageSpecProjectName">
      <summary>
            Project name used for project.json
            </summary>
      <remarks>This may be null for projects that do not contain project.json.</remarks>
    </member>
    <member name="P:NuGet.ProjectModel.ExternalProjectReference.ProjectName">
      <summary>
            Project name from the package spec or msbuild file.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.HashObjectWriter">
      <summary>
             Generates a hash from an object graph.
            
             This is non-private only to facilitate unit testing.
             </summary>
    </member>
    <member name="M:NuGet.ProjectModel.HashObjectWriter.#ctor(NuGet.ProjectModel.IHashFunction)">
      <summary>
            Creates a new instance with the provide hash function.
            </summary>
      <param name="hashFunc">An <see cref="T:NuGet.ProjectModel.IHashFunction" /> instance.  Throws if <c>null</c>.</param>
    </member>
    <member name="M:NuGet.ProjectModel.HashObjectWriter.GetHash">
      <summary>
             Gets the hash for the object.
            
             Once GetHash is called, no further writing is allowed.
             </summary>
      <returns>A hash of the object.</returns>
    </member>
    <member name="T:NuGet.ProjectModel.IExternalProjectReferenceProvider">
      <summary>
            Provides external project reference closures.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.IExternalProjectReferenceProvider.GetReferences(System.String)">
      <summary>
            Get the full p2p closure from an msbuild project path.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.IExternalProjectReferenceProvider.GetEntryPoints">
      <summary>
            Returns all known entry points.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.IHashFunction">
      <summary>
            Provides incremental hashing.
            
            This is non-private only to facilitate unit testing.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.IHashFunction.GetHash">
      <summary>
             Gets the hash.
            
             Once GetHash is called, no further hash updates are allowed.
             </summary>
      <returns>A base64-encoded hash.</returns>
    </member>
    <member name="M:NuGet.ProjectModel.IHashFunction.Update(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Incrementally updates the hash.
            </summary>
      <param name="data">The data to be included in the hash.</param>
      <param name="offset">The offset from which data should be read.</param>
      <param name="count">The count of bytes to read.</param>
    </member>
    <member name="M:NuGet.ProjectModel.JsonPackageSpecReader.GetPackageSpec(System.String,System.String)">
      <summary>
            Load and parse a project.json file
            </summary>
      <param name="name">project name</param>
      <param name="packageSpecPath">file path</param>
    </member>
    <member name="M:NuGet.ProjectModel.JsonPackageSpecReader.GetBoolOrFalse(Newtonsoft.Json.Linq.JToken,System.String,System.String)">
      <summary>
            Returns true if the property is set to true. Otherwise false.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.JsonPackageSpecReader.GetBoolOrFalse(Newtonsoft.Json.Linq.JObject,System.String,System.String)">
      <summary>
            Returns true if the property is set to true. Otherwise false.
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.JsonUtility.DefaultLoadSettings">
      <summary>
            JsonLoadSettings with line info and comments ignored.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.JsonUtility.LoadJson(System.IO.TextReader)">
      <summary>
            Load json from a file to a JObject using the default load settings.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.IAssetsLogMessage.Level">
      <summary>
            Level to indicate if this is an error or wanring.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.IAssetsLogMessage.Code">
      <summary>
            Indicates the NuGet error code.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.IAssetsLogMessage.Message">
      <summary>
            Indicates the staring generated by the code to go with the error code.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.IAssetsLogMessage.ProjectPath">
      <summary>
            Indicates the project for which the error was thrown.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.IAssetsLogMessage.WarningLevel">
      <summary>
            Level to indicate the warning level for the message.
            This is relevant only if the Level == LogLevel.Warning.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.IAssetsLogMessage.FilePath">
      <summary>
            Indicates the file for which the error was thrown.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.IAssetsLogMessage.StartLineNumber">
      <summary>
            Indicates the starting line for which the error was thrown.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.IAssetsLogMessage.StartColumnNumber">
      <summary>
            Indicates the starting column for which the error was thrown.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.IAssetsLogMessage.EndLineNumber">
      <summary>
            Indicates the ending line for which the error was thrown.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.IAssetsLogMessage.EndColumnNumber">
      <summary>
            Indicates the ending column for which the error was thrown.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.IAssetsLogMessage.LibraryId">
      <summary>
            Project or Package Id
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.IAssetsLogMessage.TargetGraphs">
      <summary>
            List of TargetGraphs
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.LockFileExtensions.GetTargetGraphs(NuGet.ProjectModel.IAssetsLogMessage,NuGet.ProjectModel.LockFile)">
      <summary>
            Get target graphs for the current log message.
            </summary>
      <remarks>If the message does not contain target graphs all graphs in the file
            will be returned.</remarks>
    </member>
    <member name="M:NuGet.ProjectModel.LockFileExtensions.GetTargetLibraries(NuGet.ProjectModel.IAssetsLogMessage,NuGet.ProjectModel.LockFile)">
      <summary>
            Get the library from each target graph it exists in.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.LockFileExtensions.GetTargetLibrary(NuGet.ProjectModel.LockFileTarget,System.String)">
      <summary>
            Get the library by id from the target graph.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.LockFileFormat.WriteLogMessage(NuGet.ProjectModel.IAssetsLogMessage,System.String)">
      <summary>
            Converts the <code>IAssetsLogMessage</code> object into a <code>JObject</code> that can be written into the assets file.
            </summary>
      <param name="logMessage">
        <code>IAssetsLogMessage</code> representing the log message.</param>
      <returns>
        <code>JObject</code> containg the json representation of the log message.</returns>
    </member>
    <member name="M:NuGet.ProjectModel.LockFileFormat.ReadLogMessage(Newtonsoft.Json.Linq.JObject,System.String)">
      <summary>
            Converts an <code>JObject</code> into an <code>IAssetsLogMessage</code>.
            </summary>
      <param name="json">
        <code>JObject</code> containg the json representation of the log message.</param>
      <returns>
        <code>IAssetsLogMessage</code> representing the log message.</returns>
    </member>
    <member name="M:NuGet.ProjectModel.LockFileLibrary.Clone">
      <summary>
            Makes a deep clone of the lock file library.
            </summary>
      <returns>The cloned lock file library.</returns>
    </member>
    <member name="P:NuGet.ProjectModel.LockFileLibrary.Path">
      <summary>
            Relative path to the project.json file for projects
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.LockFileLibrary.MSBuildProject">
      <summary>
            Relative path to the msbuild project file. Ex: xproj, csproj
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.PackageSpec">
      <summary>
            Represents the specification of a package that can be built.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpec.Clone">
      <summary>
            Clone a PackageSpec
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.PackageSpec.RestoreSettings">
      <summary>
            Project Settings is used to pass settings like HideWarningsAndErrors down to lower levels.
            Currently they do not include any settings that affect the final result of restore.
            This should not be part of the Equals and GetHashCode.
            Don't write this to the package spec
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.PackageSpec.RestoreMetadata">
      <summary>
            Additional MSBuild properties.
            </summary>
      <remarks>Optional. This is normally set for internal use only.</remarks>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecExtensions.GetTargetFramework(NuGet.ProjectModel.PackageSpec,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Get the nearest framework available in the project.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecExtensions.GetRestoreMetadataFramework(NuGet.ProjectModel.PackageSpec,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Get restore metadata framework. This is based on the project's target frameworks, then an 
            exact match is found under restore metadata.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecOperations.GetDependencyLists(NuGet.ProjectModel.PackageSpec,System.Collections.Generic.IEnumerable{NuGet.Frameworks.NuGetFramework},System.Boolean)">
      <summary>
            Get the list of dependencies in the package spec. Unless null is provided, the
            <paramref name="frameworksToConsider" /> set can be used to get the dependency lists for only for the
            provided target frameworks. If null is provided, all framework dependency lists are returned.
            </summary>
      <param name="spec">The package spec.</param>
      <param name="includeGenericDependencies">
            Whether or not the generic dependency list should be returned (dependencies that apply to all target
            frameworks.
            </param>
      <param name="frameworksToConsider">The frameworks to consider.</param>
      <returns>The sequence of dependency lists.</returns>
    </member>
    <member name="T:NuGet.ProjectModel.PackageSpecReferenceDependencyProvider">
      <summary>
            Handles both external references and projects discovered through directories
            If the type is set to external project directory discovery will be disabled.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecReferenceDependencyProvider.GetDependenciesFromSpecRestoreMetadata(NuGet.ProjectModel.PackageSpec,NuGet.Frameworks.NuGetFramework)">
      <summary>
            .NETCore projects
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecReferenceDependencyProvider.GetDependenciesFromExternalReference(NuGet.ProjectModel.ExternalProjectReference,NuGet.ProjectModel.PackageSpec,NuGet.Frameworks.NuGetFramework)">
      <summary>
            UWP Project.json
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecReferenceDependencyProvider.GetProjectNames(System.Collections.Generic.IEnumerable{NuGet.LibraryModel.LibraryDependency})">
      <summary>
            Filter dependencies down to only possible project references and return the names.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecUtility.SpecifySnapshot(System.String,System.String)">
      <summary>
            Apply a snapshot value.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecUtility.IsSnapshotVersion(System.String)">
      <summary>
            True if the string is a snapshot version.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.PackageSpecWriter">
      <summary>
            Writes out a PackageSpec object graph.
            
            This is non-private only to facilitate unit testing.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecWriter.Write(NuGet.ProjectModel.PackageSpec,NuGet.RuntimeModel.IObjectWriter)">
      <summary>
            Writes a PackageSpec to an <c>NuGet.Common.IObjectWriter</c> instance. 
            </summary>
      <param name="packageSpec">A <c>PackageSpec</c> instance.</param>
      <param name="writer">An <c>NuGet.Common.IObjectWriter</c> instance.</param>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecWriter.WriteToFile(NuGet.ProjectModel.PackageSpec,System.String)">
      <summary>
            Writes a PackageSpec to a file.
            </summary>
      <param name="packageSpec">A <c>PackageSpec</c> instance.</param>
      <param name="filePath">A file path to write to.</param>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecWriter.SetMSBuildMetadata(NuGet.RuntimeModel.IObjectWriter,NuGet.ProjectModel.PackageSpec)">
      <summary>
            This method sets the msbuild metadata that's important for restore. Ensures that frameworks regardless of which way they're stores in the metadata(full name or short tfm name) are written out the same.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.PackageSpecWriter.SetDependencies(NuGet.RuntimeModel.IObjectWriter,System.String,System.Collections.Generic.IEnumerable{NuGet.LibraryModel.LibraryDependency})">
      <summary>
            This method sorts the libraries based on the name
            This method also writes out the normalized versions to avoid cases where original string is set because it was gotten through project system vs being installed from PM UI
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectStyle">
      <summary>
            Restore behavior type.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectPath">
      <summary>
            MSBuild project file path.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectJsonPath">
      <summary>
            Full path to the project.json file if it exists.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.OutputPath">
      <summary>
            Assets file output path.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectName">
      <summary>
            Friendly project name.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectUniqueName">
      <summary>
            Name unique to the project across the solution.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.Sources">
      <summary>
            Package feed sources.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.PackagesPath">
      <summary>
            User packages folder path.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.CacheFilePath">
      <summary>
            Cache file path
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.FallbackFolders">
      <summary>
            Fallback folders.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ConfigFilePaths">
      <summary>
            ConfigFilePaths used.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.TargetFrameworks">
      <summary>
            Framework specific metadata, this may be a subset of the project's frameworks.
            Operations to determine the nearest framework should be done against the project's frameworks, 
            and then matched directly to this section.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.OriginalTargetFrameworks">
      <summary>
            Original target frameworks strings. These are used to match msbuild conditionals to $(TargetFramework)
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.CrossTargeting">
      <summary>
            True if $(TargetFrameworks) is used and the build is using Cross Targeting.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.LegacyPackagesDirectory">
      <summary>
            Whether or not to restore the packages directory using the legacy format, which write original case paths
            instead of lowercase.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.Files">
      <summary>
            Asset files. These should be equivalent to the files that would be
            in the nupkg after packing the project.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ValidateRuntimeAssets">
      <summary>
            Compatibility check for runtime framework assets.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.SkipContentFileWrite">
      <summary>
            True if this is a Legacy Package Reference project
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadata.ProjectWideWarningProperties">
      <summary>
            Contains Project wide properties for Warnings.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFile.PackagePath">
      <summary>
            Relative path that would be used within a package.
            This will be used to determine the asset type.
            Example: lib/net45/a.dll
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFile.AbsolutePath">
      <summary>
            Absolute path on disk.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFrameworkInfo.FrameworkName">
      <summary>
            Target framework
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreMetadataFrameworkInfo.ProjectReferences">
      <summary>
            Project references
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreReference.ProjectUniqueName">
      <summary>
            Project unique name.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreReference.ProjectPath">
      <summary>
            Full path to the msbuild project file.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.ProjectRestoreSettings">
      <summary>
            This class is used to hold restore related, project specific settings.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.ProjectRestoreSettings.HideWarningsAndErrors">
      <summary>
            Bool property is used inr estore command to not log errors and warning.
            Currently this is only being used for net core based projects on nomination.
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.Unknown">
      <summary>
            Unknown
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.ProjectJson">
      <summary>
            UAP style, project.lock.json is generated next to project.json
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.PackageReference">
      <summary>
            MSBuild style, project.assets.json is generated in the RestoreOutputPath folder
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.DotnetCliTool">
      <summary>
            DotnetCliToolReference "project"
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.Standalone">
      <summary>
            Non-MSBuild project with no project dependencies.
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.PackagesConfig">
      <summary>
            Packages.config project
            </summary>
    </member>
    <member name="F:NuGet.ProjectModel.ProjectStyle.DotnetToolReference">
      <summary>
            DotnetToolReference project
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.Sha512HashFunction">
      <summary>
            A SHA-512 hash function that supports incremental hashing.
            
            This is non-private only to facilitate unit testing.
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.ArgumentNullOrEmpty">
      <summary>
              Looks up a localized string similar to Argument cannot be null or empty..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.InvalidDependencyTarget">
      <summary>
              Looks up a localized string similar to Invalid dependency target value '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.InvalidPackageType">
      <summary>
              Looks up a localized string similar to The pack options package type must be a string or array of strings in '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.Log_ErrorReadingLockFile">
      <summary>
              Looks up a localized string similar to Error loading lock file '{0}' : {1}.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.Log_ErrorReadingProjectJson">
      <summary>
              Looks up a localized string similar to Error reading '{0}' : {1}.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.Log_ErrorReadingProjectJsonWithLocation">
      <summary>
              Looks up a localized string similar to Error reading '{0}' at line {1} column {2} : {3}.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.Log_InvalidImportFramework">
      <summary>
              Looks up a localized string similar to Imports contains an invalid framework: '{0}' in '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.Log_ProblemReadingCacheFile">
      <summary>
              Looks up a localized string similar to Problem reading the cache file {0} : {1}.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.MissingToolName">
      <summary>
              Looks up a localized string similar to Unable to resolve tool ''..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.MissingVersionOnDependency">
      <summary>
              Looks up a localized string similar to Package dependencies must specify a version range..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.Strings.MissingVersionOnTool">
      <summary>
              Looks up a localized string similar to Tools must specify a version range..
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.Imports">
      <summary>
            A fallback PCL framework to use when no compatible items
            were found for <see cref="P:NuGet.ProjectModel.TargetFrameworkInformation.FrameworkName" />.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.AssetTargetFallback">
      <summary>
            If True AssetTargetFallback behavior will be used for Imports.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.TargetFrameworkInformation.Warn">
      <summary>
            Display warnings when the Imports framework is used.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.ToolPathResolver.GetLockFilePath(System.String)">
      <summary>
            Given a toolDirectory path, it returns the full assets file path
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.ToolPathResolver.GetLockFilePath(System.String,NuGet.Versioning.NuGetVersion,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Given a package id, version and framework, returns the full assets file path
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.ToolPathResolver.GetToolDirectoryPath(System.String,NuGet.Versioning.NuGetVersion,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Given a package id, version and framework, returns the tool directory path where the assets/cache file are located for tools
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.ToolPathResolver.GetPackagesToolsBasePath">
      <summary>
            The base path for all restored tools
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.ToolPathResolver.GetBestToolDirectoryPath(System.String,NuGet.Versioning.VersionRange,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Returns the directory (packagesFolder/.tools/id/version for example) for the best matching version if any. 
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.ProjectModel.ToolPathResolver.GetAvailableToolVersions(System.String)">
      <summary>
            Given a package id, looks in the base tools folder and returns all the version available on disk, possibly none
            </summary>
    </member>
    <member name="T:NuGet.ProjectModel.WarningProperties">
      <summary>
            Class to hold warning properties given by project system.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.WarningProperties.GetWarningProperties(System.String,System.String,System.String)">
      <summary>
            Create warning properties from the msbuild property strings.
            </summary>
    </member>
    <member name="M:NuGet.ProjectModel.WarningProperties.GetWarningProperties(System.String,System.Collections.Generic.IEnumerable{NuGet.Common.NuGetLogCode},System.Collections.Generic.IEnumerable{NuGet.Common.NuGetLogCode})">
      <summary>
            Create warning properties from NuGetLogCode collection.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.WarningProperties.WarningsAsErrors">
      <summary>
            List of Warning Codes that should be treated as Errors.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.WarningProperties.NoWarn">
      <summary>
            List of Warning Codes that should be ignored.
            </summary>
    </member>
    <member name="P:NuGet.ProjectModel.WarningProperties.AllWarningsAsErrors">
      <summary>
            Indicates if all warnings should be ignored.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Protocol892262.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Protocol892262.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Protocol892262.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Protocol892262.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Protocol892262.HashCodeCombiner.GetHashCode``2(``0,``1)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Protocol892262.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Protocol892262.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
      <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
    </member>
    <member name="M:NuGet.Shared.NuGet.Protocol892262.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
    </member>
    <member name="T:NuGet.Repositories.LocalPackageInfo">
      <summary>
            Represents a package installed to the user global folder, or a fallback folder.
            Components of the package are cached and across all restores.
            </summary>
    </member>
    <member name="P:NuGet.Repositories.LocalPackageInfo.Nuspec">
      <summary>
            Caches the nuspec reader.
            If the nuspec does not exist this will throw a friendly exception.
            </summary>
    </member>
    <member name="P:NuGet.Repositories.LocalPackageInfo.Files">
      <summary>
            Package files with OPC files filtered out.
            Cached to avoid reading the same files multiple times.
            </summary>
    </member>
    <member name="P:NuGet.Repositories.LocalPackageInfo.Sha512">
      <summary>
            SHA512 of the package.
            </summary>
    </member>
    <member name="P:NuGet.Repositories.LocalPackageInfo.RuntimeGraph">
      <summary>
            runtime.json
            </summary>
      <remarks>Returns null if runtime.json does not exist in the package.</remarks>
    </member>
    <member name="T:NuGet.Repositories.NuGetv3LocalRepository">
      <summary>
            Caches package info from the global packages folder in memory.
            Packages not yet in the cache will be retrieved from disk.
            </summary>
    </member>
    <member name="M:NuGet.Repositories.NuGetv3LocalRepository.Exists(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            True if the package exists.
            </summary>
    </member>
    <member name="M:NuGet.Repositories.NuGetv3LocalRepository.ClearCacheForIds(System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Remove cached results for the given ids. This is needed
            after installing a new package.
            </summary>
    </member>
    <member name="M:NuGet.Repositories.NuGetv3LocalRepositoryUtility.GetPackage(System.Collections.Generic.IReadOnlyList{NuGet.Repositories.NuGetv3LocalRepository},System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Take the first match on id and version.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.CachingSourceProvider">
      <summary>
            A caching source repository provider intended to be used as a singleton.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.CachingSourceProvider.GetRepositories">
      <summary>
            Retrieve repositories that have been cached.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.CachingSourceProvider.CreateRepository(System.String)">
      <summary>
            Create a repository and add it to the cache.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.CachingSourceProvider.CreateRepository(NuGet.Configuration.PackageSource)">
      <summary>
            Create a repository and add it to the cache.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.ToJson(System.Object,Newtonsoft.Json.Formatting)">
      <summary>
            Serialize object to the JSON.
            </summary>
      <param name="obj">The object.</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.FromJson``1(System.String)">
      <summary>
            Deserialize object from the JSON.
            </summary>
      <typeparam name="T">Type of object</typeparam>
      <param name="json">JSON representation of object</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.FromJson``1(System.String,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserialize object from the JSON.
            </summary>
      <typeparam name="T">Type of object</typeparam>
      <param name="json">JSON representation of object</param>
      <param name="settings">The settings.</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.FromJson(System.String,System.Type)">
      <summary>
            Deserialize object from the JSON.
            </summary>
      <param name="json">JSON representation of object</param>
      <param name="type">The object type.</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.ToJToken(System.Object)">
      <summary>
            Serialize object to JToken.
            </summary>
      <param name="obj">The object.</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.FromJToken``1(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Deserialize object directly from JToken.
            </summary>
      <typeparam name="T">Type of object.</typeparam>
      <param name="jtoken">The JToken to be deserialized.</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.FromJToken(Newtonsoft.Json.Linq.JToken,System.Type)">
      <summary>
            Deserialize object directly from JToken.
            </summary>
      <param name="jtoken">The JToken to be deserialized.</param>
      <param name="type">The object type.</param>
    </member>
    <member name="M:NuGet.Protocol.JsonExtensions.GetJObjectProperty``1(Newtonsoft.Json.Linq.JObject,System.String)">
      <summary>
            Extract the property directly from JObject.
            </summary>
      <typeparam name="T">Type of property to return.</typeparam>
      <param name="jobject">The JObject to be deserialized.</param>
      <param name="propertyName">The property name.</param>
    </member>
    <member name="T:NuGet.Protocol.SemanticVersionConverter">
      <summary>
            A SemanticVersion JSON converter.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.SemanticVersionConverter.CanConvert(System.Type)">
      <summary>
            Gets a flag indicating whether or not a type is convertible.
            </summary>
      <param name="objectType">An object type to check.</param>
      <returns>
        <c>true</c> if <paramref name="objectType" /> is convertible; otherwise <c>false</c>.</returns>
    </member>
    <member name="M:NuGet.Protocol.SemanticVersionConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">A JSON reader.</param>
      <param name="objectType">The type of the object.</param>
      <param name="existingValue">The existing value of the object.</param>
      <param name="serializer">A serializer.</param>
      <returns>A <see cref="T:NuGet.Versioning.SemanticVersion" /> object.</returns>
    </member>
    <member name="M:NuGet.Protocol.SemanticVersionConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">A JSON writer.</param>
      <param name="value">A value to serialize.</param>
      <param name="serializer">A serializer.</param>
    </member>
    <member name="M:NuGet.Protocol.ResolverMetadataClient.GetDependencies(NuGet.Protocol.HttpSource,System.Uri,System.String,NuGet.Versioning.VersionRange,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve the <see cref="T:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo" /> for a registration.
            </summary>
      <returns>Returns an empty sequence if the package does not exist.</returns>
    </member>
    <member name="M:NuGet.Protocol.ResolverMetadataClient.ProcessPackageVersion(Newtonsoft.Json.Linq.JObject,NuGet.Versioning.NuGetVersion)">
      <summary>
            Process an individual package version entry
            </summary>
      <param name="packageObj">
      </param>
      <param name="version">
      </param>
      <returns>Returns the RemoteSourceDependencyInfo object corresponding to this package version</returns>
    </member>
    <member name="M:NuGet.Protocol.ResolverMetadataClient.GetRegistrationInfo(NuGet.Protocol.HttpSource,System.Uri,System.String,NuGet.Versioning.VersionRange,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Frameworks.NuGetFramework,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve a registration blob
            </summary>
      <returns>Returns Null if the package does not exist</returns>
    </member>
    <member name="M:NuGet.Protocol.ResolverMetadataClient.GetFramework(Newtonsoft.Json.Linq.JObject)">
      <summary>
            Retrieve the target framework from a dependency group obj
            </summary>
    </member>
    <member name="T:NuGet.Protocol.InvalidCacheProtocolException">
      <summary>
            Failure due to an invalid cache.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.PackageNotFoundProtocolException">
      <summary>
            Thrown when a package cannot be found on a feed.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.PackageNotFoundProtocolException.PackageIdentity">
      <summary>
            Package that was not found.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.Undefined">
      <summary>
            Undetermined type
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.HttpV2">
      <summary>
            V2 OData protocol, ex: https://www.nuget.org/api/v2/
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.HttpV3">
      <summary>
            V3 Json protocol, ex: https://api.nuget.org/v3/index.json
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.FileSystemV2">
      <summary>
            Flat folder of nupkgs
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.FileSystemV3">
      <summary>
            Version folder structure used for project.json
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.FileSystemUnzipped">
      <summary>
            Unzipped folder of nupkgs used by project templates
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.FileSystemPackagesConfig">
      <summary>
            Packages.config packages folder format
            </summary>
    </member>
    <member name="F:NuGet.Protocol.FeedType.FileSystemUnknown">
      <summary>
            Undetermined folder type. Occurs when the folder is empty
            or does not exist yet.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.FeedTypePackageSource">
      <summary>
            PackageSource that can carry a feed type used to override the source repository and provide a 
            hint for the expected type.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.FeedTypePackageSource.FeedType">
      <summary>
            Feed type, ex: HttpV2, FileSystemV3
            </summary>
    </member>
    <member name="T:NuGet.Protocol.FeedTypeResource">
      <summary>
            Resource wrapper for FeedType.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.AmbientAuthenticationState">
      <summary>
            Represents source authentication status per active operation
            </summary>
    </member>
    <member name="T:NuGet.Protocol.DownloadTimeoutStreamContent">
      <summary>
            A wrapper around <see cref="T:System.Net.Http.StreamContent" /> that applies a <see cref="T:NuGet.Protocol.DownloadTimeoutStream" />
            to the contained stream. When the <see cref="T:System.Net.Http.HttpResponseMessage" /> is disposed, this
            content is disposed which in turn disposes the <see cref="T:NuGet.Protocol.DownloadTimeoutStream" />, which
            disposes the actual network stream.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.HttpHandlerResourceV3">
      <summary>
            Resource wrapper for an HttpClient
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpHandlerResourceV3.CredentialsSuccessfullyUsed">
      <summary>
            Gets or sets a delegate that is to be invoked when authenticated feed credentials are successfully
            used.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageExtensions.Clone(System.Net.Http.HttpRequestMessage)">
      <summary>
            Clones an <see cref="T:System.Net.Http.HttpRequestMessage" /> request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageExtensions.GetOrCreateConfiguration(System.Net.Http.HttpRequestMessage)">
      <summary>
            Retrieves the HTTP request configuration instance attached to the given message as custom property.
            </summary>
      <param name="request">The HTTP request message.</param>
      <returns>Configuration instance if exists, or a default instance otherwise.</returns>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageExtensions.SetConfiguration(System.Net.Http.HttpRequestMessage,NuGet.Protocol.HttpRequestMessageConfiguration)">
      <summary>
            Attaches an HTTP request configuration instance to the given message as custom property.
            If the configuration has already been set on the request message, the old configuration
            is replaced.
            </summary>
      <param name="request">The HTTP request message.</param>
      <param name="configuration">An HTTP request message configuration instance.</param>
    </member>
    <member name="T:NuGet.Protocol.HttpRequestMessageFactory">
      <summary>
            Factory class containing methods facilitating creation of <see cref="T:System.Net.Http.HttpRequestMessage" /> 
            with additional custom parameters.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageFactory.Create(System.Net.Http.HttpMethod,System.String,NuGet.Common.ILogger)">
      <summary>
            Creates an instance of <see cref="T:System.Net.Http.HttpRequestMessage" />.
            </summary>
      <param name="method">Desired HTTP verb</param>
      <param name="requestUri">Request URI</param>
      <param name="log">Logger instance to be attached</param>
      <returns>Instance of <see cref="T:System.Net.Http.HttpRequestMessage" /></returns>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageFactory.Create(System.Net.Http.HttpMethod,System.Uri,NuGet.Common.ILogger)">
      <summary>
            Creates an instance of <see cref="T:System.Net.Http.HttpRequestMessage" />.
            </summary>
      <param name="method">Desired HTTP verb</param>
      <param name="requestUri">Request URI</param>
      <param name="log">Logger instance to be attached</param>
      <returns>Instance of <see cref="T:System.Net.Http.HttpRequestMessage" /></returns>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageFactory.Create(System.Net.Http.HttpMethod,System.String,NuGet.Protocol.HttpRequestMessageConfiguration)">
      <summary>
            Creates an instance of <see cref="T:System.Net.Http.HttpRequestMessage" />.
            </summary>
      <param name="method">Desired HTTP verb</param>
      <param name="requestUri">Request URI</param>
      <param name="configuration">The request configuration</param>
      <returns>Instance of <see cref="T:System.Net.Http.HttpRequestMessage" /></returns>
    </member>
    <member name="M:NuGet.Protocol.HttpRequestMessageFactory.Create(System.Net.Http.HttpMethod,System.Uri,NuGet.Protocol.HttpRequestMessageConfiguration)">
      <summary>
            Creates an instance of <see cref="T:System.Net.Http.HttpRequestMessage" />.
            </summary>
      <param name="method">Desired HTTP verb</param>
      <param name="requestUri">Request URI</param>
      <param name="configuration">The request configuration</param>
      <returns>Instance of <see cref="T:System.Net.Http.HttpRequestMessage" /></returns>
    </member>
    <member name="T:NuGet.Protocol.HttpRetryHandler">
      <summary>
            The <see cref="T:NuGet.Protocol.HttpRetryHandler" /> is for retrying and HTTP request if it times out, has any exception,
            or returns a status code of 500 or greater.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.HttpRetryHandler.SendAsync(NuGet.Protocol.HttpRetryHandlerRequest,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Make an HTTP request while retrying after failed attempts or timeouts.
            </summary>
      <remarks>
            This method accepts a factory to create instances of the <see cref="T:System.Net.Http.HttpRequestMessage" /> because
            requests cannot always be used. For example, suppose the request is a POST and contains content
            of a stream that can only be consumed once.
            </remarks>
    </member>
    <member name="T:NuGet.Protocol.HttpRetryHandlerRequest">
      <summary>
            A request to be handled by <see cref="T:NuGet.Protocol.HttpRetryHandler" />. This type should contain all
            of the knowledge necessary to make a request, while handling transient transport errors.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.HttpClient">
      <summary>The HTTP client to use for each request attempt.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.RequestFactory">
      <summary>
            The factory that generates each request message. This factory is invoked for each attempt.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.CompletionOption">
      <summary>The HTTP completion option to use for the next attempt.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.MaxTries">
      <summary>The maximum number of times to try the request. This value includes the initial attempt.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.RequestTimeout">
      <summary>How long to wait on the request to come back with a response.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.RetryDelay">
      <summary>How long to wait before trying again after a failed request.</summary>
      <summary>This API is intended only for testing purposes and should not be used in product code.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.DownloadTimeout">
      <summary>The timeout to apply to <see cref="T:NuGet.Protocol.DownloadTimeoutStream" /> instances.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpRetryHandlerRequest.AddHeaders">
      <summary>
            Additional headers to add to the request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.HttpSource.GetAsync``1(NuGet.Protocol.HttpSourceCachedRequest,System.Func{NuGet.Protocol.HttpSourceResult,System.Threading.Tasks.Task{``0}},NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Caching Get request.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSource.RetryHandler">
      <summary>The retry handler to use for all HTTP requests.</summary>
      <summary>This API is intended only for testing purposes and should not be used in product code.</summary>
    </member>
    <member name="T:NuGet.Protocol.HttpSourceCachedRequest">
      <summary>
            A cached HTTP request handled by <see cref="T:NuGet.Protocol.HttpSource" />.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.Uri">
      <summary>
            The URI to request with <code>GET</code>.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.CacheKey">
      <summary>
            The cache key to use when fetching and storing the response from the HTTP cache. This
            cache key is scoped to the NuGet source. That is to say that each NuGet source has its
            own independent HTTP cache.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.CacheContext">
      <summary>
            The cache context.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.AcceptHeaderValues">
      <summary>
            The header values to apply when building the <see cref="T:System.Net.Http.HttpRequestMessage" />.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.IgnoreNotFounds">
      <summary>
            When processing the <see cref="T:System.Net.Http.HttpResponseMessage" />, this flag allows
            <code>404 Not Found</code> to be interpreted as a null response. This value defaults
            to <code>false</code>.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.MaxTries">
      <summary>The maximum number of times to try the request. This value includes the initial attempt.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.EnsureValidContents">
      <summary>
            A method used to validate the response stream. This method should not
            dispose the stream and should throw an exception when the content is invalid.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.RequestTimeout">
      <summary>
            The timeout to use when fetching the <see cref="T:System.Net.Http.HttpResponseMessage" />. Since
            <see cref="T:NuGet.Protocol.HttpSource" /> only uses <see cref="F:System.Net.Http.HttpCompletionOption.ResponseHeadersRead" />,
            this means that we wait this amount of time for only the HTTP headers to be returned.
            Downloading the response body is not included in this timeout.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCachedRequest.DownloadTimeout">
      <summary>The timeout to apply to <see cref="T:NuGet.Protocol.DownloadTimeoutStream" /> instances.</summary>
    </member>
    <member name="T:NuGet.Protocol.HttpSourceCredentials">
      <summary>
            A mutable CredentialCache wrapper. This allows the underlying ICredentials to
            be changed to work around HttpClientHandler not allowing Credentials to change.
            This class intentionally inherits from CredentialCache to support authentication on redirects.
            According to System.Net implementation any other ICredentials implementation is dropped for security reasons.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.HttpSourceCredentials._credentials">
      <summary>
            Credentials can be changed by other threads, for this reason volatile
            is added below so that the value is not cached anywhere.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.HttpSourceCredentials.#ctor(System.Net.ICredentials)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.HttpSourceCredentials" /> class
            </summary>
      <param name="credentials">
            Optional initial credentials. May be null.
            </param>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCredentials.Credentials">
      <summary>
            The latest credentials to be used.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceCredentials.Version">
      <summary>
            The latest version ID of the <see cref="P:NuGet.Protocol.HttpSourceCredentials.Credentials" />.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.HttpSourceRequest">
      <summary>
            A non-cached HTTP request handled by <see cref="T:NuGet.Protocol.HttpSource" />.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceRequest.RequestFactory">
      <summary>
            A factory that can be called repeatedly to build the HTTP request message.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceRequest.IgnoreNotFounds">
      <summary>
            When processing the <see cref="T:System.Net.Http.HttpResponseMessage" />, this flag allows
            <code>404 Not Found</code> to be interpreted as a null response. This value defaults
            to <code>false</code>.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceRequest.RequestTimeout">
      <summary>
            The timeout to use when fetching the <see cref="T:System.Net.Http.HttpResponseMessage" />. Since
            <see cref="T:NuGet.Protocol.HttpSource" /> only uses <see cref="F:System.Net.Http.HttpCompletionOption.ResponseHeadersRead" />,
            this means that we wait this amount of time for only the HTTP headers to be returned.
            Downloading the response body is not included in this timeout.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceRequest.MaxTries">
      <summary>The maximum number of times to try the request. This value includes the initial attempt.</summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceRequest.DownloadTimeout">
      <summary>The timeout to apply to <see cref="T:NuGet.Protocol.DownloadTimeoutStream" /> instances.</summary>
    </member>
    <member name="T:NuGet.Protocol.HttpSourceResource">
      <summary>
            Holds a shared <see cref="P:NuGet.Protocol.HttpSourceResource.HttpSource" />. 
            This is expected to be shared across the app and should not be disposed of.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.HttpSourceResourceProvider.Throttle">
      <summary>
            The throttle to apply to all <see cref="T:NuGet.Protocol.HttpSource" /> HTTP requests.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.IThrottle">
      <summary>
            An interface used for throttling operations. For example, suppose the application needs to
            limit the concurrency of HTTP operations. Before executing each HTTP operation, the
            <see cref="M:NuGet.Protocol.IThrottle.WaitAsync" /> would be executed. After the HTTP operation has been completed, the
            application should call <see cref="M:NuGet.Protocol.IThrottle.Release" />. The implementation of <see cref="M:NuGet.Protocol.IThrottle.WaitAsync" />
            should only allow the application to continue if there is an appropriate number of concurrent
            callers. The primary implementation of this interface simply wraps a <see cref="T:System.Threading.SemaphoreSlim" />.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.IThrottle.WaitAsync">
      <summary>
            Waits until an appropriate level of concurrency has been reached before allowing the
            caller to continue.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.IThrottle.Release">
      <summary>
            Signals that the throttled operation has been completed and other threads can being
            their own throttled operation.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.NullThrottle">
      <summary>
            An throttle implementation that allows any level of concurrency. That is, the
            <see cref="M:NuGet.Protocol.NullThrottle.WaitAsync" /> and <see cref="M:NuGet.Protocol.NullThrottle.Release" /> methods do nothing.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.ProxyAuthenticationHandler">
      <summary>
            A message handler responsible for retrying request for authenticated proxies
            with missing credentials.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.SemaphoreSlimThrottle.CurrentCount">
      <summary>
            The number of remaining threads that can enter the semaphore.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.StsAuthenticationHandler.STSEndPointHeader">
      <summary>
            Response header that specifies the WSTrust13 Windows Transport endpoint.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.StsAuthenticationHandler.STSRealmHeader">
      <summary>
            Response header that specifies the realm to authenticate for. In most cases this would be the gallery we are going up against.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.StsAuthenticationHandler.STSTokenHeader">
      <summary>
            Request header that contains the SAML token.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.StsAuthenticationHandler.PrepareSTSRequest(System.Net.Http.HttpRequestMessage)">
      <summary>
            Adds the SAML token as a header to the request if it is already cached for this source.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.StsAuthenticationHandler.TryRetrieveSTSToken(System.Net.Http.HttpResponseMessage)">
      <summary>
            Attempts to retrieve a SAML token if the response indicates that server requires STS-based auth.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DependencyInfoResourceV2Feed.CreateDependencyInfo(NuGet.Protocol.V2FeedPackageInfo,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Convert a V2 feed package into a V3 PackageDependencyInfo
            </summary>
    </member>
    <member name="T:NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed">
      <summary>
            A resource for detecting a V2 feed's capabilities based on the metadata document.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.LegacyFeedCapabilityResourceV2Feed.DataServiceMetadataExtractor">
      <summary>
            This implementation is copied from NuGet 2.x.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ODataServiceDocumentResourceV2Provider.MaxCacheDuration">
      <summary>
            Maximum amount of time to store index.json
            </summary>
    </member>
    <member name="T:NuGet.Protocol.V2FeedPackageInfo">
      <summary>
            Represents a V2 package entry from the OData feed. This object primarily just holds the strings parsed from XML, all parsing 
            and converting should be done after based on the scenario.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.V2FeedPackageInfo.DownloadCountAsInt">
      <summary>
            Parse DownloadCount into an integer
            </summary>
    </member>
    <member name="P:NuGet.Protocol.V2FeedPackageInfo.IsListed">
      <summary>
            Checks the published date
            </summary>
    </member>
    <member name="P:NuGet.Protocol.V2FeedPackageInfo.DependencySets">
      <summary>
            Parses Dependencies into actual groups
            </summary>
    </member>
    <member name="T:NuGet.Protocol.V2FeedPage">
      <summary>
            A page of items from a V2 feed as well as a link to get the next page.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.V2FeedParser">
      <summary>
            A light weight XML parser for NuGet V2 Feeds
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.#ctor(NuGet.Protocol.HttpSource,System.String)">
      <summary>
            Creates a V2 parser
            </summary>
      <param name="httpSource">HttpSource and message handler containing auth/proxy support</param>
      <param name="baseAddress">base address for all services from this OData service</param>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.#ctor(NuGet.Protocol.HttpSource,System.String,System.String)">
      <summary>
            Creates a V2 parser
            </summary>
      <param name="httpSource">HttpSource and message handler containing auth/proxy support</param>
      <param name="baseAddress">base address for all services from this OData service</param>
      <param name="source">PackageSource useful for reporting meaningful errors that relate back to the configuration</param>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.GetPackage(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Get an exact package
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.FindPackagesByIdAsync(System.String,System.Boolean,System.Boolean,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieves all packages with the given Id from a V2 feed.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.FindPackagesByIdAsync(System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieves all packages with the given Id from a V2 feed.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.ParsePage(System.Xml.Linq.XDocument,System.String,NuGet.Protocol.MetadataReferenceCache)">
      <summary>
            Finds all entries on the page and parses them
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.ParsePackage(System.String,System.Xml.Linq.XElement,NuGet.Protocol.MetadataReferenceCache)">
      <summary>
            Parse an entry into a V2FeedPackageInfo
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.GetString(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
      <summary>
            Retrieve an XML <see cref="T:System.String" /> value safely
            </summary>
    </member>
    <member name="M:NuGet.Protocol.V2FeedParser.GetDate(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
      <summary>
            Retrieve an XML <see cref="T:System.DateTimeOffset" /> value safely
            </summary>
    </member>
    <member name="T:NuGet.Protocol.V2FeedQueryBuilder">
      <summary>
            Build the path part of a V2 feed URL. These values are appended to the V2 base URL.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.FindLocalPackagesResourcePackagesConfig">
      <summary>
            Packages.config packages folder reader
            </summary>
    </member>
    <member name="T:NuGet.Protocol.FindLocalPackagesResourcePackagesConfigProvider">
      <summary>
            Reads packages.config packages folders. The expected format is root/id.version/id.version.nupkg
            This resource cannot handle packages folders in the format root/id (exclude version)
            </summary>
    </member>
    <member name="T:NuGet.Protocol.FindLocalPackagesResourceUnzipped">
      <summary>
            Unzipped package repository reader used for project templates.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.FindLocalPackagesResourceUnzipped.GetIndex(System.Lazy{System.Collections.Generic.IReadOnlyList{NuGet.Protocol.LocalPackageInfo}})">
      <summary>
            Id + Version -&gt; Package
            </summary>
    </member>
    <member name="M:NuGet.Protocol.FindLocalPackagesResourceUnzipped.GetPathIndex(System.Lazy{System.Collections.Generic.IReadOnlyList{NuGet.Protocol.LocalPackageInfo}})">
      <summary>
            Uri -&gt; Package
            </summary>
    </member>
    <member name="T:NuGet.Protocol.FindLocalPackagesResourceV3">
      <summary>
            Retrieve packages from a local folder or UNC share that uses the V3 folder structure.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalDependencyInfoResource.ResolvePackage(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve dependency info for a single package.
            </summary>
      <param name="package">package id and version</param>
      <param name="projectFramework">project target framework. This is used for finding the dependency group</param>
      <param name="token">cancellation token</param>
    </member>
    <member name="M:NuGet.Protocol.LocalDependencyInfoResource.ResolvePackages(System.String,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve dependency info for a single package.
            </summary>
      <param name="packageId">package id</param>
      <param name="projectFramework">project target framework. This is used for finding the dependency group</param>
      <param name="token">cancellation token</param>
    </member>
    <member name="M:NuGet.Protocol.LocalDependencyInfoResource.CreateDependencyInfo(NuGet.Protocol.LocalPackageInfo,NuGet.Frameworks.NuGetFramework)">
      <summary>
            Convert a package into a PackageDependencyInfo
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageInfo.#ctor(NuGet.Packaging.Core.PackageIdentity,System.String,System.DateTime,System.Lazy{NuGet.Packaging.NuspecReader},System.Func{NuGet.Packaging.PackageReaderBase})">
      <summary>
            Local nuget package.
            </summary>
      <param name="identity">Package id and version.</param>
      <param name="path">Path to the nupkg.</param>
      <param name="lastWriteTimeUtc">Last nupkg write time for publish date.</param>
      <param name="nuspec">Nuspec XML.</param>
      <param name="getPackageReader">Method to retrieve the package as a reader.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageInfo.GetReader">
      <summary>
            Package reader.
            </summary>
      <remarks>This creates a new instance each time. Callers need to dispose of it.</remarks>
    </member>
    <member name="P:NuGet.Protocol.LocalPackageInfo.Identity">
      <summary>
            Package id and version.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.LocalPackageInfo.Path">
      <summary>
            Nupkg or folder path.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.LocalPackageInfo.LastWriteTimeUtc">
      <summary>
            Last file write time. This is used for the publish date.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.LocalPackageInfo.Nuspec">
      <summary>
            Nuspec reader.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageSearchResource.ContainsAnyTerm(System.String[],NuGet.Protocol.LocalPackageInfo)">
      <summary>
            Search Id, Tags, and Description to match the legacy local search behavior.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageSearchResource.CollapseToHighestVersion(System.Collections.Generic.IEnumerable{NuGet.Protocol.LocalPackageInfo})">
      <summary>
            Returns a distinct set of elements using the comparer specified. This implementation will pick the last occurrence
            of each element instead of picking the first. This method assumes that similar items occur in order.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.LocalV2FindPackageByIdResource">
      <summary>
            A resource capable of fetching packages, package versions and package dependency information.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalV2FindPackageByIdResource.#ctor(NuGet.Configuration.PackageSource)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.LocalV2FindPackageByIdResource" /> class.
            </summary>
      <param name="packageSource">A package source.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageSource" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.LocalV2FindPackageByIdResource.GetAllVersionsAsync(System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets all package versions for a package ID.
            </summary>
      <param name="id">A package ID.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.LocalV2FindPackageByIdResource.CopyNupkgToStreamAsync(System.String,NuGet.Versioning.NuGetVersion,System.IO.Stream,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies a .nupkg to a stream.
            </summary>
      <param name="id">A package ID.</param>
      <param name="version">A package version.</param>
      <param name="destination">A destination stream.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Boolean" /> indicating whether or not the .nupkg file was copied.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="destination" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.LocalV2FindPackageByIdResource.GetDependencyInfoAsync(System.String,NuGet.Versioning.NuGetVersion,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets dependency information for a specific package.
            </summary>
      <param name="id">A package id.</param>
      <param name="version">A package version.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.LocalV2FindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package downloader for a package identity.
            </summary>
      <param name="packageIdentity">A package identity.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an <see cref="T:NuGet.Packaging.IPackageDownloader" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageIdentity" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.LocalV2FindPackageByIdResourceProvider">
      <summary>
            A v2-style package repository that has nupkgs at the root.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.LocalV3FindPackageByIdResource">
      <summary>
            A resource capable of fetching packages, package versions and package dependency information.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalV3FindPackageByIdResource.#ctor(NuGet.Configuration.PackageSource)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.LocalV3FindPackageByIdResource" /> class.
            </summary>
      <param name="packageSource">A package source.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageSource" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.LocalV3FindPackageByIdResource.GetAllVersionsAsync(System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets all package versions for a package ID.
            </summary>
      <param name="id">A package ID.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.LocalV3FindPackageByIdResource.CopyNupkgToStreamAsync(System.String,NuGet.Versioning.NuGetVersion,System.IO.Stream,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies a .nupkg to a stream.
            </summary>
      <param name="id">A package ID.</param>
      <param name="version">A package version.</param>
      <param name="destination">A destination stream.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Boolean" /> indicating whether or not the .nupkg file was copied.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="destination" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.LocalV3FindPackageByIdResource.GetDependencyInfoAsync(System.String,NuGet.Versioning.NuGetVersion,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets dependency information for a specific package.
            </summary>
      <param name="id">A package id.</param>
      <param name="version">A package version.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.LocalV3FindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package downloader for a package identity.
            </summary>
      <param name="packageIdentity">A package identity.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an <see cref="T:NuGet.Packaging.IPackageDownloader" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageIdentity" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="P:NuGet.Protocol.LocalV3FindPackageByIdResource.PackageFileCache">
      <summary>
            Nuspec files read from disk.
            This is exposed to allow sharing the cache with other components
            that are reading the same files.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.LocalV3FindPackageByIdResourceProvider">
      <summary>
            A v3-style package repository that has expanded packages.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageSearchMetadata.Convert(System.String)">
      <summary>
            Convert a string to a URI safely. This will return null if there are errors.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.PackageSearchMetadataRegistration">
      <summary>
            Subclass of <see cref="T:NuGet.Protocol.PackageSearchMetadata" /> containing the information in the registration blobs that are not present in the V2 feed or search.
            Returned by <see cref="T:NuGet.Protocol.PackageMetadataResourceV3" />.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.PackageSearchMetadataRegistration.CatalogUri">
      <summary>
            The <see cref="T:System.Uri" /> of this package in the catalog.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.ServiceIndexEntry">
      <summary>
            index.json entry for v3
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ServiceIndexEntry.Uri">
      <summary>
            Service Uri
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ServiceIndexEntry.Type">
      <summary>
            Service Type
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ServiceIndexEntry.ClientVersion">
      <summary>
            Client version
            </summary>
    </member>
    <member name="T:NuGet.Protocol.LocalPackageFileCache">
      <summary>
            Allow .nuspec files on disk to be cached across v3 folder readers.
            Allow the list of files in a package to be cached across all projects.
            </summary>
      <remarks>It is expected that the caller has already verified the that folder and paths are valid.</remarks>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageFileCache.GetOrAddNuspec(System.String,System.String)">
      <summary>
            Read a nuspec file from disk. The nuspec is expected to exist.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageFileCache.GetOrAddFiles(System.String)">
      <summary>
            Read a the package files from disk.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageFileCache.GetOrAddSha512(System.String)">
      <summary>
            Read the .sha512 file from disk.
            </summary>
      <remarks>Throws if the file is not found.</remarks>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageFileCache.Sha512Exists(System.String)">
      <summary>
            True if the path exists on disk. This also uses
            the SHA512 cache for already read files.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageFileCache.GetOrAddRuntimeGraph(System.String)">
      <summary>
            Read runtime.json from a package.
            Returns null if runtime.json does not exist.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageFileCache.GetFiles(System.String)">
      <summary>
            Read files from a package folder.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageFileCache.IsAllowedLibraryFile(System.String)">
      <summary>
            True if the file should be added to the lock file library
            Fale if it is an OPC file or empty directory
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageFileCache.GetNuspec(System.String,System.String)">
      <summary>
            Search for a nuspec using the given path, or by the expanded folder path.
            The manifest path here is a shortcut to use the already constructed well
            known location, if this doesn't exist the folder reader will find the nuspec
            if it exists.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalPackageFileCache.GetRuntimeGraph(System.String)">
      <summary>
            Return runtime.json from a package.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.DependencyInfoResourceV3Provider">
      <summary>
            Retrieves all dependency info for the package resolver.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.DownloadResourcePluginProvider">
      <summary>
            A download resource provider for plugins.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DownloadResourcePluginProvider.#ctor">
      <summary>
            Instanatiates a new <see cref="T:NuGet.Protocol.DownloadResourcePluginProvider" /> class.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DownloadResourcePluginProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository,System.Threading.CancellationToken)">
      <summary>
            Attempts to create a resource for the specified source repository.
            </summary>
      <param name="source">A source repository.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a Tuple&lt;bool, INuGetResource&gt;</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="source" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.ServiceIndexResourceV3Provider">
      <summary>
            Retrieves and caches service index.json files
            ServiceIndexResourceV3 stores the json, all work is done in the provider
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ServiceIndexResourceV3Provider.MaxCacheDuration">
      <summary>
            Maximum amount of time to store index.json
            </summary>
    </member>
    <member name="T:NuGet.Protocol.RemotePackageArchiveDownloader">
      <summary>
            A remote package downloader.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.RemotePackageArchiveDownloader.#ctor(System.String,NuGet.Protocol.Core.Types.FindPackageByIdResource,NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.RemotePackageArchiveDownloader" /> class.
            </summary>
      <param name="source">A package source.</param>
      <param name="resource">A <see cref="T:NuGet.Protocol.Core.Types.FindPackageByIdResource" /> resource.</param>
      <param name="packageIdentity">A package identity.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="resource" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageIdentity" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.RemotePackageArchiveDownloader.Dispose">
      <summary>
            Disposes this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.RemotePackageArchiveDownloader.CopyNupkgFileToAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies a .nupkg to a target file path.
            </summary>
      <param name="destinationFilePath">The destination file path.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.Boolean" />
            indicating whether or not the copy was successful.</returns>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="destinationFilePath" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.RemotePackageArchiveDownloader.GetPackageHashAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package hash.
            </summary>
      <param name="hashAlgorithm">The hash algorithm.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.String" />
            representing the package hash.</returns>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="hashAlgorithm" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.RemotePackageArchiveDownloader.SetExceptionHandler(System.Func{System.Exception,System.Threading.Tasks.Task{System.Boolean}})">
      <summary>
            Sets an exception handler for package downloads.
            </summary>
      <remarks>The exception handler returns a task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.Boolean" />
            indicating whether or not the exception was handled.  To handle an exception and stop its
            propagation, the task should return <c>true</c>.  Otherwise, the exception will be rethrown.</remarks>
      <param name="handleExceptionAsync">An exception handler.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="handleExceptionAsync" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.RemotePackageArchiveDownloader.SetThrottle(System.Threading.SemaphoreSlim)">
      <summary>
            Sets a throttle for package downloads.
            </summary>
      <param name="throttle">A throttle.  Can be <c>null</c>.</param>
    </member>
    <member name="P:NuGet.Protocol.RemotePackageArchiveDownloader.ContentReader">
      <summary>
            Gets an asynchronous package content reader.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
    </member>
    <member name="P:NuGet.Protocol.RemotePackageArchiveDownloader.CoreReader">
      <summary>
            Gets an asynchronous package core reader.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
    </member>
    <member name="T:NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource">
      <summary>
            A <see cref="T:NuGet.Protocol.Core.Types.FindPackageByIdResource" /> for a Http-based file system where files are laid out in the
            format
            /root/
            PackageA/
            Version0/
            PackageA.nuspec
            PackageA.Version0.nupkg
            and are accessible via HTTP Gets.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource.#ctor(System.Collections.Generic.IReadOnlyList{System.Uri},NuGet.Protocol.HttpSource)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource" /> class.
            </summary>
      <param name="baseUris">Base URI's.</param>
      <param name="httpSource">An HTTP source.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="baseUris" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="baseUris" /> is empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="httpSource" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource.GetAllVersionsAsync(System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets all package versions for a package ID.
            </summary>
      <param name="id">A package ID.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource.GetDependencyInfoAsync(System.String,NuGet.Versioning.NuGetVersion,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets dependency information for a specific package.
            </summary>
      <param name="id">A package id.</param>
      <param name="version">A package version.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource.CopyNupkgToStreamAsync(System.String,NuGet.Versioning.NuGetVersion,System.IO.Stream,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies a .nupkg to a stream.
            </summary>
      <param name="id">A package ID.</param>
      <param name="version">A package version.</param>
      <param name="destination">A destination stream.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Boolean" /> indicating whether or not the .nupkg file was copied.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="destination" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.HttpFileSystemBasedFindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package downloader for a package identity.
            </summary>
      <param name="packageIdentity">A package identity.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an <see cref="T:NuGet.Packaging.IPackageDownloader" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageIdentity" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.PackageUtilities.OpenNuspecFromNupkg(System.String,System.IO.Stream,NuGet.Common.ILogger)">
      <summary>
            Create a <see cref="T:NuGet.Packaging.NuspecReader" /> from a nupkg stream.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.PluginFindPackageByIdResourceProvider">
      <summary>
            A FindPackageByIdResource provider for plugins.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.PluginFindPackageByIdResourceProvider.#ctor">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.PluginFindPackageByIdResourceProvider" /> class.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.PluginFindPackageByIdResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository,System.Threading.CancellationToken)">
      <summary>
            Asynchronously attempts to create a resource for the specified source repository.
            </summary>
      <param name="source">A source repository.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a Tuple&lt;bool, INuGetResource&gt;</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="source" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.RemoteV2FindPackageByIdResource">
      <summary>
            A resource capable of fetching packages, package versions and package dependency information.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.RemoteV2FindPackageByIdResource.#ctor(NuGet.Configuration.PackageSource,NuGet.Protocol.HttpSource)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.RemoteV2FindPackageByIdResource" /> class.
            </summary>
      <param name="packageSource">A package source.</param>
      <param name="httpSource">An HTTP source.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageSource" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="httpSource" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.RemoteV2FindPackageByIdResource.GetAllVersionsAsync(System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets all package versions for a package ID.
            </summary>
      <param name="id">A package ID.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.RemoteV2FindPackageByIdResource.GetDependencyInfoAsync(System.String,NuGet.Versioning.NuGetVersion,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets dependency information for a specific package.
            </summary>
      <param name="id">A package id.</param>
      <param name="version">A package version.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.RemoteV2FindPackageByIdResource.CopyNupkgToStreamAsync(System.String,NuGet.Versioning.NuGetVersion,System.IO.Stream,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies a .nupkg to a stream.
            </summary>
      <param name="id">A package ID.</param>
      <param name="version">A package version.</param>
      <param name="destination">A destination stream.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Boolean" /> indicating whether or not the .nupkg file was copied.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="destination" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.RemoteV2FindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package downloader for a package identity.
            </summary>
      <param name="packageIdentity">A package identity.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an <see cref="T:NuGet.Packaging.IPackageDownloader" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageIdentity" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="P:NuGet.Protocol.RemoteV2FindPackageByIdResource.PackageSource">
      <summary>
            Gets the package source.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.RemoteV2FindPackageByIdResourceProvider">
      <summary>
            A <see cref="T:NuGet.Protocol.Core.Types.ResourceProvider" /> for <see cref="T:NuGet.Protocol.Core.Types.FindPackageByIdResource" /> over v2 NuGet feeds.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.RemoteV3FindPackageByIdResource">
      <summary>
            A resource capable of fetching packages, package versions and package dependency information.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.RemoteV3FindPackageByIdResource.#ctor(NuGet.Protocol.Core.Types.SourceRepository,NuGet.Protocol.HttpSource)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.RemoteV3FindPackageByIdResource" /> class.
            </summary>
      <param name="sourceRepository">A source repository.</param>
      <param name="httpSource">An HTTP source.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="sourceRepository" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="httpSource" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.RemoteV3FindPackageByIdResource.GetAllVersionsAsync(System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets all package versions for a package ID.
            </summary>
      <param name="id">A package ID.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.RemoteV3FindPackageByIdResource.GetDependencyInfoAsync(System.String,NuGet.Versioning.NuGetVersion,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets dependency information for a specific package.
            </summary>
      <param name="id">A package id.</param>
      <param name="version">A package version.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.RemoteV3FindPackageByIdResource.CopyNupkgToStreamAsync(System.String,NuGet.Versioning.NuGetVersion,System.IO.Stream,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies a .nupkg to a stream.
            </summary>
      <param name="id">A package ID.</param>
      <param name="version">A package version.</param>
      <param name="destination">A destination stream.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Boolean" /> indicating whether or not the .nupkg file was copied.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="destination" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.RemoteV3FindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package downloader for a package identity.
            </summary>
      <param name="packageIdentity">A package identity.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an <see cref="T:NuGet.Packaging.IPackageDownloader" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageIdentity" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="P:NuGet.Protocol.RemoteV3FindPackageByIdResource.SourceRepository">
      <summary>
            Gets the source repository.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.DependencyInfoResourceV3">
      <summary>
            Retrieves all packages and dependencies from a V3 source.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DependencyInfoResourceV3.#ctor(NuGet.Protocol.HttpSource,NuGet.Protocol.RegistrationResourceV3,NuGet.Protocol.Core.Types.SourceRepository)">
      <summary>
            Dependency info resource
            </summary>
      <param name="client">Http client</param>
      <param name="regResource">Registration blob resource</param>
    </member>
    <member name="M:NuGet.Protocol.DependencyInfoResourceV3.ResolvePackage(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve dependency info for a single package.
            </summary>
      <param name="package">package id and version</param>
      <param name="projectFramework">project target framework. This is used for finding the dependency group</param>
      <param name="token">cancellation token</param>
      <returns>
            Returns dependency info for the given package if it exists. If the package is not found null is
            returned.
            </returns>
    </member>
    <member name="M:NuGet.Protocol.DependencyInfoResourceV3.ResolvePackages(System.String,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve the available packages and their dependencies.
            </summary>
      <remarks>Includes prerelease packages</remarks>
      <param name="packageId">package Id to search</param>
      <param name="projectFramework">project target framework. This is used for finding the dependency group</param>
      <param name="token">cancellation token</param>
      <returns>available packages and their dependencies</returns>
    </member>
    <member name="M:NuGet.Protocol.DependencyInfoResourceV3.ResolvePackages(System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve the available packages and their dependencies.
            </summary>
      <remarks>Includes prerelease packages</remarks>
      <param name="packageId">package Id to search</param>
      <param name="token">cancellation token</param>
      <returns>available packages and their dependencies</returns>
    </member>
    <member name="M:NuGet.Protocol.DependencyInfoResourceV3.GetPackagesFromRegistration(NuGet.Protocol.RegistrationInfo,System.Threading.CancellationToken)">
      <summary>
            Retrieve dependency info from a registration blob
            </summary>
    </member>
    <member name="T:NuGet.Protocol.DownloadResourcePlugin">
      <summary>
            A download resource for plugins.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DownloadResourcePlugin.#ctor(NuGet.Protocol.Plugins.IPlugin,NuGet.Protocol.Plugins.IPluginMulticlientUtilities,NuGet.Configuration.PackageSource)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.DownloadResourcePlugin" /> class.
            </summary>
      <param name="plugin">A plugin.</param>
      <param name="utilities">A plugin multiclient utilities.</param>
      <param name="packageSource">A package source.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="plugin" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="utilities" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageSource" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.DownloadResourcePlugin.GetDownloadResourceResultAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.PackageDownloadContext,System.String,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously downloads a package.
            </summary>
      <param name="identity">The package identity.</param>
      <param name="downloadContext">A package download context.</param>
      <param name="globalPackagesFolder">The path to the global packages folder.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns
            a <see cref="T:NuGet.Protocol.Core.Types.DownloadResourceResult" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="identity" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="downloadContext" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.DownloadResourceV3">
      <summary>
            Provides the download metatdata for a given package from a V3 server endpoint.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DownloadResourceV3.#ctor(NuGet.Protocol.HttpSource,NuGet.Protocol.RegistrationResourceV3)">
      <summary>
            Download packages using the download url found in the registration resource.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DownloadResourceV3.#ctor(NuGet.Protocol.HttpSource,System.String)">
      <summary>
            Download packages using the package base address container resource.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.DownloadResourceV3.GetDownloadUrl(NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Get the download url of the package.
            1. If the identity is a SourcePackageDependencyInfo the SourcePackageDependencyInfo.DownloadUri is used.
            2. A url will be constructed for the flat container location if the source has that resource.
            3. The download url will be found in the registration blob as a fallback.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.MetadataResourceV3">
      <summary>
            Returns the full package metadata
            </summary>
    </member>
    <member name="M:NuGet.Protocol.MetadataResourceV3.GetLatestVersions(System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Find the latest version of the package
            </summary>
      <param name="includePrerelease">include versions with prerelease labels</param>
      <param name="includeUnlisted">not implemented yet</param>
    </member>
    <member name="T:NuGet.Protocol.RegistrationResourceV3">
      <summary>
            Registration blob reader
            </summary>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetUri(System.String)">
      <summary>
            Constructs the URI of a registration index blob
            </summary>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetUri(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Constructs the URI of a registration blob with a specific version
            </summary>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetUri(NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            Constructs the URI of a registration blob with a specific version
            </summary>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetPackageMetadata(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Returns the registration blob for the id and version
            </summary>
      <remarks>The inlined entries are potentially going away soon</remarks>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetPackageMetadata(System.String,System.Boolean,System.Boolean,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Returns inlined catalog entry items for each registration blob
            </summary>
      <remarks>The inlined entries are potentially going away soon</remarks>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetPackageMetadata(System.String,NuGet.Versioning.VersionRange,System.Boolean,System.Boolean,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Returns inlined catalog entry items for each registration blob
            </summary>
      <remarks>The inlined entries are potentially going away soon</remarks>
    </member>
    <member name="M:NuGet.Protocol.RegistrationResourceV3.GetPackageEntries(System.String,System.Boolean,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Returns all index entries of type Package within the given range and filters
            </summary>
    </member>
    <member name="P:NuGet.Protocol.RegistrationResourceV3.BaseUri">
      <summary>
            Gets the <see cref="T:System.Uri" /> for the source backing this resource.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ReportAbuseResourceV3.GetReportAbuseUrl(System.String,NuGet.Versioning.NuGetVersion)">
      <summary>
            Gets a URL for reporting package abuse. The URL will not be verified to exist.
            </summary>
      <param name="id">The package id (natural casing)</param>
      <param name="version">The package version</param>
      <returns>The first URL from the resource, with the URI template applied.</returns>
    </member>
    <member name="T:NuGet.Protocol.ServiceIndexResourceV3">
      <summary>
            Stores/caches a service index json file.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntries(System.String[])">
      <summary>
            Get the list of service entries that best match the current clientVersion and type.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntries(NuGet.Versioning.NuGetVersion,System.String[])">
      <summary>
            Get the list of service entries that best match the clientVersion and type.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntryUri(System.String[])">
      <summary>
            Get the best match service URI.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntryUris(System.String[])">
      <summary>
            Get the list of service URIs that best match the current clientVersion and type.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ServiceIndexResourceV3.GetServiceEntryUris(NuGet.Versioning.NuGetVersion,System.String[])">
      <summary>
            Get the list of service URIs that best match the clientVersion and type.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.ServiceIndexResourceV3.GetValues(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Read string values from an array or string.
            Returns an empty enumerable if the value is null.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ServiceIndexResourceV3.RequestTime">
      <summary>
            Time the index was requested
            </summary>
    </member>
    <member name="P:NuGet.Protocol.ServiceIndexResourceV3.Entries">
      <summary>
            All service index entries.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Strings">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.ActionExecutor_RollingBack">
      <summary>
              Looks up a localized string similar to Install failed. Rolling back....
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.ActionResolver_UnsupportedAction">
      <summary>
              Looks up a localized string similar to Unrecognized Package Action '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.ActionResolver_UnsupportedDependencyBehavior">
      <summary>
              Looks up a localized string similar to Unsupported Dependency Behavior '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.AddPackage_ExistingPackageInvalid">
      <summary>
              Looks up a localized string similar to Package '{0}' already exists at feed '{1}' and is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.AddPackage_PackageAlreadyExists">
      <summary>
              Looks up a localized string similar to Package '{0}' already exists at feed '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.AddPackage_SuccessfullyAdded">
      <summary>
              Looks up a localized string similar to Successfully added package '{0}' to feed '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Argument_Cannot_Be_Null_Or_Empty">
      <summary>
              Looks up a localized string similar to Argument can not be null or empty..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.ArgumentCannotBeNullOrEmpty">
      <summary>
              Looks up a localized string similar to Argument cannot be null or empty..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DefaultSymbolServer">
      <summary>
              Looks up a localized string similar to the symbol server.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DeleteCommandCanceled">
      <summary>
              Looks up a localized string similar to Delete canceled.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DeleteCommandConfirm">
      <summary>
              Looks up a localized string similar to {0} {1} will be deleted from the {2}. Would you like to continue?.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DeleteCommandDeletedPackage">
      <summary>
              Looks up a localized string similar to {0} {1} was deleted successfully..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DeleteCommandDeletingPackage">
      <summary>
              Looks up a localized string similar to Deleting {0} {1} from the {2}..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DeletePackage_NotFound">
      <summary>
              Looks up a localized string similar to Not Found..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DownloadActionHandler_InvalidDownloadUrl">
      <summary>
              Looks up a localized string similar to The download URL for {0} '{1}' is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.DownloadActionHandler_NoDownloadUrl">
      <summary>
              Looks up a localized string similar to No download URL could be found for {0}..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Error_DownloadTimeout">
      <summary>
              Looks up a localized string similar to The download of '{0}' timed out because no data was received for {1}ms..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Http_CredentialsForForbidden">
      <summary>
              Looks up a localized string similar to The server responded with HTTP '403 Forbidden' when accessing the source '{0}'. This suggests that the server has authenticated your identity but has not permitted you to access the requested resource. Provide credentials that have permissions to view this resource..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Http_CredentialsForProxy">
      <summary>
              Looks up a localized string similar to The server responded with HTTP '407 Proxy Authentication Required' when accessing the proxy '{0}'. This suggests that the server needs credentials to authenticate your identity to use a proxy. Provide credentials to access this resource..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Http_CredentialsForUnauthorized">
      <summary>
              Looks up a localized string similar to The server responded with HTTP '401 Unauthorized' when accessing the source '{0}'. This suggests that the server needs credentials to authenticate your identity. Provide credentials to access this resource..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Http_RequestLog">
      <summary>
              Looks up a localized string similar to {0} {1}.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Http_ResponseLog">
      <summary>
              Looks up a localized string similar to {0} {1} {2}ms.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Http_Timeout">
      <summary>
              Looks up a localized string similar to The HTTP request to '{0} {1}' has timed out after {2}ms..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.InvalidVersionFolder">
      <summary>
              Looks up a localized string similar to The folder '{0}' contains an invalid version..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.LiveFeed">
      <summary>
              Looks up a localized string similar to the NuGet gallery.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_CanceledNupkgDownload">
      <summary>
              Looks up a localized string similar to Downloading a package from '{0}' was canceled..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_ErrorDownloading">
      <summary>
              Looks up a localized string similar to Error downloading '{0}' from '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToDownloadPackage">
      <summary>
              Looks up a localized string similar to Failed to download package '{0}' from '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToFetchV2Feed">
      <summary>
              Looks up a localized string similar to The V2 feed at '{0}' returned an unexpected status code '{1} {2}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToFetchV2FeedHttp">
      <summary>
              Looks up a localized string similar to Failed to fetch results from V2 feed at '{0}' with following message : {1}.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToGetNuspecStream">
      <summary>
              Looks up a localized string similar to Unable to load nuspec from package '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToParseRepoSignInfor">
      <summary>
              Looks up a localized string similar to Unable to parse {0} information from {1}. .
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToReadRepositorySignature">
      <summary>
              Looks up a localized string similar to Unable to get repository signature information for source {0}..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToReadServiceIndex">
      <summary>
              Looks up a localized string similar to Unable to load the service index for source {0}..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToRetrievePackage">
      <summary>
              Looks up a localized string similar to Failed to retrieve information about '{0}' from remote source '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToVerifyRootDirectory">
      <summary>
              Looks up a localized string similar to Failed to verify the root directory of local source '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FailedToVerifyValidFile">
      <summary>
              Looks up a localized string similar to Failed to validate the file '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_FileIsCorrupt">
      <summary>
              Looks up a localized string similar to The file '{0}' is corrupt..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_InvalidCacheEntry">
      <summary>
              Looks up a localized string similar to An invalid cache entry was found for URL '{0}' and will be replaced..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_InvalidNupkgFromUrl">
      <summary>
              Looks up a localized string similar to The nupkg at '{0}' is not valid..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_LocalSourceNotExist">
      <summary>
              Looks up a localized string similar to The local source '{0}' doesn't exist..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_RetryingFindPackagesById">
      <summary>
              Looks up a localized string similar to Retrying '{0}' for source '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_RetryingHttp">
      <summary>
              Looks up a localized string similar to An error was encountered when fetching '{0} {1}'. The request will now be retried..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_RetryingRepositorySignature">
      <summary>
              Looks up a localized string similar to Retrying repository signature request for source '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Log_RetryingServiceIndex">
      <summary>
              Looks up a localized string similar to Retrying service index request for source '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.NoApiKeyFound">
      <summary>
              Looks up a localized string similar to No API Key was provided and no API Key could be found for {0}. To save an API Key for a source use the 'setApiKey' command..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.NuGetRepository_CannotCreateAggregateRepo">
      <summary>
              Looks up a localized string similar to Cannot create a NuGet Repository from the Aggregate Source.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.NuGetServiceProvider_ServiceNotSupported">
      <summary>
              Looks up a localized string similar to The {0} service is not supported by this object..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.NupkgPath_Invalid">
      <summary>
              Looks up a localized string similar to '{0}' is not a valid nupkg file..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.NupkgPath_InvalidEx">
      <summary>
              Looks up a localized string similar to '{0}' is not a valid nupkg file. Error: '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.OneOrMoreUrisMustBeSpecified">
      <summary>
              Looks up a localized string similar to One or more URIs must be specified..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.PackageActionDescriptionWrapper_UnrecognizedAction">
      <summary>
              Looks up a localized string similar to Unrecognized Package Action '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.PackageNotFound">
      <summary>
              Looks up a localized string similar to Unable to find package '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.PackageServerEndpoint_NotSupported">
      <summary>
              Looks up a localized string similar to ERROR: This version of nuget.exe does not support updating packages to package source '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Path_Invalid">
      <summary>
              Looks up a localized string similar to '{0}' is not a valid path..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Path_Invalid_NotFileNotUnc">
      <summary>
              Looks up a localized string similar to '{0}' should be a local path or a UNC share path..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_ConnectionAlreadyStarted">
      <summary>
              Looks up a localized string similar to A connection has already been started..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_ConnectionIsClosed">
      <summary>
              Looks up a localized string similar to The plugin connection is closed..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_Exception">
      <summary>
              Looks up a localized string similar to Plugin '{0}' failed with the exception:  {1}.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_FailedOperationForPackage">
      <summary>
              Looks up a localized string similar to Plugin '{0}' failed a {1} operation for package {2}.{3}..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_FailedToQueryPluginOperationsClaims">
      <summary>
              Looks up a localized string similar to A failure occurred while attempting to query plugin operation claims for the plugin at '{0}'.  Exception:  {1}.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_FailureQueryingPackageVersions">
      <summary>
              Looks up a localized string similar to A failure occurred while attempting to query package versions for package '{0}' using the plugin at '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_Fault">
      <summary>
              Looks up a localized string similar to Terminating plugin '{0}' due to an unrecoverable fault:  {1}.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_FileNotFound">
      <summary>
              Looks up a localized string similar to A plugin was not found at path '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_HandshakeFailed">
      <summary>
              Looks up a localized string similar to The plugin handshake failed..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_HandshakeRequestHandlerAlreadyExists">
      <summary>
              Looks up a localized string similar to A handshake request handler already exists..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_IdleTimeoutMustBeGreaterThanOrEqualToInfiniteTimeSpan">
      <summary>
              Looks up a localized string similar to The idle timeout must be greater than or equal to System.Threading.Timeout.InfiniteTimeSpan..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_IllegalMessageWhileHandshaking">
      <summary>
              Looks up a localized string similar to An illegal message type was received during handshake..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_InitializationFailed">
      <summary>
              Looks up a localized string similar to Plugin initialization failed..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_InvalidEmbeddedSignature">
      <summary>
              Looks up a localized string similar to The plugin at '{0}' did not have a valid embedded signature..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_InvalidMessageType">
      <summary>
              Looks up a localized string similar to The message type '{0}' is invalid at this time..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_InvalidPluginFilePath">
      <summary>
              Looks up a localized string similar to The plugin file path '{0}' is invalid..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_NotConnected">
      <summary>
              Looks up a localized string similar to A plugin is not connected..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_PackageDownloadFailed">
      <summary>
              Looks up a localized string similar to Plugin '{0}' failed to download package '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_ProtocolException">
      <summary>
              Looks up a localized string similar to A plugin protocol exception occurred..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_ProtocolVersionNotSupportedOnError">
      <summary>
              Looks up a localized string similar to A protocol version is not supported on error..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_ProtocolVersionOutOfRange">
      <summary>
              Looks up a localized string similar to '{0}' must be greater than or equal to '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_RequestContextDoesNotExist">
      <summary>
              Looks up a localized string similar to Request context does not exist for request ID '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_RequestHandlerDoesNotExist">
      <summary>
              Looks up a localized string similar to A request handler does not exist for the message method '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_TimeoutOutOfRange">
      <summary>
              Looks up a localized string similar to Timeout must be greater than TimeSpan.Zero and less than or equal to TimeSpan.FromMilliseconds(int.MaxValue)..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_UnrecognizedEnumValue">
      <summary>
              Looks up a localized string similar to The enum value '{0}' is unrecognized..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Plugin_UnrecognizedOperationClaims">
      <summary>
              Looks up a localized string similar to The operation claims are unrecognized:  {0}..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.ProjectInstallationTarget_ProjectIsNotTargetted">
      <summary>
              Looks up a localized string similar to The project '{0}' is not one of the projects targetted by this object..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_BadSource">
      <summary>
              Looks up a localized string similar to Failed to retrieve metadata from source '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_duplicateUri">
      <summary>
              Looks up a localized string similar to '{0}' is a duplicate url which has already been downloaded and will lead to a cyclic dependency. Please correct from server..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_FlatContainerIndexVersionsNotArray">
      <summary>
              Looks up a localized string similar to The 'versions' property at '{0}' must be an array..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_IndexMissingResourcesNode">
      <summary>
              Looks up a localized string similar to Service index document is missing the 'resources' property..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_InvalidJsonObject">
      <summary>
              Looks up a localized string similar to The content at '{0}' is not a valid JSON object..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_InvalidServiceIndex">
      <summary>
              Looks up a localized string similar to The source does not have the 'version' property at '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_InvalidXml">
      <summary>
              Looks up a localized string similar to The content at '{0}' is not valid XML..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_MalformedMetadataError">
      <summary>
              Looks up a localized string similar to Metadata could not be loaded from the source '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_MissingRegistrationBase">
      <summary>
              Looks up a localized string similar to The source does not have a Registration Base Url defined!.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_MissingSearchService">
      <summary>
              Looks up a localized string similar to The source does not have a Search service!.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_MissingVersion">
      <summary>
              Looks up a localized string similar to The source does not have the 'version' property..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_PackageMetadataError">
      <summary>
              Looks up a localized string similar to An error occurred while retrieving package metadata for '{0}' from source '{1}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_Search_LocalSourceNotFound">
      <summary>
              Looks up a localized string similar to The path '{0}' for the selected source could not be resolved..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Protocol_UnsupportedVersion">
      <summary>
              Looks up a localized string similar to The source version is not supported: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.PushCommandPackagePushed">
      <summary>
              Looks up a localized string similar to Your package was pushed..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.PushCommandPushingPackage">
      <summary>
              Looks up a localized string similar to Pushing {0} to {1}....
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.RepositoryContentUrlMustBeHttps">
      <summary>
              Looks up a localized string similar to Repository content URL for repository signatures must be HTTPS..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.RequiredFeatureUnsupportedException_DefaultMessageWithFeature">
      <summary>
              Looks up a localized string similar to The '{0}' installation feature was required by a package but is not supported on the current host..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.RequiredFeatureUnsupportedException_DefaultMessageWithoutFeature">
      <summary>
              Looks up a localized string similar to The installation host does not support a feature required by this package..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.UnableToFindFile">
      <summary>
              Looks up a localized string similar to File does not exist ({0})..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.UnableToParseFolderV3Version">
      <summary>
              Looks up a localized string similar to Unable to parse a valid version from a v3 folder: '{0}'..
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.v2sourceDescription">
      <summary>
              Looks up a localized string similar to API v2 (legacy).
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.v3sourceDescription">
      <summary>
              Looks up a localized string similar to API v3.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Strings.Warning_SymbolServerNotConfigured">
      <summary>
              Looks up a localized string similar to Found symbols package '{0}', but no API key was specified for the symbol server. To save an API Key, run 'NuGet.exe setApiKey [your API key from http://www.NuGet.org]'..
            </summary>
    </member>
    <member name="M:NuGet.Protocol.CachingUtility.ComputeHash(System.String)">
      <summary>
            Given a string, it hashes said string and appends identifiable characters to make the root of the cache more human readable
            </summary>
      <param name="value">
      </param>
      <returns>hash</returns>
    </member>
    <member name="M:NuGet.Protocol.FeedTypeUtility.GetFeedType(NuGet.Configuration.PackageSource)">
      <summary>
            Determine the type of a nuget source. This works for both offline and online sources.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.FindPackagesByIdNupkgDownloader.GetNuspecReaderFromNupkgAsync(NuGet.Packaging.Core.PackageIdentity,System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Gets a <see cref="T:NuGet.Packaging.NuspecReader" /> from a .nupkg. If the URL cannot be fetched or there is a problem
            processing the .nuspec, an exception is throw. This method uses HTTP caching to avoid downloading the
            package over and over (unless <see cref="P:NuGet.Protocol.Core.Types.SourceCacheContext.DirectDownload" /> is specified).
            </summary>
      <param name="identity">The package identity.</param>
      <param name="url">The URL of the .nupkg.</param>
      <param name="cacheContext">The cache context.</param>
      <param name="token">The cancellation token.</param>
      <returns>The .nuspec reader.</returns>
    </member>
    <member name="M:NuGet.Protocol.FindPackagesByIdNupkgDownloader.CopyNupkgToStreamAsync(NuGet.Packaging.Core.PackageIdentity,System.String,System.IO.Stream,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Copies a .nupkg stream to the <paramref name="destination" /> stream. If the .nupkg cannot be found or if
            there is a network problem, no stream copy occurs.
            </summary>
      <param name="identity">The package identity.</param>
      <param name="url">The URL of the .nupkg.</param>
      <param name="destination">The destination stream. The .nupkg will be copied to this stream.</param>
      <param name="cacheContext">The cache context.</param>
      <param name="token">The cancellation token.</param>
      <returns>Returns true if the stream was copied, false otherwise.</returns>
    </member>
    <member name="M:NuGet.Protocol.FindPackagesByIdNupkgDownloader.ProcessNupkgStreamAsync(NuGet.Packaging.Core.PackageIdentity,System.String,System.Func{System.IO.Stream,System.Threading.Tasks.Task},NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Manages the different ways of getting a .nupkg stream when using the global HTTP cache. When a stream is
            found, the <paramref name="processStreamAsync" /> method is invoked on said stream. This deals with the
            complexity of <see cref="P:NuGet.Protocol.Core.Types.SourceCacheContext.DirectDownload" />.
            </summary>
      <param name="identity">The package identity.</param>
      <param name="url">The URL of the .nupkg to fetch.</param>
      <param name="processStreamAsync">The method to process the stream.</param>
      <param name="cacheContext">The cache context.</param>
      <param name="token">The cancellation token.</param>
      <returns>
            Returns true if the stream was processed, false if the stream could not fetched (either from the HTTP cache
            or from the network).
            </returns>
    </member>
    <member name="M:NuGet.Protocol.GetDownloadResultUtility.CleanUpDirectDownloads(NuGet.Protocol.Core.Types.PackageDownloadContext)">
      <summary>
            Allow explicit clean-up of direct download files. This is important because although direct downloads are
            opened with the <see cref="F:System.IO.FileOptions.DeleteOnClose" /> option, some systems (e.g. Linux) do not perform
            the delete if the process dies. Additionally, if the system dies before the process dies (e.g. loss of
            power), the direct download files will be left over.
            </summary>
      <param name="downloadContext">The download context.</param>
    </member>
    <member name="F:NuGet.Protocol.JsonUtility.DefaultLoadSettings">
      <summary>
            JsonLoadSettings with line info and comments ignored.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.JsonUtility.LoadJson(System.IO.TextReader)">
      <summary>
            Load json from a file to a JObject using the default load settings.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.JsonUtility.LoadJson(Newtonsoft.Json.JsonReader)">
      <summary>
            Load json from a file to a JObject using the default load settings.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackage(System.Uri,NuGet.Common.ILogger)">
      <summary>
            Retrieve a nupkg using the path.
            </summary>
      <param name="path">Nupkg path in uri form.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesV2(System.String,NuGet.Common.ILogger)">
      <summary>
            Retrieve all packages from a folder and one level deep.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesV2(System.String,System.String,NuGet.Common.ILogger)">
      <summary>
            Retrieve all packages of an id from a v2 folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
      <param name="id">Package id.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackageV2(System.String,System.String,NuGet.Versioning.NuGetVersion,NuGet.Common.ILogger)">
      <summary>
            Retrieve all packages of an id from a v2 folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
      <param name="id">Package id.</param>
      <param name="version">Package version.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackageV2(System.String,NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger)">
      <summary>
            Retrieve all packages of an id from a v2 folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
      <param name="identity">Package id and version.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackages(System.String,NuGet.Common.ILogger)">
      <summary>
            Retrieve a package with an id and version from a packages.config packages folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackages(System.String,System.String,NuGet.Common.ILogger)">
      <summary>
            Retrieve a package with an id and version from a packages.config packages folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackage(System.String,NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger)">
      <summary>
            Retrieve a package with an id and version from a packages.config packages folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
      <param name="identity">Package id and version.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderSearchPattern(System.String)">
      <summary>
            Returns either id.* or * depending on the OS.
            </summary>
      <param name="id">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackage(System.String,System.String,NuGet.Versioning.NuGetVersion,NuGet.Common.ILogger)">
      <summary>
            Retrieve a package with an id and version from a packages.config packages folder.
            </summary>
      <param name="root">Nupkg folder directory path.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesConfigFolderPackage(System.IO.DirectoryInfo,NuGet.Common.ILogger)">
      <summary>
            Return the package nupkg from a packages.config folder sub directory.
            </summary>
      <param name="dir">Package directory in the format id.version</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.IsPossiblePackageMatch(System.IO.FileInfo,NuGet.Packaging.Core.PackageIdentity)">
      <summary>
            True if the file name matches the identity. This is could be incorrect if
            the package name ends with numbers. The result should be checked against the nuspec.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.IsPossiblePackageMatch(System.IO.FileInfo,System.String)">
      <summary>
            True if the file name matches the id and is followed by a version. This is could be incorrect if
            the package name ends with numbers. The result should be checked against the nuspec.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetIdentityFromNupkgPath(System.IO.FileInfo,System.String)">
      <summary>
            An imperfect attempt at finding the identity of a package from the file name.
            This can fail if the package name ends with something such as .1
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetVersionFromFileName(System.String,System.String,System.String)">
      <summary>
            An imperfect attempt at finding the version of a package from the file name.
            This can fail if the package name ends with something such as .1
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetVersionFromIdVersionString(System.String,System.String)">
      <summary>
            Parse a possible version from a string in the format Id.Version
            Returns null if the version is invalid or the id did not match.
            </summary>
      <param name="idVersionString">Id.Version</param>
      <param name="id">Expected id</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackageV3(System.String,System.String,NuGet.Versioning.NuGetVersion,NuGet.Common.ILogger)">
      <summary>
            Retrieve a single package from a v3 version folder.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackageV3(System.String,NuGet.Packaging.Core.PackageIdentity,NuGet.Common.ILogger)">
      <summary>
            Retrieve a package from a v3 feed.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetNupkgsFromFlatFolder(System.String,NuGet.Common.ILogger)">
      <summary>
            Discover all nupkgs from a v2 local folder.
            </summary>
      <param name="root">Folder root.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetAndVerifyRootDirectory(System.String)">
      <summary>
            Verify that a path could be a valid directory. Throw a FatalProtocolException otherwise.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetAndVerifyFileInfo(System.Uri)">
      <summary>
            Verify that a path could be a valid file. Throw a FatalProtocolException otherwise.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetNupkgsFromFlatFolderChunked(System.IO.DirectoryInfo,NuGet.Common.ILogger)">
      <summary>
            Retrieve files in chunks, this helps maintain the legacy behavior of searching for
            certain non-normalized file names.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetNupkgsFromFlatFolder(System.String,System.String,NuGet.Common.ILogger)">
      <summary>
            Discover nupkgs from a v2 local folder.
            </summary>
      <param name="root">Folder root.</param>
      <param name="id">Package id file name prefix.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesV3(System.String,NuGet.Common.ILogger)">
      <summary>
            Discover all nupkgs from a v3 folder.
            </summary>
      <param name="root">Folder root.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesV3(System.String,System.String,NuGet.Common.ILogger)">
      <summary>
            Discover nupkgs from a v3 local folder.
            </summary>
      <param name="root">Folder root.</param>
      <param name="id">Package id or package id prefix.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.ResolvePackageFromPath(System.String)">
      <summary>
            Resolves a package path into a list of paths.
            If the path contains wildcards then the path is expanded to all matching entries.
            </summary>
      <param name="packagePath">Package path</param>
      <returns>A list of package paths that match the input path.</returns>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.EnsurePackageFileExists(System.String,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            This method checks of a given list of package paths exist on disk.
            </summary>
      <param name="packagePath">A package path to be used while creating logs.</param>
      <param name="matchingPackagePaths">A list of matching package paths that need to be checked.</param>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetDistinctPackages(System.Collections.Generic.IEnumerable{NuGet.Protocol.LocalPackageInfo})">
      <summary>
            Remove duplicate packages which can occur in directories.
            In V2 packages may exist under multiple sub folders. 
            Non-normalized versions also lead to duplicates: ex: 1.0, 1.0.0.0
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetDirectoriesSafe(System.IO.DirectoryInfo,NuGet.Common.ILogger)">
      <summary>
            Retrieve directories and log exceptions that occur.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetFilesSafe(System.IO.DirectoryInfo,System.String,NuGet.Common.ILogger)">
      <summary>
            Retrieve files and log exceptions that occur.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackagesFromNupkgs(System.Collections.Generic.IEnumerable{System.IO.FileInfo})">
      <summary>
            Path -&gt; LocalPackageInfo
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetPackageFromNupkg(System.IO.FileInfo)">
      <summary>
            Path -&gt; LocalPackageInfo
            </summary>
    </member>
    <member name="M:NuGet.Protocol.LocalFolderUtility.GetNupkgsFromDirectory(System.IO.DirectoryInfo,NuGet.Common.ILogger)">
      <summary>
            Find all nupkgs in the top level of a directory.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.MetadataReferenceCache">
      <summary>
            Cache strings, dates, and versions to reduce memory.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.MetadataReferenceCache.CachableTypesMap">
      <summary>
            Mapping of input parameter type to caching method.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.MetadataReferenceCache.GetString(System.String)">
      <summary>
            Checks if <paramref name="s" /> already exists in the cache.
            If so, returns the cached instance.
            If not, caches <paramref name="s" /> and returns it.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.MetadataReferenceCache.GetVersion(System.String)">
      <summary>
            Parses <paramref name="s" /> into a <see cref="T:NuGet.Versioning.NuGetVersion" />.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.MetadataReferenceCache.GetObject``1(``0)">
      <summary>
            Iterates through the properties of <paramref name="input" /> that are either <see cref="T:System.String" />s, <see cref="T:System.DateTimeOffset" />s, or <see cref="T:NuGet.Versioning.NuGetVersion" />s and checks them against the cache.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.MetadataReferenceCache.CachableTypes">
      <summary>
        <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing all types that can be cached.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.StreamExtensions.AsSeekableStreamAsync(System.IO.Stream)">
      <summary>
            Read a stream into a memory stream if CanSeek is false.
            This method is used to ensure that network streams
            can be read by non-async reads without hanging.
            
            Closes the original stream by default.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.StreamExtensions.AsSeekableStreamAsync(System.IO.Stream,System.Boolean)">
      <summary>
            Read a stream into a memory stream if CanSeek is false.
            This method is used to ensure that network streams
            can be read by non-async reads without hanging.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.TimeoutUtility.StartWithTimeout``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}},System.TimeSpan,System.String,System.Threading.CancellationToken)">
      <summary>
            Starts a task with a timeout. If the timeout occurs, a <see cref="T:System.TimeoutException" />
            with no message will be thrown.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.TimeoutUtility.StartWithTimeout(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.TimeSpan,System.String,System.Threading.CancellationToken)">
      <summary>
            Starts a task with a timeout. If the timeout occurs, a <see cref="T:System.TimeoutException" />
            with no message will be thrown.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.AutomaticProgressReporter">
      <summary>
            An automatic progress reporter.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.AutomaticProgressReporter.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.AutomaticProgressReporter.Create(NuGet.Protocol.Plugins.IConnection,NuGet.Protocol.Plugins.Message,System.TimeSpan,System.Threading.CancellationToken)">
      <summary>
            Creates a new <see cref="T:NuGet.Protocol.Plugins.AutomaticProgressReporter" /> class.
            </summary>
      <remarks>This class does not take ownership of and dispose of <paramref name="connection" />.</remarks>
      <param name="connection">A connection.</param>
      <param name="request">A request.</param>
      <param name="interval">A progress interval.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="connection" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="interval" />
            is either less than <see cref="F:NuGet.Protocol.Plugins.ProtocolConstants.MinTimeout" /> or greater than
            <see cref="F:NuGet.Protocol.Plugins.ProtocolConstants.MaxTimeout" />.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.Connection">
      <summary>
            Represents a bidirectional channel between a NuGet client and a plugin.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Connection.#ctor(NuGet.Protocol.Plugins.IMessageDispatcher,NuGet.Protocol.Plugins.ISender,NuGet.Protocol.Plugins.IReceiver,NuGet.Protocol.Plugins.ConnectionOptions)">
      <summary>
            Instantiates a new instance of the <see cref="T:NuGet.Protocol.Plugins.Connection" /> class.
            </summary>
      <param name="dispatcher">A message dispatcher.</param>
      <param name="sender">A sender.</param>
      <param name="receiver">A receiver.</param>
      <param name="options">Connection options.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="dispatcher" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="sender" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="receiver" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="options" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Connection.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Connection.Close">
      <summary>
            Closes the connection.
            </summary>
      <remarks>This does not call <see cref="M:System.IDisposable.Dispose" />.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Connection.ConnectAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously connects and handshakes with a remote target.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if the method has been called already.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Connection.SendAsync(NuGet.Protocol.Plugins.Message,System.Threading.CancellationToken)">
      <summary>
            Asynchronously sends a message to the remote target.
            </summary>
      <param name="message">The message to be sent.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="message" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if not connected.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Connection.SendRequestAndReceiveResponseAsync``2(NuGet.Protocol.Plugins.MessageMethod,``0,System.Threading.CancellationToken)">
      <summary>
            Asynchronously sends a message to the remote target and receives the target's response.
            </summary>
      <typeparam name="TOutbound">The outbound payload type.</typeparam>
      <typeparam name="TInbound">The inbound payload type.</typeparam>
      <param name="method">The outbound message method.</param>
      <param name="payload">The outbound message payload.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <typeparamref name="TInbound" />
            from the target.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if not connected.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Connection.State">
      <summary>
            The connection state.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Connection.MessageDispatcher">
      <summary>
            Gets the message dispatcher.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Connection.Options">
      <summary>
            Gets the connection options
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Connection.ProtocolVersion">
      <summary>
            Gets the negotiated protocol version, or <c>null</c> if not yet connected.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.Connection.Faulted">
      <summary>
            Occurs when an unrecoverable fault has been caught.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.Connection.MessageReceived">
      <summary>
            Occurs when a message has been received.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.ConnectionOptions">
      <summary>
            Plugin connection options.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.ConnectionOptions.#ctor(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion,System.TimeSpan,System.TimeSpan)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.ConnectionOptions" /> class.
            </summary>
      <param name="protocolVersion">The plugin protocol version.</param>
      <param name="minimumProtocolVersion">The minimum plugin protocol version.</param>
      <param name="handshakeTimeout">The plugin handshake timeout.</param>
      <param name="requestTimeout">The plugin request timeout.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="protocolVersion" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="minimumProtocolVersion" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="protocolVersion" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="protocolVersion" />
            is less than <paramref name="minimumProtocolVersion" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="handshakeTimeout" />
            is either less than <see cref="F:NuGet.Protocol.Plugins.ProtocolConstants.MinTimeout" /> or greater than
            <see cref="F:NuGet.Protocol.Plugins.ProtocolConstants.MaxTimeout" />.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="requestTimeout" />
            is either less than <see cref="F:NuGet.Protocol.Plugins.ProtocolConstants.MinTimeout" /> or greater than
            <see cref="F:NuGet.Protocol.Plugins.ProtocolConstants.MaxTimeout" />.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.ConnectionOptions.SetRequestTimeout(System.TimeSpan)">
      <summary>
            Sets a new request timeout.
            </summary>
      <param name="requestTimeout">The new request timeout.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="requestTimeout" />
            is either less than <see cref="F:NuGet.Protocol.Plugins.ProtocolConstants.MinTimeout" /> or greater than
            <see cref="F:NuGet.Protocol.Plugins.ProtocolConstants.MaxTimeout" />.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.ConnectionOptions.CreateDefault(NuGet.Common.IEnvironmentVariableReader)">
      <summary>
            Instantiates a <see cref="T:NuGet.Protocol.Plugins.ConnectionOptions" /> class with default values.
            </summary>
      <param name="reader">An environment variable reader.</param>
      <returns>A <see cref="T:NuGet.Protocol.Plugins.ConnectionOptions" />.</returns>
    </member>
    <member name="P:NuGet.Protocol.Plugins.ConnectionOptions.HandshakeTimeout">
      <summary>
            Gets the plugin handshake timeout.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.ConnectionOptions.MinimumProtocolVersion">
      <summary>
            Gets the minimum plugin protocol version.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.ConnectionOptions.ProtocolVersion">
      <summary>
            Gets the plugin protocol version.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.ConnectionOptions.RequestTimeout">
      <summary>
            Gets the plugin request timeout.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.ConnectionState">
      <summary>
            Connection states.
            </summary>
      <remarks>Member order is significant.
            For example, any connection state before <see cref="F:NuGet.Protocol.Plugins.ConnectionState.Connecting" />
            implies no connection.</remarks>
    </member>
    <member name="T:NuGet.Protocol.Plugins.EmbeddedSignatureVerifier">
      <summary>
            Base class for embedded signature verifiers.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.EmbeddedSignatureVerifier.IsValid(System.String)">
      <summary>
            Checks if a file has a valid embedded signature.
            </summary>
      <param name="filePath">The path of a file to be checked.</param>
      <returns>
        <c>true</c> if the file has a valid signature; otherwise, <c>false</c>.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="filePath" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Thrown if the current platform is unsupported.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.EmbeddedSignatureVerifier.Create">
      <summary>
            Creates an embedded signature verifier for the current platform.
            </summary>
      <returns>An embedded signature verifier.</returns>
    </member>
    <member name="T:NuGet.Protocol.Plugins.FallbackEmbeddedSignatureVerifier">
      <summary>
            A fallback embedded signature verifier for unsupported platforms.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.FallbackEmbeddedSignatureVerifier.IsValid(System.String)">
      <summary>
            Checks if a file has a valid embedded signature.
            </summary>
      <param name="filePath">The path of a file to be checked.</param>
      <returns>
        <c>true</c> if the file has a valid signature; otherwise, <c>false</c>.</returns>
      <exception cref="T:System.PlatformNotSupportedException">Thrown always.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.FaultedPluginEventArgs">
      <summary>
            Faulted plugin event arguments.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.FaultedPluginEventArgs.#ctor(NuGet.Protocol.Plugins.IPlugin,System.Exception)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.FaultedPluginEventArgs" /> class.
            </summary>
      <param name="plugin">A plugin.</param>
      <param name="exception">An exception.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="plugin" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="exception" /> is <c>null</c>.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.FaultedPluginEventArgs.Exception">
      <summary>
            Gets the exception.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.FaultedPluginEventArgs.Plugin">
      <summary>
            Gets the plugin.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.IConnection">
      <summary>
            Represents a bidirectional channel between a NuGet client and a plugin.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IConnection.Close">
      <summary>
            Closes the connection.
            </summary>
      <remarks>This does not call <see cref="M:System.IDisposable.Dispose" />.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IConnection.SendAsync(NuGet.Protocol.Plugins.Message,System.Threading.CancellationToken)">
      <summary>
            Asynchronously sends a message to the remote target.
            </summary>
      <param name="message">The message to be sent.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="message" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if not connected.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IConnection.SendRequestAndReceiveResponseAsync``2(NuGet.Protocol.Plugins.MessageMethod,``0,System.Threading.CancellationToken)">
      <summary>
            Asynchronously sends a message to the remote target and receives the target's response.
            </summary>
      <typeparam name="TOutbound">The outbound payload type.</typeparam>
      <typeparam name="TInbound">The inbound payload type.</typeparam>
      <param name="method">The outbound message method.</param>
      <param name="payload">The outbound message payload.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <typeparamref name="TInbound" />
            from the target.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if not connected.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.IConnection.MessageDispatcher">
      <summary>
            Gets the message dispatcher.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.IConnection.Options">
      <summary>
            Gets the connection options
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.IConnection.ProtocolVersion">
      <summary>
            Gets the negotiated protocol version, or <c>null</c> if not yet connected.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.IConnection.Faulted">
      <summary>
            Occurs when an unrecoverable fault has been caught.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.IConnection.MessageReceived">
      <summary>
            Occurs when a message has been received.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.IIdGenerator">
      <summary>
            A unique identifier generator.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IIdGenerator.GenerateUniqueId">
      <summary>
            Generates a new unique identifier.
            </summary>
      <returns>A unique identifier.</returns>
    </member>
    <member name="T:NuGet.Protocol.Plugins.IMessageDispatcher">
      <summary>
            A message dispatcher that maintains state for outstanding requests
            and routes messages to configured request handlers.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IMessageDispatcher.Close">
      <summary>
            Closes the dispatcher.
            </summary>
      <remarks>This does not call <see cref="M:System.IDisposable.Dispose" />.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IMessageDispatcher.CreateMessage(NuGet.Protocol.Plugins.MessageType,NuGet.Protocol.Plugins.MessageMethod)">
      <summary>
            Creates a message.
            </summary>
      <param name="type">The message type.</param>
      <param name="method">The message method.</param>
      <returns>A message.</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IMessageDispatcher.CreateMessage``1(NuGet.Protocol.Plugins.MessageType,NuGet.Protocol.Plugins.MessageMethod,``0)">
      <summary>
            Creates a message.
            </summary>
      <typeparam name="TPayload">The message payload.</typeparam>
      <param name="type">The message type.</param>
      <param name="method">The message method.</param>
      <param name="payload">The message payload.</param>
      <returns>A message.</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IMessageDispatcher.DispatchCancelAsync(NuGet.Protocol.Plugins.Message,System.Threading.CancellationToken)">
      <summary>
            Asynchronously dispatches a cancellation request for the specified request.
            </summary>
      <param name="request">The request.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IMessageDispatcher.DispatchFaultAsync(NuGet.Protocol.Plugins.Message,NuGet.Protocol.Plugins.Fault,System.Threading.CancellationToken)">
      <summary>
            Asynchronously dispatches a fault notification for the specified request.
            </summary>
      <param name="request">The cancel request.</param>
      <param name="fault">The fault payload.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IMessageDispatcher.DispatchProgressAsync(NuGet.Protocol.Plugins.Message,NuGet.Protocol.Plugins.Progress,System.Threading.CancellationToken)">
      <summary>
            Asynchronously dispatches a progress notification for the specified request.
            </summary>
      <param name="request">The request.</param>
      <param name="progress">The progress payload.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IMessageDispatcher.DispatchRequestAsync``2(NuGet.Protocol.Plugins.MessageMethod,``0,System.Threading.CancellationToken)">
      <summary>
            Asynchronously dispatches a request.
            </summary>
      <typeparam name="TOutbound">The request payload type.</typeparam>
      <typeparam name="TInbound">The expected response payload type.</typeparam>
      <param name="method">The request method.</param>
      <param name="payload">The request payload.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <typeparamref name="TInbound" />
            from the target.</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IMessageDispatcher.DispatchResponseAsync``1(NuGet.Protocol.Plugins.Message,``0,System.Threading.CancellationToken)">
      <summary>
            Asynchronously dispatches a response.
            </summary>
      <typeparam name="TOutbound">The request payload type.</typeparam>
      <param name="request">The associated request.</param>
      <param name="responsePayload">The response payload.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IMessageDispatcher.SetConnection(NuGet.Protocol.Plugins.IConnection)">
      <summary>
            Sets the connection to be used for dispatching messages.
            </summary>
      <param name="connection">A connection instance.  Can be <c>null</c>.</param>
    </member>
    <member name="P:NuGet.Protocol.Plugins.IMessageDispatcher.RequestHandlers">
      <summary>
            Gets the request handlers for use by the dispatcher.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.InboundRequestContext">
      <summary>
            Context for an inbound request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.InboundRequestContext.#ctor(NuGet.Protocol.Plugins.IConnection,System.String,System.Threading.CancellationToken)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.InboundRequestContext" /> class.
            </summary>
      <param name="connection">A connection.</param>
      <param name="requestId">A request ID.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="connection" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="requestId" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.InboundRequestContext.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.InboundRequestContext.BeginFaultAsync(NuGet.Protocol.Plugins.Message,System.Exception)">
      <summary>
            Asynchronously starts processing a fault response for the inbound request.
            </summary>
      <param name="request">The request.</param>
      <param name="exception">An exception.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" />
            is either <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="exception" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.InboundRequestContext.BeginResponseAsync(NuGet.Protocol.Plugins.Message,NuGet.Protocol.Plugins.IRequestHandler,NuGet.Protocol.Plugins.IResponseHandler)">
      <summary>
            Asynchronously starts processing a response for the inbound request.
            </summary>
      <param name="request">The request.</param>
      <param name="requestHandler">A request handler.</param>
      <param name="responseHandler">A response handler.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="requestHandler" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="responseHandler" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.InboundRequestContext.Cancel">
      <summary>
            Cancels an inbound request.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.InboundRequestContext.RequestId">
      <summary>
            Gets the request ID.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.IPlugin">
      <summary>
            Represents a plugin.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IPlugin.Close">
      <summary>
            Closes the plugin.
            </summary>
      <remarks>This does not call <see cref="M:System.IDisposable.Dispose" />.</remarks>
    </member>
    <member name="P:NuGet.Protocol.Plugins.IPlugin.Connection">
      <summary>
            Gets the connection for the plugin.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.IPlugin.FilePath">
      <summary>
            Gets the file path for the plugin.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.IPlugin.Id">
      <summary>
            Gets the unique identifier for the plugin.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.IPlugin.Name">
      <summary>
            Gets the name of the plugin.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.IPlugin.BeforeClose">
      <summary>
            Occurs before the plugin closes.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.IPlugin.Closed">
      <summary>
            Occurs when the plugin has closed.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.IPluginDiscoverer">
      <summary>
            A plugin discoverer.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IPluginDiscoverer.DiscoverAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously discovers plugins.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.IPluginFactory">
      <summary>
            A plugin factory.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IPluginFactory.GetOrCreateAsync(System.String,System.Collections.Generic.IEnumerable{System.String},NuGet.Protocol.Plugins.IRequestHandlers,NuGet.Protocol.Plugins.ConnectionOptions,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets an existing plugin instance or creates a new instance and connects to it.
            </summary>
      <param name="filePath">The file path of the plugin.</param>
      <param name="arguments">Command-line arguments to be supplied to the plugin.</param>
      <param name="requestHandlers">Request handlers.</param>
      <param name="options">Connection options.</param>
      <param name="sessionCancellationToken">A cancellation token for the plugin's lifetime.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.Protocol.Plugins.Plugin" />
            instance.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="filePath" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="arguments" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="requestHandlers" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="options" />
            is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="sessionCancellationToken" />
            is cancelled.</exception>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <remarks>This is intended to be called by NuGet client tools.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IPluginManager.CreatePluginsAsync(NuGet.Protocol.Core.Types.SourceRepository,System.Threading.CancellationToken)">
      <summary>
            Create plugins appropriate for the given source
            </summary>
      <param name="source">
      </param>
      <param name="cancellationToken">
      </param>
      <exception cref="T:System.ArgumentNullException">Throw if <paramref name="source" /> is null </exception>
      <returns>PluginCreationResults</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IPluginManager.FindAvailablePluginsAsync(System.Threading.CancellationToken)">
      <summary>
            Find all available plugins on the machine
            </summary>
      <param name="cancellationToken">
      </param>
      <returns>PluginDiscoveryResults</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IPluginManager.TryGetSourceAgnosticPluginAsync(NuGet.Protocol.Plugins.PluginDiscoveryResult,NuGet.Protocol.Plugins.OperationClaim,System.Threading.CancellationToken)">
      <summary>
            Creates a plugin from the given pluginDiscoveryResult.
            This plugin's operations will be source agnostic ones
            </summary>
      <param name="pluginDiscoveryResult">
      </param>
      <param name="cancellationToken">
      </param>
      <returns>A PluginCreationResult</returns>
    </member>
    <member name="T:NuGet.Protocol.Plugins.IPluginMulticlientUtilities">
      <summary>
            Plugin multiclient utilities.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IPluginMulticlientUtilities.DoOncePerPluginLifetimeAsync(System.String,System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
      <summary>
            Asynchronously executes a task once per plugin lifetime per key.
            </summary>
      <param name="key">A key that identifies the task.</param>
      <param name="taskFunc">A function that returns a task.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="key" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="taskFunc" />
            is either <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.IPluginProcess">
      <summary>
            Represents a plugin process.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IPluginProcess.BeginReadLine">
      <summary>
            Asynchronously starts reading the standard output stream.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IPluginProcess.CancelRead">
      <summary>
            Cancels asynchronous reading of the standard output stream.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IPluginProcess.Kill">
      <summary>
            Immediately stops the associated process.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.IPluginProcess.HasExited">
      <summary>
            Gets a value indicating whether the associated process has been terminated.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.IPluginProcess.LineRead">
      <summary>
            Occurs when a line of output has been received.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.IPluginProcess.Exited">
      <summary>
            Occurs when a process exits.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.IReceiver">
      <summary>
            Represents a unidirectional communications channel from a target.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IReceiver.Close">
      <summary>
            Closes the connection.
            </summary>
      <remarks>This does not call <see cref="M:System.IDisposable.Dispose" />.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IReceiver.Connect">
      <summary>
            Connects.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if this object is closed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if this method has already been called.</exception>
    </member>
    <member name="E:NuGet.Protocol.Plugins.IReceiver.Faulted">
      <summary>
            Occurs when an unrecoverable fault has been caught.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.IReceiver.MessageReceived">
      <summary>
            Occurs when a message has been received.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.IRequestHandler">
      <summary>
            Represents a request handler.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IRequestHandler.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection,NuGet.Protocol.Plugins.Message,NuGet.Protocol.Plugins.IResponseHandler,System.Threading.CancellationToken)">
      <summary>
            Asynchronously handles responding to a request.
            </summary>
      <param name="connection">The connection.</param>
      <param name="request">A request message.</param>
      <param name="responseHandler">A response handler.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="connection" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="responseHandler" />
            is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.IRequestHandler.CancellationToken">
      <summary>
            Gets the <see cref="P:NuGet.Protocol.Plugins.IRequestHandler.CancellationToken" /> for a request.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.IRequestHandlers">
      <summary>
            A set of <see cref="T:NuGet.Protocol.Plugins.IRequestHandler" />.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IRequestHandlers.AddOrUpdate(NuGet.Protocol.Plugins.MessageMethod,System.Func{NuGet.Protocol.Plugins.IRequestHandler},System.Func{NuGet.Protocol.Plugins.IRequestHandler,NuGet.Protocol.Plugins.IRequestHandler})">
      <summary>
            Atomically add or update a request handler for the specified message method.
            </summary>
      <param name="method">A message method.</param>
      <param name="addHandlerFunc">An add request handler function.</param>
      <param name="updateHandlerFunc">An update request handler function.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="addHandlerFunc" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="updateHandlerFunc" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IRequestHandlers.TryAdd(NuGet.Protocol.Plugins.MessageMethod,NuGet.Protocol.Plugins.IRequestHandler)">
      <summary>
            Attempts to add a request handler for the specified message method.
            </summary>
      <param name="method">A message method.</param>
      <param name="handler">A request handler.</param>
      <returns>
        <c>true</c> if added; otherwise, <c>false</c>.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="handler" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IRequestHandlers.TryGet(NuGet.Protocol.Plugins.MessageMethod,NuGet.Protocol.Plugins.IRequestHandler@)">
      <summary>
            Attempts to get a request handler for the specified message method.
            </summary>
      <param name="method">A message method.</param>
      <param name="handler">A request handler.</param>
      <returns>
        <c>true</c> if the request handler exists; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IRequestHandlers.TryRemove(NuGet.Protocol.Plugins.MessageMethod)">
      <summary>
            Attempts to remove a request handler for the specified message method.
            </summary>
      <param name="method">A message method.</param>
      <returns>
        <c>true</c> if a request handler was removed; otherwise, <c>false</c>.</returns>
    </member>
    <member name="T:NuGet.Protocol.Plugins.IResponseHandler">
      <summary>
            A response handler.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.IResponseHandler.SendResponseAsync``1(NuGet.Protocol.Plugins.Message,``0,System.Threading.CancellationToken)">
      <summary>
            Asynchronously handles responding to a request.
            </summary>
      <typeparam name="TPayload">The response payload type.</typeparam>
      <param name="request">The request message.</param>
      <param name="payload">The response payload.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="payload" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.ISender">
      <summary>
            Represents a unidirectional communications to a target.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.ISender.Close">
      <summary>
            Closes the connection.
            </summary>
      <remarks>This does not call <see cref="M:System.IDisposable.Dispose" />.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.ISender.Connect">
      <summary>
            Connects.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if this object is closed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if this method has already been called.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.ISender.SendAsync(NuGet.Protocol.Plugins.Message,System.Threading.CancellationToken)">
      <summary>
            Asynchronously sends a message to the target.
            </summary>
      <param name="message">The message to send.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if <see cref="M:NuGet.Protocol.Plugins.ISender.Connect" /> has not been called.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="message" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.JsonSerializationUtilities">
      <summary>
            JSON serialization/deserialization utilities.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.JsonSerializationUtilities.Deserialize``1(System.String)">
      <summary>
            Deserializes an object from the provided JSON.
            </summary>
      <typeparam name="T">The deserialization type.</typeparam>
      <param name="json">JSON to deserialize.</param>
      <returns>An instance of <typeparamref name="T" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="json" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.JsonSerializationUtilities.FromObject(System.Object)">
      <summary>
            Serializes an object.
            </summary>
      <param name="value">An object to serialize.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="value" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.JsonSerializationUtilities.Serialize(Newtonsoft.Json.JsonWriter,System.Object)">
      <summary>
            Serializes an object to the provided writer.
            </summary>
      <param name="writer">A JSON writer.</param>
      <param name="value">The value to serialize.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="value" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.JsonSerializationUtilities.ToObject``1(Newtonsoft.Json.Linq.JObject)">
      <summary>
            Deserializes an object.
            </summary>
      <typeparam name="T">The deserialization type.</typeparam>
      <param name="jObject">A JSON object.</param>
      <returns>An instance of <typeparamref name="T" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="jObject" /> is <c>null</c>.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.JsonSerializationUtilities.Serializer">
      <summary>
            Gets the JSON serializer.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.LineReadEventArgs">
      <summary>
            Line read event arguments.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.LineReadEventArgs.#ctor(System.String)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.LineReadEventArgs" /> class.
            </summary>
      <param name="line">The output line read.</param>
    </member>
    <member name="P:NuGet.Protocol.Plugins.LineReadEventArgs.Line">
      <summary>
            The output line read.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.MessageDispatcher">
      <summary>
            A message dispatcher that maintains state for outstanding requests
            and routes messages to configured request handlers.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageDispatcher.#ctor(NuGet.Protocol.Plugins.IRequestHandlers,NuGet.Protocol.Plugins.IIdGenerator)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.MessageDispatcher" /> class.
            </summary>
      <param name="requestHandlers">Request handlers.</param>
      <param name="idGenerator">A unique identifier generator.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="requestHandlers" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="idGenerator" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageDispatcher.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageDispatcher.Close">
      <summary>
            Closes the dispatcher.
            </summary>
      <remarks>This does not call <see cref="M:System.IDisposable.Dispose" />.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageDispatcher.CreateMessage(NuGet.Protocol.Plugins.MessageType,NuGet.Protocol.Plugins.MessageMethod)">
      <summary>
            Creates a message.
            </summary>
      <param name="type">The message type.</param>
      <param name="method">The message method.</param>
      <returns>A message.</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageDispatcher.CreateMessage``1(NuGet.Protocol.Plugins.MessageType,NuGet.Protocol.Plugins.MessageMethod,``0)">
      <summary>
            Creates a message.
            </summary>
      <typeparam name="TPayload">The message payload.</typeparam>
      <param name="type">The message type.</param>
      <param name="method">The message method.</param>
      <param name="payload">The message payload.</param>
      <returns>A message.</returns>
      <exception cref="T:System.ArgumentNullException">Throws if <paramref name="payload" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageDispatcher.DispatchCancelAsync(NuGet.Protocol.Plugins.Message,System.Threading.CancellationToken)">
      <summary>
            Asynchronously dispatches a cancellation request for the specified request.
            </summary>
      <param name="request">The request.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageDispatcher.DispatchFaultAsync(NuGet.Protocol.Plugins.Message,NuGet.Protocol.Plugins.Fault,System.Threading.CancellationToken)">
      <summary>
            Asynchronously dispatches a fault notification for the specified request.
            </summary>
      <param name="request">The cancel request.</param>
      <param name="fault">The fault payload.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="fault" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageDispatcher.DispatchProgressAsync(NuGet.Protocol.Plugins.Message,NuGet.Protocol.Plugins.Progress,System.Threading.CancellationToken)">
      <summary>
            Asynchronously dispatches a progress notification for the specified request.
            </summary>
      <param name="request">The request.</param>
      <param name="progress">The progress payload.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="progress" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageDispatcher.DispatchRequestAsync``2(NuGet.Protocol.Plugins.MessageMethod,``0,System.Threading.CancellationToken)">
      <summary>
            Asynchronously dispatches a request.
            </summary>
      <typeparam name="TOutbound">The request payload type.</typeparam>
      <typeparam name="TInbound">The expected response payload type.</typeparam>
      <param name="method">The request method.</param>
      <param name="payload">The request payload.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <typeparamref name="TInbound" />
            from the target.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageDispatcher.DispatchResponseAsync``1(NuGet.Protocol.Plugins.Message,``0,System.Threading.CancellationToken)">
      <summary>
            Asynchronously dispatches a response.
            </summary>
      <typeparam name="TOutbound">The request payload type.</typeparam>
      <param name="request">The associated request.</param>
      <param name="responsePayload">The response payload.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="responsePayload" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageDispatcher.SetConnection(NuGet.Protocol.Plugins.IConnection)">
      <summary>
            Sets the connection to be used for dispatching messages.
            </summary>
      <param name="connection">A connection instance.  Can be <c>null</c>.</param>
    </member>
    <member name="P:NuGet.Protocol.Plugins.MessageDispatcher.RequestHandlers">
      <summary>
            Gets the request handlers for use by the dispatcher.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.MessageEventArgs">
      <summary>
            Message event arguments.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageEventArgs.#ctor(NuGet.Protocol.Plugins.Message)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.MessageEventArgs" /> class.
            </summary>
      <param name="message">A message.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="message" /> is <c>null</c>.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.MessageEventArgs.Message">
      <summary>
            Gets the message.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.MessageMethod">
      <summary>
            Message methods.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.None">
      <summary>
            None
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.Close">
      <summary>
            Close
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.CopyFilesInPackage">
      <summary>
            Copy files in a package
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.CopyNupkgFile">
      <summary>
            Copy a .nupkg file
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.GetCredentials">
      <summary>
            Get credentials
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.GetFilesInPackage">
      <summary>
            Get files in a package
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.GetOperationClaims">
      <summary>
            Get operation claims
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.GetPackageHash">
      <summary>
            Get package hash
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.GetPackageVersions">
      <summary>
            Get package versions
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.GetServiceIndex">
      <summary>
            Get service index
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.Handshake">
      <summary>
            Handshake
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.Initialize">
      <summary>
            Initialize
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.Log">
      <summary>
            Log
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.MonitorNuGetProcessExit">
      <summary>
            Monitor NuGet process exit
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.PrefetchPackage">
      <summary>
            Prefetch a package
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.SetCredentials">
      <summary>
            Set credentials
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.SetLogLevel">
      <summary>
            Set log level
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageMethod.GetAuthenticationCredentials">
      <summary>
            Get authentication credentials, for authentication operation
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.MessageResponseCode">
      <summary>
            Message response codes.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageResponseCode.Success">
      <summary>
            The response is success.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageResponseCode.Error">
      <summary>
            The response is error.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageResponseCode.NotFound">
      <summary>
            The response is not found.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.CopyFilesInPackageRequest">
      <summary>
            A request to copy files in a package to a specified destination.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.CopyFilesInPackageRequest.#ctor(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.CopyFilesInPackageRequest" /> class.
            </summary>
      <param name="packageSourceRepository">The package source repository location.</param>
      <param name="packageId">The package ID.</param>
      <param name="packageVersion">The package version.</param>
      <param name="filesInPackage">The files in the package to be copied.</param>
      <param name="destinationFolderPath">The destination folder path.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageSourceRepository" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageId" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageVersion" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="filesInPackage" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="destinationFolderPath" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.CopyFilesInPackageRequest.DestinationFolderPath">
      <summary>
            Gets the destination folder path.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.CopyFilesInPackageRequest.FilesInPackage">
      <summary>
            Gets the files in the package to be copied.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.CopyFilesInPackageRequest.PackageId">
      <summary>
            Gets the package ID.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.CopyFilesInPackageRequest.PackageSourceRepository">
      <summary>
            Gets the package source repository location.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.CopyFilesInPackageRequest.PackageVersion">
      <summary>
            Gets the package version.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.CopyFilesInPackageResponse">
      <summary>
            A response to a copy package files request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.CopyFilesInPackageResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.CopyFilesInPackageResponse" /> class.
            </summary>
      <param name="responseCode">The response code.</param>
      <param name="copiedFiles">The paths of files copies.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" /> 
            is <see cref="F:NuGet.Protocol.Plugins.MessageResponseCode.Success" /> and <paramref name="copiedFiles" />
            is either <c>null</c> or empty.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.CopyFilesInPackageResponse.CopiedFiles">
      <summary>
            Gets the paths of files copies.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.CopyFilesInPackageResponse.ResponseCode">
      <summary>
            Gets the response code.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.CopyNupkgFileRequest">
      <summary>
            A request to copy a .nupkg file.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.CopyNupkgFileRequest.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.CopyNupkgFileRequest" /> class.
            </summary>
      <param name="packageSourceRepository">The package source repository location.</param>
      <param name="packageId">The package ID.</param>
      <param name="packageVersion">The package version.</param>
      <param name="destinationFilePath">The destination file path for the .nupkg file.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageSourceRepository" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageId" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageVersion" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="destinationFilePath" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.CopyNupkgFileRequest.DestinationFilePath">
      <summary>
            Gets the destination file path for the .nupkg file.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.CopyNupkgFileRequest.PackageId">
      <summary>
            Gets the package ID.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.CopyNupkgFileRequest.PackageSourceRepository">
      <summary>
            Gets the package source repository location.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.CopyNupkgFileRequest.PackageVersion">
      <summary>
            Gets the package version.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.CopyNupkgFileResponse">
      <summary>
            A response to a copy .nupkg file request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.CopyNupkgFileResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.CopyNupkgFileResponse" /> class.
            </summary>
      <param name="responseCode">The response code.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.CopyNupkgFileResponse.ResponseCode">
      <summary>
            Gets the response code.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.Fault">
      <summary>
            A notification indicating the sender has experienced an unrecoverable fault.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Fault.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.Fault" /> class.
            </summary>
      <param name="message">The fault message.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="message" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Fault.Message">
      <summary>
            Gets the fault message.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest">
      <summary>
            A get authentication credentials request
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest.#ctor(System.Uri,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Create a GetAuthenticationCredentialsRequest
            </summary>
      <param name="uri">
      </param>
      <param name="isRetry">
      </param>
      <param name="isNonInteractive">
      </param>
      <exception cref="T:System.ArgumentNullException"> if <paramref name="uri" /> is null</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest.Uri">
      <summary>
            Uri
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest.IsRetry">
      <summary>
            isRetry
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest.IsNonInteractive">
      <summary>
            IsNonInteractive - tells the plugin whether it can block the operation to ask for user input. Be it a device flow request or a pop-up. 
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetAuthenticationCredentialsRequest.CanShowDialog">
      <summary>
            CanShowDialog - tells the plugin whether it can show a dialog if the plugin is run in interactive mode. This being false normally means that the auth method should be device flow.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse">
      <summary>
            A get authentication credentials response
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.#ctor(System.String,System.String,System.String,System.Collections.Generic.IList{System.String},NuGet.Protocol.Plugins.MessageResponseCode)">
      <summary>
            Create a response object
            </summary>
      <param name="username">
      </param>
      <param name="password">
      </param>
      <param name="message">
      </param>
      <param name="authenticationTypes">
      </param>
      <param name="responseCode">
      </param>
      <exception cref="T:System.ArgumentException">If MessageResponseCode is not defined on this runtime</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.IsValid">
      <summary>
            Gets a value indicating whether the provider returnd a valid response.
            </summary>
      <remarks>
            Either Username or Password (or both) must be set, and AuthTypes must either be null or contain at least
            one element
            </remarks>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.Username">
      <summary>
            Username
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.Password">
      <summary>
            password token
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.Message">
      <summary>
            message - optional, can be used as a way to communicate to NuGet why the authentication failed.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.AuthenticationTypes">
      <summary>
            Gets or sets the list of authentication types this credential is applicable to. Useful values include
            <c>basic</c>, <c>digest</c>, <c>negotiate</c>, and <c>ntlm</c></summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetAuthenticationCredentialsResponse.ResponseCode">
      <summary>
            ResponseCode - status of the credentials
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetCredentialsRequest">
      <summary>
            A request to get credentials.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetCredentialsRequest.#ctor(System.String,System.Net.HttpStatusCode)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.GetCredentialsRequest" /> class.
            </summary>
      <param name="packageSourceRepository">The package source repository location.</param>
      <param name="statusCode">The HTTP status code.</param>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetCredentialsRequest.PackageSourceRepository">
      <summary>
            Gets the package source repository location.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetCredentialsRequest.StatusCode">
      <summary>
            Gets the HTTP status code that necessitates credentials.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetCredentialsResponse">
      <summary>
            A response to a get credentials request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetCredentialsResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode,System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.GetCredentialsResponse" /> class.
            </summary>
      <param name="responseCode">The plugin's response code.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetCredentialsResponse.Password">
      <summary>
            Gets the password.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetCredentialsResponse.ResponseCode">
      <summary>
            Gets the response code.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetCredentialsResponse.Username">
      <summary>
            Gets the username.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetFilesInPackageRequest">
      <summary>
            A get files in package request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetFilesInPackageRequest.#ctor(System.String,System.String,System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.GetFilesInPackageRequest" /> class.
            </summary>
      <param name="packageSourceRepository">The package source repository location.</param>
      <param name="packageId">The package ID.</param>
      <param name="packageVersion">The package version.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageSourceRepository" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageId" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageVersion" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetFilesInPackageRequest.PackageId">
      <summary>
            Gets the package ID.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetFilesInPackageRequest.PackageSourceRepository">
      <summary>
            Gets the package source repository location.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetFilesInPackageRequest.PackageVersion">
      <summary>
            Gets the package version.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetFilesInPackageResponse">
      <summary>
            A response to a get files in package request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetFilesInPackageResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.GetFilesInPackageResponse" /> class.
            </summary>
      <param name="responseCode">The response code.</param>
      <param name="files">The paths of files in the package.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" /> 
            is <see cref="F:NuGet.Protocol.Plugins.MessageResponseCode.Success" /> and <paramref name="files" />
            is either <c>null</c> or empty.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetFilesInPackageResponse.Files">
      <summary>
            Gets the paths of files in the package.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetFilesInPackageResponse.ResponseCode">
      <summary>
            Gets the response code.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetOperationClaimsRequest">
      <summary>
            A query to a plugin about which operations it supports for a specific package source.
            In version 1.0.0, the fields are required. That's not the case for version 2.0.0
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetOperationClaimsRequest.#ctor(System.String,Newtonsoft.Json.Linq.JObject)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.GetOperationClaimsRequest" /> class.
            </summary>
      <param name="packageSourceRepository">The package source location.</param>
      <param name="serviceIndex">The service index (index.json).</param>
      <remarks>Both packageSourceRepository and service index can be null. If they are, the operation claims request is considered as source agnostic</remarks>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetOperationClaimsRequest.PackageSourceRepository">
      <summary>
            Gets the package source repository location for the <see cref="P:NuGet.Protocol.Plugins.GetOperationClaimsRequest.ServiceIndex" />.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetOperationClaimsRequest.ServiceIndex">
      <summary>
            Gets the service index (index.json) for the <see cref="P:NuGet.Protocol.Plugins.GetOperationClaimsRequest.PackageSourceRepository" />.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetOperationClaimsResponse">
      <summary>
            A plugin's response as to which operations it supports for a specific package source.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetOperationClaimsResponse.#ctor(System.Collections.Generic.IEnumerable{NuGet.Protocol.Plugins.OperationClaim})">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.GetOperationClaimsResponse" /> class.
            </summary>
      <param name="claims">The operation claims.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="claims" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="claims" /> contains
            undefined <see cref="T:NuGet.Protocol.Plugins.OperationClaim" /> values.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetOperationClaimsResponse.Claims">
      <summary>
            Gets the plugin's operation claims.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetPackageHashRequest">
      <summary>
            A request to get a package hash.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetPackageHashRequest.#ctor(System.String,System.String,System.String,System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.GetPackageHashRequest" /> class.
            </summary>
      <param name="packageSourceRepository">The package source repository location.</param>
      <param name="packageId">The package ID.</param>
      <param name="packageVersion">The package version.</param>
      <param name="hashAlgorithm">The hash algorithm.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageSourceRepository" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageId" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageVersion" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="hashAlgorithm" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetPackageHashRequest.HashAlgorithm">
      <summary>
            Gets the hash algorithm.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetPackageHashRequest.PackageId">
      <summary>
            Gets the package ID.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetPackageHashRequest.PackageSourceRepository">
      <summary>
            Gets the package source repository location.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetPackageHashRequest.PackageVersion">
      <summary>
            Gets the package version.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetPackageHashResponse">
      <summary>
            A response to a get package hash request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetPackageHashResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode,System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.GetPackageHashResponse" /> class.
            </summary>
      <param name="responseCode">The response code.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" /> 
            is <see cref="F:NuGet.Protocol.Plugins.MessageResponseCode.Success" /> and <paramref name="hash" />
            is either <c>null</c> or empty.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetPackageHashResponse.Hash">
      <summary>
            Gets the package hash.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetPackageHashResponse.ResponseCode">
      <summary>
            Gets the response code.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetPackageVersionsRequest">
      <summary>
            A request for package versions.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetPackageVersionsRequest.#ctor(System.String,System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.GetPackageVersionsRequest" /> class.
            </summary>
      <param name="packageSourceRepository">The package source repository location.</param>
      <param name="packageId">The package ID.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageSourceRepository" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageId" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetPackageVersionsRequest.PackageId">
      <summary>
            Gets the package ID.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetPackageVersionsRequest.PackageSourceRepository">
      <summary>
            Gets the package source repository location.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetPackageVersionsResponse">
      <summary>
            A response to a get package versions request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetPackageVersionsResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode,System.Collections.Generic.IEnumerable{System.String})">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.GetPackageVersionsResponse" /> class.
            </summary>
      <param name="responseCode">The response code.</param>
      <param name="versions">The package versions.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" /> 
            is <see cref="F:NuGet.Protocol.Plugins.MessageResponseCode.Success" /> and <paramref name="versions" />
            is either <c>null</c> or empty.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetPackageVersionsResponse.ResponseCode">
      <summary>
            Gets the response code.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetPackageVersionsResponse.Versions">
      <summary>
            Gets the package versions.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetServiceIndexRequest">
      <summary>
            A request to get the service index for a package source repository.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetServiceIndexRequest.#ctor(System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.GetServiceIndexRequest" /> class.
            </summary>
      <param name="packageSourceRepository">The package source repository location.</param>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetServiceIndexRequest.PackageSourceRepository">
      <summary>
            Gets the package source repository location.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetServiceIndexResponse">
      <summary>
            A response to a get service index request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetServiceIndexResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode,Newtonsoft.Json.Linq.JObject)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.GetServiceIndexResponse" /> class.
            </summary>
      <param name="responseCode">The response code.</param>
      <param name="serviceIndex">The service index (index.json) for the package source repository.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="responseCode" /> 
            is <see cref="F:NuGet.Protocol.Plugins.MessageResponseCode.Success" /> and <paramref name="serviceIndex" />
            is <c>null</c>.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetServiceIndexResponse.ResponseCode">
      <summary>
            Gets the response code.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetServiceIndexResponse.ServiceIndex">
      <summary>
            Gets the service index (index.json) for the package source repository.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.HandshakeRequest">
      <summary>
            A handshake request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.HandshakeRequest.#ctor(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.HandshakeRequest" /> class.
            </summary>
      <param name="protocolVersion">The requestor's plugin protocol version.</param>
      <param name="minimumProtocolVersion">The requestor's minimum plugin protocol version.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="protocolVersion" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="minimumProtocolVersion" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="protocolVersion" />
            is less than <paramref name="minimumProtocolVersion" />.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.HandshakeRequest.ProtocolVersion">
      <summary>
            Gets the requestor's plugin protocol version.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.HandshakeRequest.MinimumProtocolVersion">
      <summary>
            Gets the requestor's minimum plugin protocol version.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.HandshakeResponse">
      <summary>
            A handshake response.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.HandshakeResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode,NuGet.Versioning.SemanticVersion)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.HandshakeResponse" /> class.
            </summary>
      <param name="responseCode">The handshake responder's handshake response code.</param>
      <param name="protocolVersion">The handshake responder's plugin protocol version
            if the handshake was successful; otherwise, <c>null</c>.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is <see cref="F:NuGet.Protocol.Plugins.MessageResponseCode.Success" /> and <paramref name="protocolVersion" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is not <see cref="F:NuGet.Protocol.Plugins.MessageResponseCode.Success" /> and <paramref name="protocolVersion" />
            is not <c>null</c>.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.HandshakeResponse.ResponseCode">
      <summary>
            Gets the handshake responder's handshake response code.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.HandshakeResponse.ProtocolVersion">
      <summary>
            Gets the handshake responder's plugin protocol version if the handshake was successful;
            otherwise, <c>null</c>.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.InitializeRequest">
      <summary>
            An initialization request to a plugin.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.InitializeRequest.#ctor(System.String,System.String,System.TimeSpan)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.InitializeRequest" /> class.
            </summary>
      <param name="clientVersion">The requestor's NuGet client version.</param>
      <param name="culture">The requestor's current culture.</param>
      <param name="requestTimeout">The default request timeout.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="clientVersion" /> is either <c>null</c>
            or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="culture" /> is either <c>null</c>
            or an empty string.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="requestTimeout" />
            is either less than <see cref="F:NuGet.Protocol.Plugins.ProtocolConstants.MinTimeout" /> or greater than
            <see cref="F:NuGet.Protocol.Plugins.ProtocolConstants.MaxTimeout" />.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.InitializeRequest.ClientVersion">
      <summary>
            Gets the requestor's NuGet client version.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.InitializeRequest.Culture">
      <summary>
            Gets the requestor's current culture.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.InitializeRequest.RequestTimeout">
      <summary>
            Gets the default request timeout for all subsequent requests.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.InitializeResponse">
      <summary>
            An initialization response from a plugin.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.InitializeResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.InitializeResponse" /> class.
            </summary>
      <param name="responseCode">The plugin's initialization response code.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.InitializeResponse.ResponseCode">
      <summary>
            Gets the plugin's initialization response code.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.LogRequest">
      <summary>
            A logging request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.LogRequest.#ctor(NuGet.Common.LogLevel,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.LogRequest" /> class.
            </summary>
      <param name="logLevel">The logging level for the message.</param>
      <param name="message">The message to be logged.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="logLevel" /> is an undefined
            <see cref="P:NuGet.Protocol.Plugins.LogRequest.LogLevel" /> value.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="message" /> is either <c>null</c>
            or an empty string.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.LogRequest.LogLevel">
      <summary>
            Gets the logging level for the message.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.LogRequest.Message">
      <summary>
            Gets the message.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.LogResponse">
      <summary>
            A logging response.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.LogResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.LogResponse" /> class.
            </summary>
      <param name="responseCode">The logging response code.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.LogResponse.ResponseCode">
      <summary>
            Gets the logging response code.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.Message">
      <summary>
            Represents a message between a NuGet client and a plugin.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Message.#ctor(System.String,NuGet.Protocol.Plugins.MessageType,NuGet.Protocol.Plugins.MessageMethod,Newtonsoft.Json.Linq.JObject)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.Message" /> class.
            </summary>
      <param name="requestId">The request ID.</param>
      <param name="type">The message type.</param>
      <param name="method">The message method.</param>
      <param name="payload">An optional message payload.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="requestId" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="type" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageType" /> value.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="method" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageMethod" /> value.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Message.RequestId">
      <summary>
            Gets the request ID.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Message.Type">
      <summary>
            Gets the message type.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Message.Method">
      <summary>
            Gets the message method.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Message.Payload">
      <summary>
            Gets the optional message payload.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequest">
      <summary>
            A request to monitor a NuGet process exit.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequest.#ctor(System.Int32)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequest" /> class.
            </summary>
      <param name="processId">The process ID.</param>
    </member>
    <member name="P:NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequest.ProcessId">
      <summary>
            Gets the process ID.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.MonitorNuGetProcessExitResponse">
      <summary>
            A response to a monitor NuGet process exit request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MonitorNuGetProcessExitResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.MonitorNuGetProcessExitResponse" /> class.
            </summary>
      <param name="responseCode">The plugin's response code.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.MonitorNuGetProcessExitResponse.ResponseCode">
      <summary>
            Gets the response code.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PrefetchPackageRequest">
      <summary>
            A request to a plugin to prefetch a package.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PrefetchPackageRequest.#ctor(System.String,System.String,System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.PrefetchPackageRequest" /> class.
            </summary>
      <param name="packageSourceRepository">The package source repository location.</param>
      <param name="packageId">The package ID.</param>
      <param name="packageVersion">The package version.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageSourceRepository" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageId" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageVersion" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PrefetchPackageRequest.PackageId">
      <summary>
            Gets the package ID.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PrefetchPackageRequest.PackageSourceRepository">
      <summary>
            Gets the package source repository location.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PrefetchPackageRequest.PackageVersion">
      <summary>
            Gets the package version.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PrefetchPackageResponse">
      <summary>
            A plugin's response to a package prefetch request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PrefetchPackageResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.PrefetchPackageResponse" /> class.
            </summary>
      <param name="responseCode">The plugin's response code.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PrefetchPackageResponse.ResponseCode">
      <summary>
            Gets the plugin's response code.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.Progress">
      <summary>
            A progress notification.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Progress.#ctor(System.Nullable{System.Double})">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.Progress" /> class.
            </summary>
      <param name="percentage">The progress percentage.</param>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Progress.Percentage">
      <summary>
            Gets the progress percentage.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.SetCredentialsRequest">
      <summary>
            A request to set credentials for a package source with any last known good credentials.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.SetCredentialsRequest.#ctor(System.String,System.String,System.String,System.String,System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.SetCredentialsRequest" /> class.
            </summary>
      <param name="packageSourceRepository">The package source repository location.</param>
      <param name="proxyUsername">The proxy username.</param>
      <param name="proxyPassword">The proxy password.</param>
      <param name="username">The package source repository username.</param>
      <param name="password">The package source repository password.</param>
    </member>
    <member name="P:NuGet.Protocol.Plugins.SetCredentialsRequest.PackageSourceRepository">
      <summary>
            Gets the package source repository location.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.SetCredentialsRequest.Password">
      <summary>
            Gets the package source repository password.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.SetCredentialsRequest.ProxyPassword">
      <summary>
            Gets the proxy password.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.SetCredentialsRequest.ProxyUsername">
      <summary>
            Gets the proxy username.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.SetCredentialsRequest.Username">
      <summary>
            Gets the package source repository username.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.SetCredentialsResponse">
      <summary>
            A plugin's response to a set credentials request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.SetCredentialsResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.SetCredentialsResponse" /> class.
            </summary>
      <param name="responseCode">The plugin's response code.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.SetCredentialsResponse.ResponseCode">
      <summary>
            Gets the plugin's response code.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.SetLogLevelRequest">
      <summary>
            A request to set the log level.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.SetLogLevelRequest.#ctor(NuGet.Common.LogLevel)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.SetLogLevelRequest" /> class.
            </summary>
      <param name="logLevel">The log level.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="logLevel" /> is an undefined
            <see cref="P:NuGet.Protocol.Plugins.SetLogLevelRequest.LogLevel" /> value.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.SetLogLevelRequest.LogLevel">
      <summary>
            Gets the log level.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.SetLogLevelResponse">
      <summary>
            A response to a log level set request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.SetLogLevelResponse.#ctor(NuGet.Protocol.Plugins.MessageResponseCode)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.SetLogLevelResponse" /> class.
            </summary>
      <param name="responseCode">The response code.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="responseCode" />
            is an undefined <see cref="T:NuGet.Protocol.Plugins.MessageResponseCode" /> value.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.SetLogLevelResponse.ResponseCode">
      <summary>
            Gets the response code.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.MessageType">
      <summary>
            Message types.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageType.Cancel">
      <summary>
            A cancellation request for an existing request.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageType.Fault">
      <summary>
            A fault notification, either standalone or for an existing request.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageType.Progress">
      <summary>
            A progress notification for an existing request.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageType.Request">
      <summary>
            A request.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.MessageType.Response">
      <summary>
            A response for an existing request.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.MessageUtilities">
      <summary>
            Helper methods for messages.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageUtilities.Create(System.String,NuGet.Protocol.Plugins.MessageType,NuGet.Protocol.Plugins.MessageMethod)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.Message" /> class.
            </summary>
      <param name="requestId">The message request ID.</param>
      <param name="type">The message type.</param>
      <param name="method">The message method.</param>
      <returns>a <see cref="T:NuGet.Protocol.Plugins.Message" /> instance.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="requestId" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageUtilities.Create``1(System.String,NuGet.Protocol.Plugins.MessageType,NuGet.Protocol.Plugins.MessageMethod,``0)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.Message" /> class.
            </summary>
      <typeparam name="TPayload">The message payload type.</typeparam>
      <param name="requestId">The message request ID.</param>
      <param name="type">The message type.</param>
      <param name="method">The message method.</param>
      <param name="payload">The message payload.</param>
      <returns>a <see cref="T:NuGet.Protocol.Plugins.Message" /> instance.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="requestId" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="payload" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MessageUtilities.DeserializePayload``1(NuGet.Protocol.Plugins.Message)">
      <summary>
            Deserializes a message payload.
            </summary>
      <typeparam name="TPayload">The message payload type.</typeparam>
      <param name="message">The message.</param>
      <returns>The deserialized message payload of type <typeparamref name="TPayload" />
            or <c>null</c> if no payload exists.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="message" /> is <c>null</c>.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.NoOpDisposePlugin">
      <summary>
            A plugin wrapper that no-ops IDisposable.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.NoOpDisposePlugin.#ctor(NuGet.Protocol.Plugins.IPlugin)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.NoOpDisposePlugin" /> class.
            </summary>
      <param name="plugin">A plugin</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="plugin" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.NoOpDisposePlugin.Dispose">
      <summary>
            Does nothing.
            </summary>
      <remarks>Plugin disposal is implemented elsewhere.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.NoOpDisposePlugin.Close">
      <summary>
            Closes the plugin.
            </summary>
      <remarks>This does not call <see cref="M:System.IDisposable.Dispose" />.</remarks>
    </member>
    <member name="P:NuGet.Protocol.Plugins.NoOpDisposePlugin.Connection">
      <summary>
            Gets the connection for the plugin.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.NoOpDisposePlugin.FilePath">
      <summary>
            Gets the file path for the plugin.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.NoOpDisposePlugin.Id">
      <summary>
            Gets the unique identifier for the plugin.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.NoOpDisposePlugin.Name">
      <summary>
            Gets the name of the plugin.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.NoOpDisposePlugin.BeforeClose">
      <summary>
            Occurs before the plugin closes.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.NoOpDisposePlugin.Closed">
      <summary>
            Occurs when the plugin has closed.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.OperationClaim">
      <summary>
            Plugin operation claims.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.OperationClaim.DownloadPackage">
      <summary>
            The download package operation claim.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.OperationClaim.Authentication">
      <summary>
            The authentication operation claim
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.OutboundRequestContext">
      <summary>
            Context for an outbound request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.OutboundRequestContext.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.OutboundRequestContext.HandleCancelResponse">
      <summary>
            Handles a cancellation response for the outbound request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.OutboundRequestContext.HandleProgress(NuGet.Protocol.Plugins.Message)">
      <summary>
            Handles progress notifications for the outbound request.
            </summary>
      <param name="progress">A progress notification.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="progress" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.OutboundRequestContext.HandleResponse(NuGet.Protocol.Plugins.Message)">
      <summary>
            Handles a response for the outbound request.
            </summary>
      <param name="response">A response.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="response" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.OutboundRequestContext.HandleFault(NuGet.Protocol.Plugins.Message)">
      <summary>
            Handles a fault response for the outbound request.
            </summary>
      <param name="fault">A fault response.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="fault" /> is <c>null</c>.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.OutboundRequestContext.CancellationToken">
      <summary>
            Gets the <see cref="P:NuGet.Protocol.Plugins.OutboundRequestContext.CancellationToken" />.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.OutboundRequestContext.RequestId">
      <summary>
            Gets the request ID.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.OutboundRequestContext`1">
      <summary>
            Context for an outbound request.
            </summary>
      <typeparam name="TResult">The response payload type.</typeparam>
    </member>
    <member name="M:NuGet.Protocol.Plugins.OutboundRequestContext`1.#ctor(NuGet.Protocol.Plugins.IConnection,NuGet.Protocol.Plugins.Message,System.Nullable{System.TimeSpan},System.Boolean,System.Threading.CancellationToken)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.OutboundRequestContext`1" /> class.
            </summary>
      <param name="connection">A connection.</param>
      <param name="request">A request.</param>
      <param name="timeout">An optional request timeout.</param>
      <param name="isKeepAlive">A flag indicating whether or not the request supports progress notifications
            to reset the request timeout.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="connection" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" />
            is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.OutboundRequestContext`1.HandleCancelResponse">
      <summary>
            Handles a cancellation response for the outbound request.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.OutboundRequestContext`1.HandleProgress(NuGet.Protocol.Plugins.Message)">
      <summary>
            Handles progress notifications for the outbound request.
            </summary>
      <param name="progress">A progress notification.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="progress" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.OutboundRequestContext`1.HandleResponse(NuGet.Protocol.Plugins.Message)">
      <summary>
            Handles a response for the outbound request.
            </summary>
      <param name="response">A response.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="response" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.OutboundRequestContext`1.HandleFault(NuGet.Protocol.Plugins.Message)">
      <summary>
            Handles a fault response for the outbound request.
            </summary>
      <param name="fault">A fault response.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="fault" /> is <c>null</c>.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.OutboundRequestContext`1.CompletionTask">
      <summary>
            Gets the completion task.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.Plugin">
      <summary>
            Represents a plugin.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Plugin.#ctor(System.String,NuGet.Protocol.Plugins.IConnection,NuGet.Protocol.Plugins.IPluginProcess,System.Boolean,System.TimeSpan)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.Plugin" /> class.
            </summary>
      <param name="filePath">The plugin file path.</param>
      <param name="connection">The plugin connection.</param>
      <param name="process">The plugin process.</param>
      <param name="isOwnProcess">
        <c>true</c> if <paramref name="process" /> is the current process;
            otherwise, <c>false</c>.</param>
      <param name="idleTimeout">The plugin idle timeout.  Can be <see cref="F:System.Threading.Timeout.InfiniteTimeSpan" />.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="filePath" /> is either <c>null</c>
            or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="connection" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="process" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="idleTimeout" /> is smaller than
            <see cref="F:System.Threading.Timeout.InfiniteTimeSpan" />.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Plugin.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Plugin.Close">
      <summary>
            Closes the plugin.
            </summary>
      <remarks>This does not call <see cref="M:System.IDisposable.Dispose" />.</remarks>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Plugin.Connection">
      <summary>
            Gets the connection for the plugin
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Plugin.FilePath">
      <summary>
            Gets the file path for the plugin.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Plugin.Id">
      <summary>
            Gets the unique identifier for the plugin.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Plugin.Name">
      <summary>
            Gets the name of the plugin.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.Plugin.BeforeClose">
      <summary>
            Occurs before the plugin closes.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.Plugin.Closed">
      <summary>
            Occurs when the plugin has closed.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.Plugin.Exited">
      <summary>
            Occurs when a plugin process has exited.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.Plugin.Faulted">
      <summary>
            Occurs when a plugin or plugin connection has faulted.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.Plugin.Idle">
      <summary>
            Occurs when a plugin has been idle for the configured idle timeout period.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginCacheEntry">
      <summary>
            This class represents a plugin operations cache entry.
            It contains expiry logic, read/write/update logic.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginCacheEntry.#ctor(System.String,System.String,System.String)">
      <summary>
            Create a plugin cache entry.
            </summary>
      <param name="rootCacheFolder">The root cache folder, normally /localappdata/nuget/plugins-cache</param>
      <param name="pluginFilePath">The full plugin file path, which will be used to create a key for the folder created in the root folder itself </param>
      <param name="requestKey">A unique request key for the operation claims. Ideally the packageSourceRepository value of the PluginRequestKey. Example https://protected.package.feed/index.json, or Source-Agnostic</param>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginCacheEntry.LoadFromFile">
      <summary>
            Loads and processes the contet from the generated file if it exists.
            Even after this method is invoked, the operation claims might be null. 
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginCacheEntry.UpdateCacheFileAsync">
      <summary>
            Updates the cache file with the current value in the operation claims if the operationn claims is not null.
            </summary>
      <returns>Task</returns>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginConstants">
      <summary>
            Plugin constants.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.PluginConstants.CloseTimeout">
      <summary>
            Default close timeout for plugins.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.PluginConstants.IdleTimeout">
      <summary>
            Default idle timeout for plugins.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.PluginConstants.PluginArguments">
      <summary>
            Default command-line arguments for plugins.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.PluginConstants.ProgressInterval">
      <summary>
            The progress notification interval.
            </summary>
      <remarks>This value must be less than half of <see cref="F:NuGet.Protocol.Plugins.PluginConstants.RequestTimeout" />.</remarks>
    </member>
    <member name="F:NuGet.Protocol.Plugins.PluginConstants.RequestTimeout">
      <summary>
            The default request timeout set by an initialize request after handshaking.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginCreationResult">
      <summary>
            A plugin's creation result.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginCreationResult.#ctor(NuGet.Protocol.Plugins.IPlugin,NuGet.Protocol.Plugins.IPluginMulticlientUtilities,System.Collections.Generic.IReadOnlyList{NuGet.Protocol.Plugins.OperationClaim})">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.PluginCreationResult" /> class.
            </summary>
      <param name="plugin">A plugin.</param>
      <param name="utilities">A plugin multiclient utilities.</param>
      <param name="claims">The plugin's operation claims.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="plugin" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="utilities" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="claims" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginCreationResult.#ctor(System.String)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.PluginCreationResult" /> class.
            </summary>
      <param name="message">A message why a plugin could not be created.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="message" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PluginCreationResult.Claims">
      <summary>
            Gets the plugin's operation claims.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PluginCreationResult.Message">
      <summary>
            Gets a message if <see cref="P:NuGet.Protocol.Plugins.PluginCreationResult.Plugin" /> is <c>null</c>; otherwise, <c>null</c>.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PluginCreationResult.Plugin">
      <summary>
            Gets a plugin.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PluginCreationResult.PluginMulticlientUtilities">
      <summary>
            Gets a plugin multiclient utilities.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginDiscoverer">
      <summary>
            Discovers plugins and their operation claims.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginDiscoverer.#ctor(System.String,NuGet.Protocol.Plugins.EmbeddedSignatureVerifier)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.PluginDiscoverer" /> class.
            </summary>
      <param name="rawPluginPaths">The raw semicolon-delimited list of supposed plugin file paths.</param>
      <param name="verifier">An embedded signature verifier.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="verifier" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginDiscoverer.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginDiscoverer.DiscoverAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously discovers plugins.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> from the target.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginDiscoveryResult">
      <summary>
            A plugin discovery result.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginDiscoveryResult.#ctor(NuGet.Protocol.Plugins.PluginFile)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.PluginDiscoveryResult" /> class.
            </summary>
      <param name="pluginFile">A plugin file.</param>
      <see cref="F:NuGet.Protocol.Plugins.PluginFileState.Valid" />; otherwise, <c>null</c><exception cref="T:System.ArgumentNullException">Thrown if <paramref name="pluginFile" />
            is <c>null</c>.</exception></member>
    <member name="P:NuGet.Protocol.Plugins.PluginDiscoveryResult.PluginFile">
      <summary>
            Gets the plugin file.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PluginDiscoveryResult.Message">
      <summary>
            Gets a message if <see cref="P:NuGet.Protocol.Plugins.PluginFile.State" /> is not <see cref="F:NuGet.Protocol.Plugins.PluginFileState.Valid" />;
            otherwise, <c>null</c>.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginDiscoveryUtility.GetInternalPlugins">
      <summary>
            The internal plugins located next to the NuGet assemblies.
            </summary>
      <returns>Internal plugins</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginDiscoveryUtility.GetInternalPluginRelativeToMSBuildExe(System.String)">
      <summary>
            Given Visual Studio 2017 MSBuild.exe path, return the NuGet plugins directory which is in CommonExtensions\NuGet\Plugins
            </summary>
      <param name="msbuildExePath">The MsBuildExe path. Needs to be a valid path. file:// not supported.</param>
      <returns>The NuGet plugins directory, null if <paramref name="msbuildExePath" /> is null</returns>
      <remarks>The MSBuild.exe is in MSBuild\15.0\Bin\MsBuild.exe, the Plugins directory is in Common7\IDE\CommonExtensions\Microsoft\NuGet\Plugins</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginDiscoveryUtility.GetNuGetPluginsDirectoryRelativeToNuGetAssembly(System.String)">
      <summary>
            Given a NuGet assembly path, returns the NuGet plugins directory
            </summary>
      <param name="nugetAssemblyPath">The path to a NuGet assembly in CommonExtensions\NuGet, needs to be a valid path. file:// not supported</param>
      <returns>The NuGet plugins directory in CommonExtensions\NuGet\Plugins, null if the <paramref name="nugetAssemblyPath" /> is null</returns>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginEventArgs">
      <summary>
            Plugin event arguments.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginEventArgs.#ctor(NuGet.Protocol.Plugins.IPlugin)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.PluginEventArgs" /> class.
            </summary>
      <param name="plugin">A plugin.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="plugin" /> is <c>null</c>.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PluginEventArgs.Plugin">
      <summary>
            Gets the plugin.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginException">
      <summary>
            A plugin exception.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginException.#ctor(System.String)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.PluginException" /> class.
            </summary>
      <param name="message">The exception message.</param>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginException.#ctor(System.String,System.Exception)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.PluginException" /> class.
            </summary>
      <param name="message">The exception message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginFactory">
      <summary>
            A plugin factory.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginFactory.#ctor(System.TimeSpan)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.PluginFactory" /> class.
            </summary>
      <param name="pluginIdleTimeout">The plugin idle timeout.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="pluginIdleTimeout" />
            is less than <see cref="F:System.Threading.Timeout.InfiniteTimeSpan" />.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginFactory.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginFactory.GetOrCreateAsync(System.String,System.Collections.Generic.IEnumerable{System.String},NuGet.Protocol.Plugins.IRequestHandlers,NuGet.Protocol.Plugins.ConnectionOptions,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets an existing plugin instance or creates a new instance and connects to it.
            </summary>
      <param name="filePath">The file path of the plugin.</param>
      <param name="arguments">Command-line arguments to be supplied to the plugin.</param>
      <param name="requestHandlers">Request handlers.</param>
      <param name="options">Connection options.</param>
      <param name="sessionCancellationToken">A cancellation token for the plugin's lifetime.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.Protocol.Plugins.Plugin" />
            instance.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="filePath" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="arguments" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="requestHandlers" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="options" />
            is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="sessionCancellationToken" />
            is cancelled.</exception>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <remarks>This is intended to be called by NuGet client tools.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginFactory.CreateFromCurrentProcessAsync(NuGet.Protocol.Plugins.IRequestHandlers,NuGet.Protocol.Plugins.ConnectionOptions,System.Threading.CancellationToken)">
      <summary>
            Asynchronously creates a plugin instance and connects to it.
            </summary>
      <param name="requestHandlers">Request handlers.</param>
      <param name="options">Connection options.</param>
      <param name="sessionCancellationToken">A cancellation token for the plugin's lifetime.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.Protocol.Plugins.Plugin" />
            instance.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="requestHandlers" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="options" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="sessionCancellationToken" />
            is cancelled.</exception>
      <remarks>This is intended to be called by a plugin.</remarks>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginFile">
      <summary>
            Represents a plugin file.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginFile.#ctor(System.String,System.Lazy{NuGet.Protocol.Plugins.PluginFileState})">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.PluginFile" /> class.
            </summary>
      <param name="filePath">The plugin's file path.</param>
      <param name="state">A lazy that evaluates the plugin file state.</param>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PluginFile.Path">
      <summary>
            Gets the plugin's file path.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PluginFile.State">
      <summary>
            Gets the plugin file state.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginFileState">
      <summary>
            State of a plugin file path.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.PluginFileState.Valid">
      <summary>
            The file exists and has a valid embedded signature.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.PluginFileState.NotFound">
      <summary>
            The file was not found.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.PluginFileState.InvalidFilePath">
      <summary>
            The file path was invalid (e.g.:  not rooted).
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.PluginFileState.InvalidEmbeddedSignature">
      <summary>
            The file exists but it has either no embedded signature or an invalid embedded signature.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginMulticlientUtilities">
      <summary>
            Plugin multiclient utilities.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginMulticlientUtilities.#ctor">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.PluginMulticlientUtilities" /> class.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginMulticlientUtilities.DoOncePerPluginLifetimeAsync(System.String,System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
      <summary>
            Asynchronously executes a task once per plugin lifetime per key.
            </summary>
      <param name="key">A key that identifies the task.</param>
      <param name="taskFunc">A function that returns a task.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="key" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="taskFunc" />
            is either <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginPackageDownloader">
      <summary>
            A package downloader that delegates to a plugin.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageDownloader.#ctor(NuGet.Protocol.Plugins.IPlugin,NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Plugins.PluginPackageReader,System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.PluginPackageDownloader" /> class.
            </summary>
      <param name="plugin">A plugin.</param>
      <param name="packageIdentity">A package identity.</param>
      <param name="packageReader">A plugin package reader.</param>
      <param name="packageSourceRepository">A package source repository location.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="plugin" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageIdentity" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageReader" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="packageSourceRepository" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageDownloader.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageDownloader.CopyNupkgFileToAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies a .nupkg to a target file path.
            </summary>
      <param name="destinationFilePath">The destination file path.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.Boolean" />
            indicating whether or not the copy was successful.</returns>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="destinationFilePath" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageDownloader.GetPackageHashAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package hash.
            </summary>
      <param name="hashAlgorithm">The hash algorithm.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.String" />
            representing the package hash.</returns>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="hashAlgorithm" />
            is either <c>null</c> or empty.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageDownloader.SetExceptionHandler(System.Func{System.Exception,System.Threading.Tasks.Task{System.Boolean}})">
      <summary>
            Sets an exception handler for package downloads.
            </summary>
      <remarks>The exception handler returns a task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.Boolean" />
            indicating whether or not the exception was handled.  To handle an exception and stop its
            propagation, the task should return <c>true</c>.  Otherwise, the exception will be rethrown.</remarks>
      <param name="handleExceptionAsync">An exception handler.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="handleExceptionAsync" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageDownloader.SetThrottle(System.Threading.SemaphoreSlim)">
      <summary>
            Sets a throttle for package downloads.
            </summary>
      <param name="throttle">A throttle.  Can be <c>null</c>.</param>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PluginPackageDownloader.ContentReader">
      <summary>
            Gets an asynchronous package content reader.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PluginPackageDownloader.CoreReader">
      <summary>
            Gets an asynchronous package core reader.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginPackageReader">
      <summary>
            A package reader that delegates package read operations to a plugin.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.#ctor(NuGet.Protocol.Plugins.IPlugin,NuGet.Packaging.Core.PackageIdentity,System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.PluginPackageReader" /> class.
            </summary>
      <param name="plugin">A plugin.</param>
      <param name="packageIdentity">A package identity.</param>
      <param name="packageSourceRepository">A package source repository location.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="plugin" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageIdentity" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageSourceRepository" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetStream(System.String)">
      <summary>
            Gets a stream for a file in the package.
            </summary>
      <param name="path">The file path in the package.</param>
      <returns>A stream.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetStreamAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a stream for a file in the package.
            </summary>
      <param name="path">The file path in the package.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.IO.Stream" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="path" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetFiles">
      <summary>
            Gets files in the package.
            </summary>
      <returns>An enumerable of files in the package.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetFilesAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets files in the package.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetFiles(System.String)">
      <summary>
            Gets files in the package.
            </summary>
      <param name="folder">A folder in the package.</param>
      <returns>An enumerable of files in the package.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetFilesAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets files in the package under the specified folder.
            </summary>
      <param name="folder">A folder in the package.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="folder" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.CopyFiles(System.String,System.Collections.Generic.IEnumerable{System.String},NuGet.Packaging.Core.ExtractPackageFileDelegate,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Copies specified files in the package to the destination location.
            </summary>
      <param name="destination">A directory path to copy files to.</param>
      <param name="packageFiles">An enumerable of files in the package to copy.</param>
      <param name="extractFile">A package file extraction delegate.</param>
      <param name="logger">A logger.</param>
      <param name="token">A cancellation token.</param>
      <returns>An enumerable of file paths in the destination location.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.CopyFilesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},NuGet.Packaging.Core.ExtractPackageFileDelegate,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies specified files in the package to the destination location.
            </summary>
      <param name="destination">A directory path to copy files to.</param>
      <param name="packageFiles">An enumerable of files in the package to copy.</param>
      <param name="extractFile">A package file extraction delegate.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="destination" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageFiles" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetIdentity">
      <summary>
            Gets the package identity.
            </summary>
      <returns>A package identity.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetIdentityAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets the package identity.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:NuGet.Packaging.Core.PackageIdentity" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetMinClientVersion">
      <summary>
            Gets the minimum client version in the .nuspec.
            </summary>
      <returns>A NuGet version.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetMinClientVersionAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets the minimum client version in the .nuspec.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:NuGet.Versioning.NuGetVersion" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetPackageTypes">
      <summary>
            Gets the package types.
            </summary>
      <returns>A read-only list of package types.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetPackageTypesAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets the package types.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IReadOnlyList`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetNuspec">
      <summary>
            Gets a stream for the .nuspec file.
            </summary>
      <returns>A stream.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetNuspecAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a stream for the .nuspec file.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.IO.Stream" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetNuspecFile">
      <summary>
            Gets the .nuspec file path in the package.
            </summary>
      <returns>The .nuspec file path in the package.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetNuspecFileAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets the .nuspec file path in the package.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.String" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetNuspecReaderAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets the .nuspec reader.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="P:NuGet.Protocol.Plugins.PluginPackageReader.NuspecReader" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetSupportedFrameworks">
      <summary>
            Gets supported frameworks.
            </summary>
      <returns>An enumerable of NuGet frameworks.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetSupportedFrameworksAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets supported frameworks.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetFrameworkItems">
      <summary>
            Gets framework items.
            </summary>
      <returns>An enumerable of framework specific groups.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetFrameworkItemsAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets framework items.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.IsServiceable">
      <summary>
            Gets a flag indicating whether or not the package is serviceable.
            </summary>
      <returns>A flag indicating whether or not the package is serviceable.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.IsServiceableAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a flag indicating whether or not the package is serviceable.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.Boolean" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetBuildItems">
      <summary>
            Gets build items.
            </summary>
      <returns>An enumerable of framework specific groups.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetBuildItemsAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets build items.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetToolItems">
      <summary>
            Gets tool items.
            </summary>
      <returns>An enumerable of framework specific groups.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetToolItemsAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets tool items.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetContentItems">
      <summary>
            Gets content items.
            </summary>
      <returns>An enumerable of framework specific groups.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetContentItemsAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets content items.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetItems(System.String)">
      <summary>
            Gets items in the specified folder in the package.
            </summary>
      <param name="folderName">A folder in the package.</param>
      <returns>An enumerable of framework specific groups.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetItemsAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets items in the specified folder in the package.
            </summary>
      <param name="folderName">A folder in the package.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="folderName" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetPackageDependencies">
      <summary>
            Gets package dependencies.
            </summary>
      <returns>An enumerable of package dependency groups.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetPackageDependenciesAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets package dependencies.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetLibItems">
      <summary>
            Gets lib items.
            </summary>
      <returns>An enumerable of framework specific groups.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetLibItemsAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets lib items.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetReferenceItems">
      <summary>
            Gets reference items.
            </summary>
      <returns>An enumerable of framework specific groups.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetReferenceItemsAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets reference items.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetDevelopmentDependency">
      <summary>
            Gets a flag indicating whether or not the package is a development dependency.
            </summary>
      <returns>A flag indicating whether or not the package is a development dependency</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.GetDevelopmentDependencyAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a flag indicating whether or not the package is a development dependency.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.Boolean" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginPackageReader.CopyNupkgAsync(System.String,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies a package to the specified destination file path.
            </summary>
      <param name="nupkgFilePath">The destination file path.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:System.String" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="nupkgFilePath" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PluginPackageReader.NuspecReader">
      <summary>
            Gets the .nuspec reader.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.PluginProcess">
      <summary>
            Represents a plugin process.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginProcess.#ctor(System.Diagnostics.Process)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.PluginProcess" /> class.
            </summary>
      <param name="process">A plugin process.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="process" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginProcess.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginProcess.BeginReadLine">
      <summary>
            Asynchronously starts reading the standard output stream.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginProcess.CancelRead">
      <summary>
            Cancels asynchronous reading of the standard output stream.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.PluginProcess.Kill">
      <summary>
            Immediately stops the associated process.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.PluginProcess.HasExited">
      <summary>
            Gets a value indicating whether the associated process has been terminated.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.PluginProcess.Exited">
      <summary>
            Occurs when a process exits.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.PluginProcess.LineRead">
      <summary>
            Occurs when a line of output has been received.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.ProtocolConstants">
      <summary>
            Plugin protocol constants.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.ProtocolConstants.CurrentVersion">
      <summary>
            The current protocol version.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.ProtocolConstants.Version100">
      <summary>
            The minimum supported protocol version.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.ProtocolConstants.HandshakeTimeout">
      <summary>
            The default handshake timeout.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.ProtocolConstants.MaxTimeout">
      <summary>
            The maximum timeout value.
            </summary>
      <remarks>This is set by CancellationTokenSource's constructor.</remarks>
    </member>
    <member name="F:NuGet.Protocol.Plugins.ProtocolConstants.MinTimeout">
      <summary>
            The minimum timeout value.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Plugins.ProtocolConstants.RequestTimeout">
      <summary>
            The default request timeout.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.ProtocolErrorEventArgs">
      <summary>
            Protocol error event arguments.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.ProtocolErrorEventArgs.#ctor(System.Exception)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.ProtocolErrorEventArgs" /> class.
            </summary>
      <param name="exception">An exception.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="exception" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.ProtocolErrorEventArgs.#ctor(System.Exception,NuGet.Protocol.Plugins.Message)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.ProtocolErrorEventArgs" /> class.
            </summary>
      <param name="exception">An exception.</param>
      <param name="message">A message.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="exception" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="message" /> is <c>null</c>.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.ProtocolErrorEventArgs.Exception">
      <summary>
            Gets the exception.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.ProtocolErrorEventArgs.Message">
      <summary>
            Gets the message.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.ProtocolException">
      <summary>
            A plugin  protocol exception.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.ProtocolException.#ctor(System.String)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.ProtocolException" /> class.
            </summary>
      <param name="message">The exception message.</param>
    </member>
    <member name="M:NuGet.Protocol.Plugins.ProtocolException.#ctor(System.String,System.Exception)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.ProtocolException" /> class.
            </summary>
      <param name="message">The exception message.</param>
      <param name="innerException">The inner exception.</param>
    </member>
    <member name="T:NuGet.Protocol.Plugins.Receiver">
      <summary>
            Represents a unidirectional communications channel from a target.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Receiver.Close">
      <summary>
            Closes the connection.
            </summary>
      <remarks>This does not call <see cref="M:System.IDisposable.Dispose" />.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Receiver.Connect">
      <summary>
            Connects.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if this object is closed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if this method has already been called.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Receiver.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Receiver.IsClosed">
      <summary>
            Gets a flag indicating whether or not this instance is closed.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Plugins.Receiver.IsDisposed">
      <summary>
            Gets or sets a flag indicating whether or not this instance is disposed.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.Receiver.Faulted">
      <summary>
            Occurs when an unrecoverable fault has been caught.
            </summary>
    </member>
    <member name="E:NuGet.Protocol.Plugins.Receiver.MessageReceived">
      <summary>
            Occurs when a message has been received.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.RequestHandlers">
      <summary>
            A set of <see cref="T:NuGet.Protocol.Plugins.IRequestHandler" />.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.RequestHandlers.#ctor">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.RequestHandlers" /> class.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.RequestHandlers.AddOrUpdate(NuGet.Protocol.Plugins.MessageMethod,System.Func{NuGet.Protocol.Plugins.IRequestHandler},System.Func{NuGet.Protocol.Plugins.IRequestHandler,NuGet.Protocol.Plugins.IRequestHandler})">
      <summary>
            Atomically add or update a request handler for the specified message method.
            </summary>
      <param name="method">A message method.</param>
      <param name="addHandlerFunc">An add request handler function.</param>
      <param name="updateHandlerFunc">An update request handler function.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="addHandlerFunc" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="updateHandlerFunc" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.RequestHandlers.TryAdd(NuGet.Protocol.Plugins.MessageMethod,NuGet.Protocol.Plugins.IRequestHandler)">
      <summary>
            Attempts to add a request handler for the specified message method.
            </summary>
      <param name="method">A message method.</param>
      <param name="handler">A request handler.</param>
      <returns>
        <c>true</c> if added; otherwise, <c>false</c>.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="handler" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.RequestHandlers.TryGet(NuGet.Protocol.Plugins.MessageMethod,NuGet.Protocol.Plugins.IRequestHandler@)">
      <summary>
            Attempts to get a request handler for the specified message method.
            </summary>
      <param name="method">A message method.</param>
      <param name="handler">An existing request handler.</param>
      <returns>
        <c>true</c> if the request handler exists; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:NuGet.Protocol.Plugins.RequestHandlers.TryRemove(NuGet.Protocol.Plugins.MessageMethod)">
      <summary>
            Attempts to remove a request handler for the specified message method.
            </summary>
      <param name="method">A message method.</param>
      <returns>
        <c>true</c> if a request handler was removed; otherwise, <c>false</c>.</returns>
    </member>
    <member name="T:NuGet.Protocol.Plugins.CloseRequestHandler">
      <summary>
            A request handler for closing a plugin.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.CloseRequestHandler.#ctor(NuGet.Protocol.Plugins.IPlugin)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.CloseRequestHandler" /> class.
            </summary>
      <param name="plugin">A plugin.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="plugin" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.CloseRequestHandler.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection,NuGet.Protocol.Plugins.Message,NuGet.Protocol.Plugins.IResponseHandler,System.Threading.CancellationToken)">
      <summary>
            Asynchronously handles responding to a request.
            </summary>
      <param name="connection">The connection.</param>
      <param name="request">A request message.</param>
      <param name="responseHandler">A response handler.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="connection" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="responseHandler" />
            is <c>null</c>.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetCredentialsRequestHandler">
      <summary>
            A request handler for get credentials requests.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetCredentialsRequestHandler.#ctor(NuGet.Protocol.Plugins.IPlugin,System.Net.IWebProxy,NuGet.Configuration.ICredentialService)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.GetCredentialsRequestHandler" /> class.
            </summary>
      <param name="plugin">A plugin.</param>
      <param name="proxy">A web proxy.</param>
      <param name="credentialService">An optional credential service.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="plugin" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetCredentialsRequestHandler.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetCredentialsRequestHandler.AddOrUpdateSourceRepository(NuGet.Protocol.Core.Types.SourceRepository)">
      <summary>
            Adds or updates a source repository in a source repository cache.
            </summary>
      <param name="sourceRepository">A source repository.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="sourceRepository" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetCredentialsRequestHandler.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection,NuGet.Protocol.Plugins.Message,NuGet.Protocol.Plugins.IResponseHandler,System.Threading.CancellationToken)">
      <summary>
            Asynchronously handles responding to a request.
            </summary>
      <param name="connection">The connection.</param>
      <param name="request">A request message.</param>
      <param name="responseHandler">A response handler.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="connection" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="responseHandler" />
            is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetCredentialsRequestHandler.CancellationToken">
      <summary>
            Gets the <see cref="P:NuGet.Protocol.Plugins.GetCredentialsRequestHandler.CancellationToken" /> for a request.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.GetServiceIndexRequestHandler">
      <summary>
            A request handler for get service index requests.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetServiceIndexRequestHandler.#ctor(NuGet.Protocol.Plugins.IPlugin)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.GetServiceIndexRequestHandler" /> class.
            </summary>
      <param name="plugin">A plugin.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="plugin" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetServiceIndexRequestHandler.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetServiceIndexRequestHandler.AddOrUpdateSourceRepository(NuGet.Protocol.Core.Types.SourceRepository)">
      <summary>
            Adds or updates a source repository in a source repository cache.
            </summary>
      <param name="sourceRepository">A source repository.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="sourceRepository" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.GetServiceIndexRequestHandler.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection,NuGet.Protocol.Plugins.Message,NuGet.Protocol.Plugins.IResponseHandler,System.Threading.CancellationToken)">
      <summary>
            Asynchronously handles responding to a request.
            </summary>
      <param name="connection">The connection.</param>
      <param name="request">A request message.</param>
      <param name="responseHandler">A response handler.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="connection" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="responseHandler" />
            is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.GetServiceIndexRequestHandler.CancellationToken">
      <summary>
            Gets the <see cref="P:NuGet.Protocol.Plugins.GetServiceIndexRequestHandler.CancellationToken" /> for a request.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.LogRequestHandler">
      <summary>
            A request handler for logging.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.LogRequestHandler.#ctor(NuGet.Common.ILogger)">
      <summary>
            Instantiates a new instance of the <see cref="T:NuGet.Protocol.Plugins.LogRequestHandler" /> class.
            </summary>
      <param name="logger">A logger.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.LogRequestHandler.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection,NuGet.Protocol.Plugins.Message,NuGet.Protocol.Plugins.IResponseHandler,System.Threading.CancellationToken)">
      <summary>
            Asynchronously handles responding to a request.
            </summary>
      <param name="connection">The connection.</param>
      <param name="request">A request message.</param>
      <param name="responseHandler">A response handler.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="connection" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="responseHandler" />
            is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.LogRequestHandler.SetLogger(NuGet.Common.ILogger)">
      <summary>
            Sets the logger.
            </summary>
      <param name="logger">A logger.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.LogRequestHandler.GetLogLevel(NuGet.Common.ILogger)">
      <summary>
            Gets the log level of a logger.
            </summary>
      <param name="logger">A logger.</param>
      <returns>A log level.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /> is <c>null</c>.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.LogRequestHandler.CancellationToken">
      <summary>
            Gets the <see cref="P:NuGet.Protocol.Plugins.LogRequestHandler.CancellationToken" /> for a request.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler">
      <summary>
            A request handler for monitoring the exit of a NuGet process.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler.#ctor(NuGet.Protocol.Plugins.IPlugin)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler" /> class.
            </summary>
      <param name="plugin">A plugin.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="plugin" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.MonitorNuGetProcessExitRequestHandler.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection,NuGet.Protocol.Plugins.Message,NuGet.Protocol.Plugins.IResponseHandler,System.Threading.CancellationToken)">
      <summary>
            Asynchronously handles responding to a request.
            </summary>
      <param name="connection">The connection.</param>
      <param name="request">A request message.</param>
      <param name="responseHandler">A response handler.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="connection" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="responseHandler" />
            is <c>null</c>.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.SymmetricHandshake">
      <summary>
            A helper class that performs a symmetric handshake.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.SymmetricHandshake.#ctor(NuGet.Protocol.Plugins.IConnection,System.TimeSpan,NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Initializes a new instance of the <see cref="T:NuGet.Protocol.Plugins.SymmetricHandshake" /> class.
            </summary>
      <param name="connection">A connection.</param>
      <param name="handshakeTimeout">The handshake timeout.</param>
      <param name="protocolVersion">The handshaker's protocol version.</param>
      <param name="minimumProtocolVersion">The handshaker's minimum protocol version.</param>
    </member>
    <member name="M:NuGet.Protocol.Plugins.SymmetricHandshake.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.SymmetricHandshake.HandshakeAsync(System.Threading.CancellationToken)">
      <summary>
            Asynchronously handles handshaking.
            </summary>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.Versioning.SemanticVersion" />
            if the handshake was successful; otherwise, <c>null</c>.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.SymmetricHandshake.HandleResponseAsync(NuGet.Protocol.Plugins.IConnection,NuGet.Protocol.Plugins.Message,NuGet.Protocol.Plugins.IResponseHandler,System.Threading.CancellationToken)">
      <summary>
            Asynchronously handles responding to a request.
            </summary>
      <param name="connection">The connection.</param>
      <param name="request">A request message.</param>
      <param name="responseHandler">A response handler.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="connection" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="request" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="responseHandler" />
            is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="P:NuGet.Protocol.Plugins.SymmetricHandshake.CancellationToken">
      <summary>
            Gets the <see cref="P:NuGet.Protocol.Plugins.SymmetricHandshake.CancellationToken" /> for a request.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Plugins.RequestIdGenerator">
      <summary>
            A unique identifier generator.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.RequestIdGenerator.GenerateUniqueId">
      <summary>
            Generates a new unique identifier.
            </summary>
      <returns>A unique identifier.</returns>
    </member>
    <member name="T:NuGet.Protocol.Plugins.Sender">
      <summary>
            Represents a unidirectional communications channel to a target.
            </summary>
      <remarks>
            Any public static members of this type are thread safe.
            Any instance members are not guaranteed to be thread safe.
            </remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Sender.#ctor(System.IO.TextWriter)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.Sender" /> class.
            </summary>
      <param name="writer">A text writer.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="writer" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Sender.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Sender.Close">
      <summary>
            Closes the connection.
            </summary>
      <remarks>This does not call <see cref="M:System.IDisposable.Dispose" />.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Sender.Connect">
      <summary>
            Connects.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if this object is closed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if this method has already been called.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.Sender.SendAsync(NuGet.Protocol.Plugins.Message,System.Threading.CancellationToken)">
      <summary>
            Asynchronously sends a message to the target.
            </summary>
      <param name="message">The message to send.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.</returns>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if <see cref="M:NuGet.Protocol.Plugins.Sender.Connect" /> has not been called.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="message" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.StandardInputReceiver">
      <summary>
            Represents a unidirectional communications channel from a target.
            </summary>
      <remarks>
            Any public static members of this type are thread safe.
            Any instance members are not guaranteed to be thread safe.
            </remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.StandardInputReceiver.#ctor(System.IO.TextReader)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.StandardInputReceiver" /> class.
            </summary>
      <param name="reader">A text reader.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="reader" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.StandardInputReceiver.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.StandardInputReceiver.Connect">
      <summary>
            Connects.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if this object is closed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if this method has already been called.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.StandardOutputReceiver">
      <summary>
            Represents a unidirectional communications channel from a target.
            </summary>
      <remarks>
            Any public static members of this type are thread safe.
            Any instance members are not guaranteed to be thread safe.
            </remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.StandardOutputReceiver.#ctor(NuGet.Protocol.Plugins.IPluginProcess)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Plugins.StandardOutputReceiver" /> class.
            </summary>
      <param name="process">A plugin process.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="process" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.StandardOutputReceiver.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.StandardOutputReceiver.Close">
      <summary>
            Closes the connection.
            </summary>
      <remarks>This does not call <see cref="M:System.IDisposable.Dispose" />.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Plugins.StandardOutputReceiver.Connect">
      <summary>
            Connects.
            </summary>
      <exception cref="T:System.ObjectDisposedException">Thrown if this object is disposed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if this object is closed.</exception>
      <exception cref="T:System.InvalidOperationException">Thrown if this method has already been called.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.TimeoutUtilities">
      <summary>
            Timeout utilities.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.TimeoutUtilities.GetTimeout(System.String,System.TimeSpan)">
      <summary>
            Attempts to parse a legal timeout and returns a default timeout as a fallback.
            </summary>
      <param name="timeoutInSeconds">The requested timeout in seconds.</param>
      <param name="fallbackTimeout">A fallback timeout.</param>
      <returns>A <see cref="T:System.TimeSpan" /> object that represents a timeout interval.</returns>
      <exception cref="T:System.ArgumentOutOfRangeException">Thrown if <paramref name="fallbackTimeout" /> is an invalid
            timeout.</exception>
    </member>
    <member name="M:NuGet.Protocol.Plugins.TimeoutUtilities.IsValid(System.TimeSpan)">
      <summary>
            Determines if a timeout is valid.
            </summary>
      <param name="timeout">A timeout.</param>
      <returns>
        <c>true</c> if the timeout is valid; otherwise, <c>false</c>.</returns>
    </member>
    <member name="T:NuGet.Protocol.Plugins.UnixPlatformsEmbeddedSignatureVerifier">
      <summary>
            Embedded Signature Verifier for the MacOS and Linux platforms.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.UnixPlatformsEmbeddedSignatureVerifier.IsValid(System.String)">
      <summary>
            Checks if a file has a valid embedded signature.
            </summary>
      <param name="filePath">The path of a file to be checked.</param>
      <returns>
        <c>true</c> if the file has a valid signature; otherwise, <c>false</c>.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="filePath" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.PlatformNotSupportedException">Thrown if the current platform is unsupported.</exception>
    </member>
    <member name="T:NuGet.Protocol.Plugins.WindowsEmbeddedSignatureVerifier">
      <summary>
            Windows Authenticode signature verifier.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Plugins.WindowsEmbeddedSignatureVerifier.IsValid(System.String)">
      <summary>
            Checks if a file has a valid Authenticode signature.
            </summary>
      <param name="filePath">The path of a file to be checked.</param>
      <returns>
        <c>true</c> if the file has a valid signature; otherwise, <c>false</c>.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="filePath" />
            is either <c>null</c> or an empty string.</exception>
    </member>
    <member name="M:NuGet.Protocol.VisualStudio.FactoryExtensionsVS.GetVisualStudio(NuGet.Protocol.Core.Types.Repository.ProviderFactory)">
      <summary>
            Core V2 + Core V3 + VS
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.DownloadResourceResult">
      <summary>
            The result of <see cref="T:NuGet.Protocol.Core.Types.DownloadResource" />.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DownloadResourceResult.#ctor(NuGet.Protocol.Core.Types.DownloadResourceResultStatus)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Core.Types.DownloadResourceResult" /> class.
            </summary>
      <param name="status">A download resource result status.</param>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="status" />
            is either <see cref="F:NuGet.Protocol.Core.Types.DownloadResourceResultStatus.Available" /> or
            <see cref="F:NuGet.Protocol.Core.Types.DownloadResourceResultStatus.AvailableWithoutStream" />.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DownloadResourceResult.#ctor(System.IO.Stream,System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Core.Types.DownloadResourceResult" /> class.
            </summary>
      <param name="stream">A package stream.</param>
      <param name="source">A package source.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="stream" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DownloadResourceResult.#ctor(System.IO.Stream,NuGet.Packaging.PackageReaderBase,System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Core.Types.DownloadResourceResult" /> class.
            </summary>
      <param name="stream">A package stream.</param>
      <param name="packageReader">A package reader.</param>
      <param name="source">A package source.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="stream" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DownloadResourceResult.#ctor(NuGet.Packaging.PackageReaderBase,System.String)">
      <summary>
            Initializes a new <see cref="T:NuGet.Protocol.Core.Types.DownloadResourceResult" /> class.
            </summary>
      <param name="packageReader">A package reader.</param>
      <param name="source">A package source.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageReader" /> is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DownloadResourceResult.Dispose">
      <summary>
            Disposes of this instance.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.DownloadResourceResult.PackageStream">
      <summary>
            Gets the package <see cref="P:NuGet.Protocol.Core.Types.DownloadResourceResult.PackageStream" />.
            </summary>
      <remarks>The value may be <c>null</c>.</remarks>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.DownloadResourceResult.PackageSource">
      <summary>
            Gets the source containing this package, if not from cache
            </summary>
      <remarks>The value may be <c>null</c>.</remarks>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.DownloadResourceResult.PackageReader">
      <summary>
            Gets the <see cref="T:NuGet.Packaging.PackageReaderBase" /> for the package.
            </summary>
      <remarks>The value may be <c>null</c>.</remarks>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.NuGetProtocolException">
      <summary>
            Base protocol exception type containing a message and optional inner exception.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo.#ctor(NuGet.Packaging.Core.PackageIdentity,System.Collections.Generic.IEnumerable{NuGet.Packaging.PackageDependencyGroup},System.Collections.Generic.IEnumerable{NuGet.Packaging.FrameworkSpecificGroup})">
      <summary>
            DependencyInfo
            </summary>
      <param name="packageIdentity">original package identity</param>
      <param name="dependencyGroups">package dependency groups</param>
      <param name="frameworkReferenceGroups">Sequence of <see cref="T:NuGet.Packaging.FrameworkSpecificGroup" />s.</param>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo.PackageIdentity">
      <summary>
            Original package identity from the package.
            This contains the exact casing for the id and version.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo.DependencyGroups">
      <summary>
            Gets the package dependecy groups.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.FindPackageByIdDependencyInfo.FrameworkReferenceGroups">
      <summary>
            Gets the framework reference groups.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.HttpSourceCacheContext.RootTempFolder">
      <summary>
            A suggested root folder to drop temporary files under, it will get cleared by the
            disposal of the <see cref="P:NuGet.Protocol.Core.Types.HttpSourceCacheContext.SourceCacheContext" /> that was used to create this instance.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.HttpSourceCacheContext.SourceCacheContext">
      <summary>
            Inner cache context.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.INuGetResource">
      <summary>
            Represents a resource provided by a server endpoint (V2 or V3).
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.INuGetResourceProvider">
      <summary>
            INuGetResourceProviders are imported by SourceRepository. They exist as singletons which span all sources,
            and are responsible
            for determining if they should be used for the given source when TryCreate is called.
            The provider determines the caching. Resources may be cached per source, but they are normally created new
            each time
            to allow for caching within the context they were created in.
            Providers may retrieve other resources from the source repository and pass them to the resources they
            create in order
            to build on them.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.INuGetResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository,System.Threading.CancellationToken)">
      <summary>
            Attempts to create a resource for this source.
            </summary>
      <remarks>
            The provider may return true but null for the resource if the
            provider determines that it should not exist.
            </remarks>
      <param name="source">Source repository</param>
      <returns>True if this provider handles the input source.</returns>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.INuGetResourceProvider.ResourceType">
      <summary>
            Resource type provided
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.INuGetResourceProvider.Name">
      <summary>
            Name of the provider. This is used for ordering.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.INuGetResourceProvider.Before">
      <summary>
            Names of providers this should be ordered BEFORE
            Gives this instance a higher priority.
            </summary>
      <remarks>If provider: default is named here, this provider will be called BEFORE default</remarks>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.INuGetResourceProvider.After">
      <summary>
            Names of providers this should be ordered AFTER.
            Gives this instance a lower priority.
            </summary>
      <remarks>If provider: default is named here, this provider will be called AFTER default</remarks>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.ISourceRepositoryProvider">
      <summary>
            SourceRepositoryProvider composes resource providers into source repositories.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.ISourceRepositoryProvider.GetRepositories">
      <summary>
            Retrieve repositories
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.ISourceRepositoryProvider.CreateRepository(NuGet.Configuration.PackageSource)">
      <summary>
            Create a repository for one time use.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.ISourceRepositoryProvider.CreateRepository(NuGet.Configuration.PackageSource,NuGet.Protocol.FeedType)">
      <summary>
            Create a repository for one time use.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.ISourceRepositoryProvider.PackageSourceProvider">
      <summary>
            Gets the package source provider
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.IPackageSearchMetadata">
      <summary>
            Package metadata only containing select fields relevant to search results processing and presenting.
            Immutable.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.PackageSearchMetadataBuilder">
      <summary>
            Helper class allowing creation/alteration of immutable package metadata objects.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.PackageSearchMetadataExtensions">
      <summary>
            Shortcut methods to create altered metadata objects with new versions.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.VersionInfo.PackageSearchMetadata">
      <summary>
            In V2, when finding the list of versions that a package ID has, we also get all of the metadata
            associated with each version. It would be wasteful to throw this away, so we store what we have
            here. For V3, the metadata property is null. Callers that receive this type need to be able to
            fetch this package metadata some other way if this property is null.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.NuGetResourceProviderPositions">
      <summary>
            Positions to base providers on
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.NuGetResourceProviderPositions.First">
      <summary>
            The first provider called
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.NuGetResourceProviderPositions.Last">
      <summary>
            The last provider called
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.NuGetTestMode.InvokeTestFunctionAgainstTestMode``1(System.Func{``0},System.Boolean)">
      <summary>
            Intended for internal use only: utility method for testing purposes.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PackageProgressEventArgs.#ctor(NuGet.Packaging.Core.PackageIdentity,NuGet.Configuration.PackageSource,System.Double)">
      <summary>
            The status of a package action.
            </summary>
      <param name="identity">package identity</param>
      <param name="source">repository source or null</param>
      <param name="complete">0.0 - 1.0</param>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.PackageProgressEventArgs.Complete">
      <summary>
            Completion - 0.0 - 1.0
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.PackageProgressEventArgs.IsComplete">
      <summary>
            True at 100% completion
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.PluginManager">
      <summary>
            A plugin manager. This manages all the live plugins and their operation claims.
            Invoked in by both the credential provider and the PluginResourceProvider
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginManager.#ctor(NuGet.Common.IEnvironmentVariableReader,System.Lazy{NuGet.Protocol.Plugins.IPluginDiscoverer},System.Func{System.TimeSpan,NuGet.Protocol.Plugins.IPluginFactory})">
      <summary>
            Creates a new plugin manager
            </summary>
      <remarks>This is public to facilitate unit testing. This should not be called from product code</remarks>
      <param name="reader">An environment variable reader.</param>
      <param name="pluginDiscoverer">A lazy plugin discoverer.</param>
      <param name="pluginFactoryCreator">A plugin factory creator.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="reader" /> is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="pluginDiscoverer" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="pluginFactoryCreator" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginManager.Dispose">
      <summary>
            Disposes of this instance.
            This should not be called in production code as this is a singleton instance.
            The pattern is implemented because the plugin manager transitively owns objects
            that need to implement IDisposable because they potentially have managed and unmanaged resources.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginManager.FindAvailablePluginsAsync(System.Threading.CancellationToken)">
      <summary>
            Find all available plugins on the machine
            </summary>
      <param name="cancellationToken">
      </param>
      <returns>PluginDiscoveryResults</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginManager.CreatePluginsAsync(NuGet.Protocol.Core.Types.SourceRepository,System.Threading.CancellationToken)">
      <summary>
            Create plugins appropriate for the given source
            </summary>
      <param name="source">
      </param>
      <param name="cancellationToken">
      </param>
      <exception cref="T:System.ArgumentNullException">Throw if <paramref name="source" /> is null </exception>
      <returns>PluginCreationResults</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginManager.TryGetSourceAgnosticPluginAsync(NuGet.Protocol.Plugins.PluginDiscoveryResult,NuGet.Protocol.Plugins.OperationClaim,System.Threading.CancellationToken)">
      <summary>
            Creates a plugin from the given pluginDiscoveryResult.
            This plugin's operations will be source agnostic ones (Authentication)
            </summary>
      <param name="pluginDiscoveryResult">plugin discovery result</param>
      <param name="requestedOperationClaim">The requested operation claim</param>
      <param name="cancellationToken">cancellation token</param>
      <returns>A plugin creation result, null if the requested plugin cannot handle the given operation claim</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginManager.TryCreatePluginAsync(NuGet.Protocol.Plugins.PluginDiscoveryResult,NuGet.Protocol.Plugins.OperationClaim,NuGet.Protocol.Core.Types.PluginManager.PluginRequestKey,System.String,Newtonsoft.Json.Linq.JObject,System.Threading.CancellationToken)">
      <summary>
            Creates a plugin from the discovered plugin.
            We firstly check the cache for the operation claims for the given request key.
            If there is a valid cache entry, and it does contain the requested operation claim, then we start the plugin, and if need be update the cache value itself.
            If there is a valid cache entry, and it does NOT contain the requested operation claim, then we return a null.
            If there is no valid cache entry or an invalid one, we start the plugin as normally, return an active plugin even if the requested claim is not available, and write a cache entry.
            </summary>
      <param name="result">plugin discovery result</param>
      <param name="requestedOperationClaim">The requested operation claim</param>
      <param name="requestKey">plugin request key</param>
      <param name="packageSourceRepository">package source repository</param>
      <param name="serviceIndex">service index</param>
      <param name="cancellationToken">cancellation token</param>
      <returns>A plugin creation result, null if the requested plugin cannot handle the given operation claim</returns>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.PluginManager.EnvironmentVariableReader">
      <summary>
            Gets an environment variable reader.
            </summary>
      <remarks>This is non-private only to facilitate testing.</remarks>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.ProviderComparer">
      <summary>
            An imperfect sort for provider before/after
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.PluginResourceProvider">
      <summary>
            A plugin resource provider.
            </summary>
      <remarks>This is unsealed only to facilitate testing.</remarks>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginResourceProvider.TryCreate(NuGet.Protocol.Core.Types.SourceRepository,System.Threading.CancellationToken)">
      <summary>
            Asynchronously attempts to create a resource for the specified source repository.
            </summary>
      <param name="source">A source repository.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a Tuple&lt;bool, INuGetResource&gt;</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="source" /> is <c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.PluginFindPackageByIdResource">
      <summary>
            A <see cref="T:NuGet.Protocol.Core.Types.FindPackageByIdResource" /> for plugins.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginFindPackageByIdResource.#ctor(NuGet.Protocol.Plugins.IPlugin,NuGet.Protocol.Plugins.IPluginMulticlientUtilities,NuGet.Configuration.PackageSource)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Core.Types.PluginFindPackageByIdResource" /> class.
            </summary>
      <param name="plugin">A plugin.</param>
      <param name="utilities">A plugin multiclient utilities.</param>
      <param name="packageSource">A package source.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="plugin" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="utilities" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageSource" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginFindPackageByIdResource.CopyNupkgToStreamAsync(System.String,NuGet.Versioning.NuGetVersion,System.IO.Stream,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies a .nupkg to a stream.
            </summary>
      <param name="id">A package ID.</param>
      <param name="version">A package version.</param>
      <param name="destination">A destination stream.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Boolean" /> indicating whether or not the .nupkg file was copied.</returns>
      <exception cref="T:System.NotSupportedException">Thrown always.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginFindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package downloader for a package identity.
            </summary>
      <param name="packageIdentity">A package identity.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an <see cref="T:NuGet.Packaging.IPackageDownloader" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageIdentity" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginFindPackageByIdResource.GetAllVersionsAsync(System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets all package versions for a package ID.
            </summary>
      <param name="id">A package ID.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginFindPackageByIdResource.GetDependencyInfoAsync(System.String,NuGet.Versioning.NuGetVersion,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets dependency information for a specific package.
            </summary>
      <param name="id">A package id.</param>
      <param name="version">A package version.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo">
      <summary>
            A collection of package dependency groups with the content (nupkg url).
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.#ctor(NuGet.Packaging.Core.PackageIdentity,System.Boolean,System.Collections.Generic.IEnumerable{NuGet.Packaging.PackageDependencyGroup},System.String)">
      <summary>
            DependencyInfo
            </summary>
      <param name="identity">package identity</param>
      <param name="dependencyGroups">package dependency groups</param>
      <param name="contentUri">The content uri for the dependency.</param>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.Identity">
      <summary>
            Package identity
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.Listed">
      <summary>
            IsListed
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.DependencyGroups">
      <summary>
            Package dependency groups
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.RemoteSourceDependencyInfo.ContentUri">
      <summary>
            The content url of this resource.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.Repository.CreateProvider(System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.INuGetResourceProvider})">
      <summary>
            Create the default source repository provider
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.Repository.CreateProvider(System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.INuGetResourceProvider},System.String)">
      <summary>
            Find sources from nuget.config based on the root path
            </summary>
      <param name="rootPath">lowest folder path</param>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.Repository.CreateSource(System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}},System.String)">
      <summary>
            Create a SourceRepository
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.Repository.CreateSource(System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}},System.String,NuGet.Protocol.FeedType)">
      <summary>
            Create a SourceRepository
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.Repository.CreateSource(System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}},NuGet.Configuration.PackageSource)">
      <summary>
            Create a SourceRepository
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.Repository.CreateSource(System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}},NuGet.Configuration.PackageSource,NuGet.Protocol.FeedType)">
      <summary>
            Create a SourceRepository
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.ResourceProvider.#ctor(System.Type,System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
      <summary>
      </summary>
      <param name="resourceType">Type this resource provider creates</param>
      <param name="name">name used for ordering</param>
      <param name="before">providers that this provider should have precendence over</param>
      <param name="after">providers that this provider should be called after</param>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.DependencyInfoResource">
      <summary>
            Provides methods for resolving a package and its dependencies. This might change based on the new
            dependency resolver.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DependencyInfoResource.ResolvePackage(NuGet.Packaging.Core.PackageIdentity,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve dependency info for a single package.
            </summary>
      <param name="package">package id and version</param>
      <param name="projectFramework">project target framework. This is used for finding the dependency group</param>
      <param name="token">cancellation token</param>
      <returns>
            Returns dependency info for the given package if it exists. If the package is not found null is
            returned.
            </returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DependencyInfoResource.ResolvePackages(System.String,NuGet.Frameworks.NuGetFramework,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve the available packages and their dependencies.
            </summary>
      <remarks>Includes prerelease packages</remarks>
      <param name="packageId">package Id to search</param>
      <param name="projectFramework">project target framework. This is used for finding the dependency group</param>
      <param name="token">cancellation token</param>
      <returns>available packages and their dependencies</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DependencyInfoResource.ResolvePackages(System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieve the available packages and their dependencies.
            </summary>
      <remarks>Includes prerelease packages</remarks>
      <param name="packageId">package Id to search</param>
      <param name="token">cancellation token</param>
      <returns>available packages and their dependencies</returns>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.DownloadResource">
      <summary>
            Finds the download url of a nupkg
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.DownloadResource.GetDownloadResourceResultAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.PackageDownloadContext,System.String,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Downloads a package .nupkg with the provided identity. If the package is not available
            on the source but the source itself is not down or unavailable, the
            <see cref="P:NuGet.Protocol.Core.Types.DownloadResourceResult.Status" /> will be <see cref="F:NuGet.Protocol.Core.Types.DownloadResourceResultStatus.NotFound" />.
            If the operation was cancelled, the <see cref="P:NuGet.Protocol.Core.Types.DownloadResourceResult.Status" /> will be
            <see cref="F:NuGet.Protocol.Core.Types.DownloadResourceResultStatus.Cancelled" />.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.FindPackageByIdResource">
      <summary>
            A resource capable of fetching packages, package versions and package dependency information.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.FindPackageByIdResource.GetAllVersionsAsync(System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets all package versions for a package ID.
            </summary>
      <param name="id">A package ID.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.FindPackageByIdResource.GetDependencyInfoAsync(System.String,NuGet.Versioning.NuGetVersion,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets dependency information for a specific package.
            </summary>
      <param name="id">A package id.</param>
      <param name="version">A package version.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.FindPackageByIdResource.CopyNupkgToStreamAsync(System.String,NuGet.Versioning.NuGetVersion,System.IO.Stream,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously copies a .nupkg to a stream.
            </summary>
      <param name="id">A package ID.</param>
      <param name="version">A package version.</param>
      <param name="destination">A destination stream.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an
            <see cref="T:System.Boolean" /> indicating whether or not the .nupkg file was copied.</returns>
      <exception cref="T:System.ArgumentException">Thrown if <paramref name="id" />
            is either <c>null</c> or an empty string.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="version" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="destination" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.FindPackageByIdResource.GetPackageDownloaderAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Asynchronously gets a package downloader for a package identity.
            </summary>
      <param name="packageIdentity">A package identity.</param>
      <param name="cacheContext">A source cache context.</param>
      <param name="logger">A logger.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns an <see cref="T:NuGet.Packaging.IPackageDownloader" />.</returns>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageIdentity" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="cacheContext" /><c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="logger" /><c>null</c>.</exception>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.FindPackageByIdResource.GetDependencyInfo(NuGet.Packaging.NuspecReader)">
      <summary>
            Read dependency info from a nuspec.
            </summary>
      <remarks>This also verifies minClientVersion.</remarks>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.HttpHandlerResource">
      <summary>
            An HttpClient configured for the package source
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.HttpHandlerResource.ClientHandler">
      <summary>
            HttpClientHandler used for credential support.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.HttpHandlerResource.MessageHandler">
      <summary>
            Message handler containing the ClientHandler.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.LegacyFeedCapabilityResource">
      <summary>
            A resource for detecting the capabilities of a V2 feed.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.MetadataResource">
      <summary>
            Basic metadata
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.MetadataResource.GetVersions(System.String,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Get all versions of a package
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.MetadataResource.GetVersions(System.String,System.Boolean,System.Boolean,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Get all versions of a package
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.MetadataResource.Exists(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            True if the package exists in the source
            Includes unlisted.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.MetadataResource.Exists(NuGet.Packaging.Core.PackageIdentity,System.Boolean,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            True if the package exists in the source
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PackageMetadataResource.GetMetadataAsync(System.String,System.Boolean,System.Boolean,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Returns all versions of a package
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PackageMetadataResource.GetMetadataAsync(NuGet.Packaging.Core.PackageIdentity,NuGet.Protocol.Core.Types.SourceCacheContext,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Return package metadata for the input PackageIdentity
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PackageSearchResource.SearchAsync(System.String,NuGet.Protocol.Core.Types.SearchFilter,System.Int32,System.Int32,NuGet.Common.ILogger,System.Threading.CancellationToken)">
      <summary>
            Retrieves search results
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.PackageUpdateResource">
      <summary>
            Contains logics to push or delete packages in Http server or file system
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.PackageUpdateResource.TempApiKeyServiceEndpoint">
      <summary>
            Create temporary verification api key endpoint: "create-verification-key/[package id]/[package version]"
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PackageUpdateResource.GetSymbolsPath(System.String)">
      <summary>
            Get the symbols package from the original package. Removes the .nupkg and adds .symbols.nupkg
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.PluginResource">
      <summary>
            Represents a plugin resource.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginResource.#ctor(System.Collections.Generic.IEnumerable{NuGet.Protocol.Plugins.PluginCreationResult},NuGet.Configuration.PackageSource,NuGet.Configuration.ICredentialService)">
      <summary>
            Instantiates a new <see cref="T:NuGet.Protocol.Core.Types.PluginResource" /> class.
            </summary>
      <param name="pluginCreationResults">Plugin creation results.</param>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="pluginCreationResults" />
            is <c>null</c>.</exception>
      <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="packageSource" />
            is <c>null</c>.</exception>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.PluginResource.GetPluginAsync(NuGet.Protocol.Plugins.OperationClaim,System.Threading.CancellationToken)">
      <summary>
            Gets the first plugin satisfying the required operation claims for the current package source.
            </summary>
      <param name="requiredClaim">The required operation claim.</param>
      <param name="cancellationToken">A cancellation token.</param>
      <returns>A task that represents the asynchronous operation.
            The task result (<see cref="P:System.Threading.Tasks.Task`1.Result" />) returns a <see cref="T:NuGet.Protocol.Core.Types.PluginResource.GetPluginResult" />.</returns>
      <exception cref="T:System.OperationCanceledException">Thrown if <paramref name="cancellationToken" />
            is cancelled.</exception>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.SearchFilter">
      <summary>
            A search filter context that represents the UI settings
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SearchFilter.#ctor(System.Boolean)">
      <summary>
            Initializes an instance of a <see cref="T:NuGet.Protocol.Core.Types.SearchFilter" /> and validates required parameters.
            </summary>
      <param name="includePrerelease">Whether or not to allow prerelease results.</param>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SearchFilter.#ctor(System.Boolean,System.Nullable{NuGet.Protocol.Core.Types.SearchFilterType})">
      <summary>
            Initializes an instance of a <see cref="T:NuGet.Protocol.Core.Types.SearchFilter" /> and validates required parameters.
            </summary>
      <param name="includePrerelease">Whether or not to allow prerelease results.</param>
      <param name="filter">The filter to apply to the results.</param>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SearchFilter.SupportedFrameworks">
      <summary>
            Filter to only the list of packages compatible with these frameworks.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SearchFilter.IncludePrerelease">
      <summary>
            Include prerelease packages in search
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SearchFilter.IncludeDelisted">
      <summary>
            Include unlisted packages in search
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SearchFilter.PackageTypes">
      <summary>
            Restrict the search to certain package types.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SearchFilter.Filter">
      <summary>
            The optional filter type. Absense of this value indicates that all versions should be returned.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SearchFilter.OrderBy">
      <summary>
            The optional order by. Absense of this value indicates that search results should be ordered by relevance.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.SearchFilterType">
      <summary>
            The type of filter to apply to the search.
            </summary>
      <remarks>
            Here are some examples to clarify what these filters mean. Suppose the very latest version is prerelease.
            
              Version     | Prerelease | IsLatestVersion | IsAbsoluteLatestVersion
              ------------|------------|-----------------|------------------------
              8.0.1-beta1 | true       | false           | false
              8.0.3       | false      | false           | false
              9.0.1       | false      | true            | false
              9.0.2-beta1 | true       | false           | true
            
            Suppose the very latest version is not prerelease. Notice the latest version is also the absolute latest
            version. In other words, a prerelease package cannot be a latest version but a non-prerelease package can be
            both the latest version and the absolute latest version.
            
              Version     | Prerelease | IsLatestVersion | IsAbsoluteLatestVersion
              ------------|------------|-----------------|------------------------
              8.0.1-beta1 | true       | false           | false
              8.0.3       | false      | false           | false
              9.0.1       | false      | true            | true
            
            Suppose there are only prerelease versions. Notice there are no package that has IsLatestVersion as true.
            
              Version     | Prerelease | IsLatestVersion | IsAbsoluteLatestVersion
              8
              ------------|------------|-----------------|------------------------.0.1-beta1 | true       | false           | false
              9.0.2-beta1 | true       | false           | true
            
            </remarks>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.SearchFilterType.IsLatestVersion">
      <summary>
            Only select the latest stable version of a package per package ID. Given the server supports
            <see cref="F:NuGet.Protocol.Core.Types.SearchFilterType.IsAbsoluteLatestVersion" />, a package that is <see cref="F:NuGet.Protocol.Core.Types.SearchFilterType.IsLatestVersion" /> should never be
            prerelease. Also, it does not make sense to look for a <see cref="F:NuGet.Protocol.Core.Types.SearchFilterType.IsLatestVersion" /> package when also
            including prerelease.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.SearchFilterType.IsAbsoluteLatestVersion">
      <summary>
            Only select the absolute latest version of a package per package ID. It does not make sense to look for a
            <see cref="F:NuGet.Protocol.Core.Types.SearchFilterType.IsAbsoluteLatestVersion" /> when excluding prerelease.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.SearchOrderBy.Id">
      <summary>
            Order the resulting packages by package ID.
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.SourceCacheContext">
      <summary>
            Cache control settings for the V3 disk cache.
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.SourceCacheContext._generatedTempFolder">
      <summary>
            Path of temp folder if requested by GeneratedTempFolder
            </summary>
    </member>
    <member name="F:NuGet.Protocol.Core.Types.SourceCacheContext.DefaultMaxAge">
      <summary>
            Default amount of time to cache version lists.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceCacheContext.Clone">
      <summary>
            Clones the current SourceCacheContext.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceCacheContext.WithRefreshCacheTrue">
      <summary>
            Clones the current cache context and does the following:
            1. Sets MaxAge to Now
            2. RefreshMemoryCache to true
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceCacheContext.NoCache">
      <summary>
            If set, the global disk cache will not be written to or read from. Instead, a temporary directory will be
            used.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceCacheContext.DirectDownload">
      <summary>
            If set, the global disk cache will not be written to.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceCacheContext.MaxAge">
      <summary>
            Package version lists or packages from the server older than this date will be fetched from the server.
            </summary>
      <remarks>This will be ignored if <see cref="P:NuGet.Protocol.Core.Types.SourceCacheContext.NoCache" /> is true.</remarks>
      <remarks>If the value is null the default expiration will be used.</remarks>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceCacheContext.RefreshMemoryCache">
      <summary>
            Force the in-memory cache to reload. This avoids allowing other calls to populate
            the memory cache again from cached files on disk using a different source context.
            This should only be used for retries.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceCacheContext.SessionId">
      <summary>
            X-NUGET-SESSION
            This should be unique for each package operation.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceCacheContext.MaxAgeTimeSpan">
      <summary>
            Package version lists from the server older than this time span
            will be fetched from the server.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.Listed">
      <summary>
            True if the package is listed and shown in search.
            </summary>
      <remarks>This property only applies to online sources.</remarks>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.Source">
      <summary>
            Source repository the dependency information was retrieved from.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.DownloadUri">
      <summary>
            The HTTP, UNC, or local file URI to the package nupkg.
            </summary>
      <remarks>Optional</remarks>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourcePackageDependencyInfo.PackageHash">
      <summary>
            Package hash
            </summary>
      <remarks>Optional</remarks>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.SourceRepository">
      <summary>
            Represents a Server endpoint. Exposes methods to get a specific resource such as Search, Metrics service
            and so on for the given server endpoint.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.#ctor(NuGet.Configuration.PackageSource,System.Collections.Generic.IEnumerable{NuGet.Protocol.Core.Types.INuGetResourceProvider})">
      <summary>
            Source Repository
            </summary>
      <param name="source">source url</param>
      <param name="providers">Resource providers</param>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.#ctor(NuGet.Configuration.PackageSource,System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}})">
      <summary>
            Source Repository
            </summary>
      <param name="source">source url</param>
      <param name="providers">Resource providers</param>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.#ctor(NuGet.Configuration.PackageSource,System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}},NuGet.Protocol.FeedType)">
      <summary>
            Source Repository
            </summary>
      <param name="source">source url</param>
      <param name="providers">Resource providers</param>
      <param name="feedTypeOverride">Restrict the source to this feed type.</param>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.#ctor">
      <summary>
            Internal default constructor
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.GetFeedType(System.Threading.CancellationToken)">
      <summary>
            Find the FeedType of the source. If overridden FeedTypeOverride is returned.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.GetResource``1">
      <summary>
            Returns a resource from the SourceRepository if it exists.
            </summary>
      <typeparam name="T">Expected resource type</typeparam>
      <returns>Null if the resource does not exist</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.GetResource``1(System.Threading.CancellationToken)">
      <summary>
            Returns a resource from the SourceRepository if it exists.
            </summary>
      <typeparam name="T">Expected resource type</typeparam>
      <returns>Null if the resource does not exist</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.GetResourceAsync``1">
      <summary>
            Returns a resource from the SourceRepository if it exists.
            </summary>
      <typeparam name="T">Expected resource type</typeparam>
      <returns>Null if the resource does not exist</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.GetResourceAsync``1(System.Threading.CancellationToken)">
      <summary>
            Returns a resource from the SourceRepository if it exists.
            </summary>
      <typeparam name="T">Expected resource type</typeparam>
      <returns>Null if the resource does not exist</returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.Init(System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}})">
      <summary>
            Initialize provider cache
            </summary>
      <param name="providers">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepository.GetFeedType(NuGet.Configuration.PackageSource)">
      <summary>
            Get the feed type from the package source.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceRepository.FeedTypeOverride">
      <summary>
            Pre-determined feed type.
            </summary>
    </member>
    <member name="P:NuGet.Protocol.Core.Types.SourceRepository.PackageSource">
      <summary>
            Package source
            </summary>
    </member>
    <member name="T:NuGet.Protocol.Core.Types.SourceRepositoryProvider">
      <summary>
            SourceRepositoryProvider is the high level source for repository objects representing package sources.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepositoryProvider.#ctor(NuGet.Configuration.IPackageSourceProvider,System.Collections.Generic.IEnumerable{System.Lazy{NuGet.Protocol.Core.Types.INuGetResourceProvider}})">
      <summary>
            Non-MEF constructor
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepositoryProvider.GetRepositories">
      <summary>
            Retrieve repositories
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepositoryProvider.CreateRepository(NuGet.Configuration.PackageSource)">
      <summary>
            Create a repository for one time use.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.SourceRepositoryProvider.CreateRepository(NuGet.Configuration.PackageSource,NuGet.Protocol.FeedType)">
      <summary>
            Create a repository for one time use.
            </summary>
    </member>
    <member name="M:NuGet.Protocol.Core.Types.UserAgent.SetUserAgent(System.Net.Http.HttpClient)">
      <summary>
            Set user agent string on HttpClient to the static string.
            </summary>
      <param name="client">Http client</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Versioning1159689.EqualityUtility.OrderedEquals``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two enumberables for equality, ordered according to the specified key and optional comparer. Handles null values gracefully.
            </summary>
      <typeparam name="TSource">The type of the list</typeparam>
      <typeparam name="TKey">The type of the sorting key</typeparam>
      <param name="self">This list</param>
      <param name="other">The other list</param>
      <param name="keySelector">The function to extract the key from each item in the list</param>
      <param name="orderComparer">An optional comparer for comparing keys</param>
      <param name="sequenceComparer">An optional comparer for sequences</param>
    </member>
    <member name="M:NuGet.Shared.NuGet.Versioning1159689.EqualityUtility.SequenceEqualWithNullCheck``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sequence for equality, allowing either sequence to be null. If one is null, both have to be
            null for equality.
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Versioning1159689.EqualityUtility.SetEqualsWithNullCheck``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Compares two sets for equality, allowing either sequence to be null.
            If one is null, both have to be null for equality.
            </summary>
    </member>
    <member name="T:NuGet.Shared.NuGet.Versioning1159689.HashCodeCombiner">
      <summary>
            Hash code creator, based on the original NuGet hash code combiner/ASP hash code combiner implementations
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Versioning1159689.HashCodeCombiner.GetHashCode``2(``0,``1)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Versioning1159689.HashCodeCombiner.GetHashCode``3(``0,``1,``2)">
      <summary>
            Create a unique hash code for the given set of items
            </summary>
    </member>
    <member name="M:NuGet.Shared.NuGet.Versioning1159689.Extensions.AsList``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Return the enumerable as a List of T, copying if required. Optimized for common case where it is an List of T.
            Avoid mutating the return value.
            </summary>
      <remarks>https://aspnetwebstack.codeplex.com/SourceControl/latest#src/Common/CollectionExtensions.cs</remarks>
    </member>
    <member name="M:NuGet.Shared.NuGet.Versioning1159689.Extensions.AsHashSet``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Return the ISet as a HashSet of T, copying if required. Optimized for common case where it is a HashSet of T.
            Avoid mutating the return value.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.FloatRange">
      <summary>
            The floating subset of a version range.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.#ctor(NuGet.Versioning.NuGetVersionFloatBehavior)">
      <summary>
            Create a floating range.
            </summary>
      <param name="floatBehavior">Section to float.</param>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.#ctor(NuGet.Versioning.NuGetVersionFloatBehavior,NuGet.Versioning.NuGetVersion)">
      <summary>
            Create a floating range.
            </summary>
      <param name="floatBehavior">Section to float.</param>
      <param name="minVersion">Min version of the range.</param>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.#ctor(NuGet.Versioning.NuGetVersionFloatBehavior,NuGet.Versioning.NuGetVersion,System.String)">
      <summary>
            FloatRange
            </summary>
      <param name="floatBehavior">Section to float.</param>
      <param name="minVersion">Min version of the range.</param>
      <param name="releasePrefix">The original release label. Invalid labels are allowed here.</param>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.Satisfies(NuGet.Versioning.NuGetVersion)">
      <summary>
            True if the given version falls into the floating range.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.Parse(System.String)">
      <summary>
            Parse a floating version into a FloatRange
            </summary>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.TryParse(System.String,NuGet.Versioning.FloatRange@)">
      <summary>
            Parse a floating version into a FloatRange
            </summary>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.ToString">
      <summary>
            Create a floating version string in the format: 1.0.0-alpha-*
            </summary>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.Equals(NuGet.Versioning.FloatRange)">
      <summary>
            Equals
            </summary>
    </member>
    <member name="M:NuGet.Versioning.FloatRange.GetHashCode">
      <summary>
            Hash code
            </summary>
    </member>
    <member name="P:NuGet.Versioning.FloatRange.HasMinVersion">
      <summary>
            True if a min range exists.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.FloatRange.MinVersion">
      <summary>
            The minimum version of the float range. This is null for cases such as *
            </summary>
    </member>
    <member name="P:NuGet.Versioning.FloatRange.FloatBehavior">
      <summary>
            Defined float behavior
            </summary>
    </member>
    <member name="P:NuGet.Versioning.FloatRange.OriginalReleasePrefix">
      <summary>
            The original release label. Invalid labels are allowed here.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.INuGetVersionable">
      <summary>
            An item that exposes a NuGetVersion
            </summary>
    </member>
    <member name="P:NuGet.Versioning.INuGetVersionable.Version">
      <summary>
            NuGet semantic version
            </summary>
    </member>
    <member name="T:NuGet.Versioning.IVersionComparer">
      <summary>
            IVersionComparer represents a version comparer capable of sorting and determining the equality of
            SemanticVersion objects.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.IVersionRangeComparer">
      <summary>
            Version range comparer
            </summary>
    </member>
    <member name="T:NuGet.Versioning.NuGetVersion">
      <summary>
            A hybrid implementation of SemVer that supports semantic versioning as described at http://semver.org while
            not strictly enforcing it to
            allow older 4-digit versioning schemes to continue working.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.String)">
      <summary>
            Creates a NuGetVersion using NuGetVersion.Parse(string)
            </summary>
      <param name="version">Version string</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(NuGet.Versioning.NuGetVersion)">
      <summary>
            Creates a NuGetVersion from an existing NuGetVersion
            </summary>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Version,System.String,System.String)">
      <summary>
            Creates a NuGetVersion from a .NET Version
            </summary>
      <param name="version">Version numbers</param>
      <param name="releaseLabel">Prerelease label</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a NuGetVersion X.Y.Z
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32,System.String)">
      <summary>
            Creates a NuGetVersion X.Y.Z-alpha
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="releaseLabel">Prerelease label</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32,System.String,System.String)">
      <summary>
            Creates a NuGetVersion X.Y.Z-alpha#build01
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="releaseLabel">Prerelease label</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Creates a NuGetVersion X.Y.Z-alpha.1.2#build01
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="releaseLabels">Prerelease labels</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a NuGetVersion W.X.Y.Z
            </summary>
      <param name="major">W.x.y.z</param>
      <param name="minor">w.X.y.z</param>
      <param name="patch">w.x.Y.z</param>
      <param name="revision">w.x.y.Z</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String)">
      <summary>
            Creates a NuGetVersion W.X.Y.Z-alpha#build01
            </summary>
      <param name="major">W.x.y.z</param>
      <param name="minor">w.X.y.z</param>
      <param name="patch">w.x.Y.z</param>
      <param name="revision">w.x.y.Z</param>
      <param name="releaseLabel">Prerelease label</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Creates a NuGetVersion W.X.Y.Z-alpha.1#build01
            </summary>
      <param name="major">W.x.y.z</param>
      <param name="minor">w.X.y.z</param>
      <param name="patch">w.x.Y.z</param>
      <param name="revision">w.x.y.Z</param>
      <param name="releaseLabels">Prerelease labels</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.#ctor(System.Version,System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
      <summary>
            Creates a NuGetVersion from a .NET Version with additional release labels, build metadata, and a
            non-normalized version string.
            </summary>
      <param name="version">Version numbers</param>
      <param name="releaseLabels">prerelease labels</param>
      <param name="metadata">Build metadata</param>
      <param name="originalVersion">Non-normalized original version string</param>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.ToString">
      <summary>
            Returns the version string.
            </summary>
      <remarks>This method includes legacy behavior. Use ToNormalizedString() instead.</remarks>
      <remarks>Versions with SemVer 2.0.0 components are automatically normalized.</remarks>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.Parse(System.String)">
      <summary>
            Creates a NuGetVersion from a string representing the semantic version.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.TryParse(System.String,NuGet.Versioning.NuGetVersion@)">
      <summary>
            Parses a version string using loose semantic versioning rules that allows 2-4 version components followed
            by an optional special version.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.TryParseStrict(System.String,NuGet.Versioning.NuGetVersion@)">
      <summary>
            Parses a version string using strict SemVer rules.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.NuGetVersion.GetLegacyString(System.Version,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Creates a legacy version string using System.Version
            </summary>
    </member>
    <member name="P:NuGet.Versioning.NuGetVersion.Version">
      <summary>
            A System.Version representation of the version without metadata or release labels.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.NuGetVersion.IsLegacyVersion">
      <summary>
            True if the NuGetVersion is using legacy behavior.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.NuGetVersion.Revision">
      <summary>
            Revision version R (x.y.z.R)
            </summary>
    </member>
    <member name="P:NuGet.Versioning.NuGetVersion.IsSemVer2">
      <summary>
            Returns true if version is a SemVer 2.0.0 version
            </summary>
    </member>
    <member name="P:NuGet.Versioning.NuGetVersion.OriginalVersion">
      <summary>
            Returns the original, non-normalized version string.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.NuGetVersionFloatBehavior">
      <summary>
            Specifies the floating behavior type.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.None">
      <summary>
            Lowest version, no float
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.Prerelease">
      <summary>
            Highest matching pre-release label
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.Revision">
      <summary>
            x.y.z.*
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.Patch">
      <summary>
            x.y.*
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.Minor">
      <summary>
            x.*
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.Major">
      <summary>
            *
            </summary>
    </member>
    <member name="F:NuGet.Versioning.NuGetVersionFloatBehavior.AbsoluteLatest">
      <summary>
            Float major and pre-release
            </summary>
    </member>
    <member name="T:NuGet.Versioning.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.Resources.Argument_Cannot_Be_Null_Or_Empty">
      <summary>
              Looks up a localized string similar to Value cannot be null or an empty string..
            </summary>
    </member>
    <member name="P:NuGet.Versioning.Resources.Invalidvalue">
      <summary>
              Looks up a localized string similar to '{0}' is not a valid version string..
            </summary>
    </member>
    <member name="T:NuGet.Versioning.SemanticVersion">
      <summary>
            A strict SemVer implementation
            </summary>
      <summary>
            A base version operations
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(NuGet.Versioning.SemanticVersion)">
      <summary>
            Creates a SemanticVersion from an existing SemanticVersion
            </summary>
      <param name="version">Version to clone.</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
            Creates a SemanticVersion X.Y.Z
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Int32,System.Int32,System.Int32,System.String)">
      <summary>
            Creates a NuGetVersion X.Y.Z-alpha
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="releaseLabel">Prerelease label</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Int32,System.Int32,System.Int32,System.String,System.String)">
      <summary>
            Creates a NuGetVersion X.Y.Z-alpha#build01
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="releaseLabel">Prerelease label</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Creates a NuGetVersion X.Y.Z-alpha.1.2#build01
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="releaseLabels">Release labels that have been split by the dot separator</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Version,System.String,System.String)">
      <summary>
            Internal constructor.
            </summary>
      <param name="version">Version</param>
      <param name="releaseLabel">Full release label</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.String)">
      <summary>
            Internal constructor.
            </summary>
      <param name="major">X.y.z</param>
      <param name="minor">x.Y.z</param>
      <param name="patch">x.y.Z</param>
      <param name="revision">x.y.z.R</param>
      <param name="releaseLabel">Prerelease label</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Internal constructor.
            </summary>
      <param name="major">
      </param>
      <param name="minor">
      </param>
      <param name="patch">
      </param>
      <param name="revision">
      </param>
      <param name="releaseLabels">
      </param>
      <param name="metadata">
      </param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.#ctor(System.Version,System.Collections.Generic.IEnumerable{System.String},System.String)">
      <summary>
            Internal constructor.
            </summary>
      <param name="version">Version</param>
      <param name="releaseLabels">Release labels</param>
      <param name="metadata">Build metadata</param>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.ToNormalizedString">
      <summary>
            Gives a normalized representation of the version.
            This string is unique to the identity of the version and does not contain metadata.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.ToFullString">
      <summary>
            Gives a full representation of the version include metadata.
            This string is not unique to the identity of the version. Other versions 
            that differ on metadata will have a different full string representation.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.ToString">
      <summary>
            Get the normalized string.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.ToString(System.String,System.IFormatProvider)">
      <summary>
            Custom string format.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.TryFormatter(System.String,System.IFormatProvider,System.String@)">
      <summary>
            Internal string formatter.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.GetHashCode">
      <summary>
            Hash code
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.CompareTo(System.Object)">
      <summary>
            Object compare.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.CompareTo(NuGet.Versioning.SemanticVersion)">
      <summary>
            Compare to another SemanticVersion.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.Equals(System.Object)">
      <summary>
            Equals
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.Equals(NuGet.Versioning.SemanticVersion)">
      <summary>
            Equals
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.Equals(NuGet.Versioning.SemanticVersion,NuGet.Versioning.VersionComparison)">
      <summary>
            True if the VersionBase objects are equal based on the given comparison mode.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.CompareTo(NuGet.Versioning.SemanticVersion,NuGet.Versioning.VersionComparison)">
      <summary>
            Compares NuGetVersion objects using the given comparison mode.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.op_Equality(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Equals
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.op_Inequality(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Not equal
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.op_LessThan(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Less than
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.op_LessThanOrEqual(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Less than or equal
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.op_GreaterThan(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Greater than
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.op_GreaterThanOrEqual(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Greater than or equal
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.Parse(System.String)">
      <summary>
            Parses a SemVer string using strict SemVer rules.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.TryParse(System.String,NuGet.Versioning.SemanticVersion@)">
      <summary>
            Parse a version string
            </summary>
      <returns>false if the version is not a strict semver</returns>
    </member>
    <member name="M:NuGet.Versioning.SemanticVersion.ParseSections(System.String)">
      <summary>
            Parse the version string into version/release/build
            The goal of this code is to take the most direct and optimized path
            to parsing and validating a semver. Regex would be much cleaner, but
            due to the number of versions created in NuGet Regex is too slow.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.Major">
      <summary>
            Major version X (X.y.z)
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.Minor">
      <summary>
            Minor version Y (x.Y.z)
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.Patch">
      <summary>
            Patch version Z (x.y.Z)
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.ReleaseLabels">
      <summary>
            A collection of pre-release labels attached to the version.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.Release">
      <summary>
            The full pre-release label for the version.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.IsPrerelease">
      <summary>
            True if pre-release labels exist for the version.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.HasMetadata">
      <summary>
            True if metadata exists for the version.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.SemanticVersion.Metadata">
      <summary>
            Build metadata attached to the version.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionComparer">
      <summary>
            An IVersionComparer for NuGetVersion and NuGetVersion types.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparer.Default">
      <summary>
            A default comparer that compares metadata as strings.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparer.Version">
      <summary>
            A comparer that uses only the version numbers.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparer.VersionRelease">
      <summary>
            Compares versions without comparing the metadata.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparer.VersionReleaseMetadata">
      <summary>
            A version comparer that follows SemVer 2.0.0 rules.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.#ctor">
      <summary>
            Creates a VersionComparer using the default mode.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.#ctor(NuGet.Versioning.VersionComparison)">
      <summary>
            Creates a VersionComparer that respects the given comparison mode.
            </summary>
      <param name="versionComparison">comparison mode</param>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.Equals(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Determines if both versions are equal.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.Compare(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion,NuGet.Versioning.VersionComparison)">
      <summary>
            Compares the given versions using the VersionComparison mode.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.GetHashCode(NuGet.Versioning.SemanticVersion)">
      <summary>
            Gives a hash code based on the normalized version string.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.Compare(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Compare versions.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.CompareLegacyVersion(NuGet.Versioning.NuGetVersion,NuGet.Versioning.NuGetVersion)">
      <summary>
            Compares the 4th digit of the version number.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.CompareReleaseLabels(System.String[],System.String[])">
      <summary>
            Compares sets of release labels.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.CompareRelease(System.String,System.String)">
      <summary>
            Release labels are compared as numbers if they are numeric, otherwise they will be compared
            as strings.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.GetReleaseLabelsOrNull(NuGet.Versioning.SemanticVersion)">
      <summary>
            Returns an array of release labels from the version, or null.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.AreReleaseLabelsEqual(NuGet.Versioning.SemanticVersion,NuGet.Versioning.SemanticVersion)">
      <summary>
            Compare release labels
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionComparer.GetRevisionOrZero(NuGet.Versioning.SemanticVersion)">
      <summary>
            Returns the fourth version number or zero.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionComparison">
      <summary>
            Version comparison modes.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparison.Default">
      <summary>
            Semantic version 2.0.1-rc comparison with additional compares for extra NuGetVersion fields.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparison.Version">
      <summary>
            Compares only the version numbers.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparison.VersionRelease">
      <summary>
            Include Version number and Release labels in the compare.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionComparison.VersionReleaseMetadata">
      <summary>
            Include all metadata during the compare.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionExtensions">
      <summary>
            Version extension methods.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionExtensions.FindBestMatch``1(System.Collections.Generic.IEnumerable{``0},NuGet.Versioning.VersionRange,System.Func{``0,NuGet.Versioning.NuGetVersion})">
      <summary>
            Find the version that best matches the VersionRange and the floating behavior.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionExtensions.FindBestMatch(System.Collections.Generic.IEnumerable{NuGet.Versioning.INuGetVersionable},NuGet.Versioning.VersionRange)">
      <summary>
            Find the version that best matches the VersionRange and the floating behavior.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionFormatter">
      <summary>
            Custom formatter for NuGet versions.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionFormatter.Instance">
      <summary>
            A static instance of the VersionFormatter class.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionFormatter.Format(System.String,System.Object,System.IFormatProvider)">
      <summary>
            Format a version string.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionFormatter.GetFormat(System.Type)">
      <summary>
            Get version format type.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionFormatter.GetNormalizedString(NuGet.Versioning.SemanticVersion)">
      <summary>
            Create a normalized version string. This string is unique for each version 'identity' 
            and does not include leading zeros or metadata.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionFormatter.GetFullString(NuGet.Versioning.SemanticVersion)">
      <summary>
            Create the full version string including metadata. This is primarily for display purposes.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionRange">
      <summary>
            Represents a range of versions and a preferred order.
            </summary>
      <summary>
            Static factory methods for creating version range objects.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionRange.All">
      <summary>
            A range that accepts all versions, prerelease and stable.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionRange.AllFloating">
      <summary>
            A range that accepts all versions, prerelease and stable, and floats to the highest.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionRange.AllStable">
      <summary>
            A range that accepts all stable versions
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionRange.AllStableFloating">
      <summary>
            A range that accepts all versions, prerelease and stable, and floats to the highest.
            </summary>
    </member>
    <member name="F:NuGet.Versioning.VersionRange.None">
      <summary>
            A range that rejects all versions
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.#ctor(NuGet.Versioning.NuGetVersion)">
      <summary>
            Creates a range that is greater than or equal to the minVersion.
            </summary>
      <param name="minVersion">Lower bound of the version range.</param>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.#ctor(NuGet.Versioning.NuGetVersion,NuGet.Versioning.FloatRange)">
      <summary>
            Creates a range that is greater than or equal to the minVersion with the given float behavior.
            </summary>
      <param name="minVersion">Lower bound of the version range.</param>
      <param name="floatRange">Floating behavior.</param>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.#ctor(NuGet.Versioning.VersionRange,NuGet.Versioning.FloatRange)">
      <summary>
            Clones a version range and applies a new float range.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.#ctor(NuGet.Versioning.NuGetVersion,System.Boolean,NuGet.Versioning.NuGetVersion,System.Boolean,NuGet.Versioning.FloatRange,System.String)">
      <summary>
            Creates a VersionRange with the given min and max.
            </summary>
      <param name="minVersion">Lower bound of the version range.</param>
      <param name="includeMinVersion">True if minVersion satisfies the condition.</param>
      <param name="maxVersion">Upper bound of the version range.</param>
      <param name="includeMaxVersion">True if maxVersion satisfies the condition.</param>
      <param name="floatRange">The floating range subset used to find the best version match.</param>
      <param name="originalString">The original string being parsed to this object.</param>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToString">
      <summary>
            Normalized range string.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToNormalizedString">
      <summary>
            Normalized range string.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToLegacyString">
      <summary>
            A legacy version range compatible with NuGet 2.8.3
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToLegacyShortString">
      <summary>
            A short legacy version range compatible with NuGet 2.8.3.
            Ex: 1.0.0
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToString(System.String,System.IFormatProvider)">
      <summary>
            Format the version range with an IFormatProvider
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.TryFormatter(System.String,System.IFormatProvider,System.String@)">
      <summary>
            Format the range
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.PrettyPrint">
      <summary>
            Format the version range in Pretty Print format.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.FindBestMatch(System.Collections.Generic.IEnumerable{NuGet.Versioning.NuGetVersion})">
      <summary>
            Return the version that best matches the range.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.IsBetter(NuGet.Versioning.NuGetVersion,NuGet.Versioning.NuGetVersion)">
      <summary>
            Determines if a given version is better suited to the range than a current version.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToNonSnapshotRange">
      <summary>
            Removes the floating snapshot part of the minimum version if it exists.
            Ex: 1.0.0-* -&gt; 1.0.0
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.GetNonSnapshotVersion(NuGet.Versioning.NuGetVersion)">
      <summary>
            Remove the snapshot version section of a version
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.ToShortString">
      <summary>
            ToLegacyShortString that also includes floating ranges
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.Parse(System.String)">
      <summary>
            The version string is either a simple version or an arithmetic range
            e.g.
            1.0         --&gt; 1.0  x
            (,1.0]      --&gt; x  1.0
            (,1.0)      --&gt; x &lt; 1.0
            [1.0]       --&gt; x == 1.0
            (1.0,)      --&gt; 1.0 &lt; x
            (1.0, 2.0)   --&gt; 1.0 &lt; x &lt; 2.0
            [1.0, 2.0]   --&gt; 1.0  x  2.0
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.Parse(System.String,System.Boolean)">
      <summary>
            Direct parse
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.TryParse(System.String,NuGet.Versioning.VersionRange@)">
      <summary>
            Parses a VersionRange from its string representation.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.TryParse(System.String,System.Boolean,NuGet.Versioning.VersionRange@)">
      <summary>
            Parses a VersionRange from its string representation.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.Combine(System.Collections.Generic.IEnumerable{NuGet.Versioning.NuGetVersion})">
      <summary>
            Returns the smallest range that includes all given versions.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.Combine(System.Collections.Generic.IEnumerable{NuGet.Versioning.NuGetVersion},NuGet.Versioning.IVersionComparer)">
      <summary>
            Returns the smallest range that includes all given versions.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.Combine(System.Collections.Generic.IEnumerable{NuGet.Versioning.VersionRange})">
      <summary>
            Returns the smallest range that includes all given ranges.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.Combine(System.Collections.Generic.IEnumerable{NuGet.Versioning.VersionRange},NuGet.Versioning.IVersionComparer)">
      <summary>
            Returns the smallest range that includes all given ranges.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.CommonSubSet(System.Collections.Generic.IEnumerable{NuGet.Versioning.VersionRange})">
      <summary>
            Returns the greatest common range that satisfies all given ranges.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.CommonSubSet(System.Collections.Generic.IEnumerable{NuGet.Versioning.VersionRange},NuGet.Versioning.IVersionComparer)">
      <summary>
            Returns the greatest common range that satisfies all given ranges.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRange.HasValidRange(NuGet.Versioning.VersionRange)">
      <summary>
            Verify the range has an actual width.
            Ex: no version can satisfy (3.0.0, 3.0.0)
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRange.IsFloating">
      <summary>
            True if the range has a floating version above the min version.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRange.Float">
      <summary>
            Optional floating range used to determine the best version match.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRange.OriginalString">
      <summary>
            Original string being parsed to this object.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionRangeBase">
      <summary>
            A base version range that handles ranges only and not any of the preferred version logic.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.#ctor(NuGet.Versioning.NuGetVersion,System.Boolean,NuGet.Versioning.NuGetVersion,System.Boolean)">
      <summary>
            Creates a VersionRange with the given min and max.
            </summary>
      <param name="minVersion">Lower bound of the version range.</param>
      <param name="includeMinVersion">True if minVersion satisfies the condition.</param>
      <param name="maxVersion">Upper bound of the version range.</param>
      <param name="includeMaxVersion">True if maxVersion satisfies the condition.</param>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Satisfies(NuGet.Versioning.NuGetVersion)">
      <summary>
            Determines if an NuGetVersion meets the requirements.
            </summary>
      <param name="version">SemVer to compare</param>
      <returns>True if the given version meets the version requirements.</returns>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Satisfies(NuGet.Versioning.NuGetVersion,NuGet.Versioning.VersionComparison)">
      <summary>
            Determines if an NuGetVersion meets the requirements using the given mode.
            </summary>
      <param name="version">SemVer to compare</param>
      <param name="versionComparison">VersionComparison mode used to determine the version range.</param>
      <returns>True if the given version meets the version requirements.</returns>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Satisfies(NuGet.Versioning.NuGetVersion,NuGet.Versioning.IVersionComparer)">
      <summary>
            Determines if an NuGetVersion meets the requirements using the version comparer.
            </summary>
      <param name="version">SemVer to compare.</param>
      <param name="comparer">Version comparer used to determine if the version criteria is met.</param>
      <returns>True if the given version meets the version requirements.</returns>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Equals(System.Object)">
      <summary>
            Compares the object as a VersionRange with the default comparer
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.GetHashCode">
      <summary>
            Returns the hash code using the default comparer.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Equals(NuGet.Versioning.VersionRangeBase)">
      <summary>
            Default compare
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Equals(NuGet.Versioning.VersionRangeBase,NuGet.Versioning.IVersionRangeComparer)">
      <summary>
            Use the VersionRangeComparer for equality checks
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Equals(NuGet.Versioning.VersionRangeBase,NuGet.Versioning.VersionComparison)">
      <summary>
            Use a specific VersionComparison for comparison
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.Equals(NuGet.Versioning.VersionRangeBase,NuGet.Versioning.IVersionComparer)">
      <summary>
            Use a specific IVersionComparer for comparison
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.IsSubSetOrEqualTo(NuGet.Versioning.VersionRangeBase)">
      <summary>
            SubSet check
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeBase.IsSubSetOrEqualTo(NuGet.Versioning.VersionRangeBase,NuGet.Versioning.IVersionComparer)">
      <summary>
            SubSet check
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.HasLowerBound">
      <summary>
            True if MinVersion exists;
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.HasUpperBound">
      <summary>
            True if MaxVersion exists.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.HasLowerAndUpperBounds">
      <summary>
            True if both MinVersion and MaxVersion exist.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.IsMinInclusive">
      <summary>
            True if MinVersion exists and is included in the range.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.IsMaxInclusive">
      <summary>
            True if MaxVersion exists and is included in the range.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.MaxVersion">
      <summary>
            Maximum version allowed by this range.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.MinVersion">
      <summary>
            Minimum version allowed by this range.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeBase.HasPrereleaseBounds">
      <summary>
            Infer if the range should allow prerelease versions based on if the lower or upper bounds 
            contain prerelease labels.
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionRangeComparer">
      <summary>
            A version range comparer capable of using different VersionComparers to check if ranges are equivalent.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeComparer.#ctor">
      <summary>
            Default version range comparer.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeComparer.#ctor(NuGet.Versioning.VersionComparison)">
      <summary>
            Compare versions with a specific VersionComparison
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeComparer.#ctor(NuGet.Versioning.IVersionComparer)">
      <summary>
            Compare versions with a specific IVersionComparer
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeComparer.Equals(NuGet.Versioning.VersionRangeBase,NuGet.Versioning.VersionRangeBase)">
      <summary>
            Checks if two version ranges are equivalent. This follows the rules of the version comparer
            when checking the bounds.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeComparer.GetHashCode(NuGet.Versioning.VersionRangeBase)">
      <summary>
            Creates a hash code based on all properties of the range. This follows the rules of the
            version comparer when comparing the version bounds.
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeComparer.Default">
      <summary>
            Default Version comparer
            </summary>
    </member>
    <member name="P:NuGet.Versioning.VersionRangeComparer.VersionRelease">
      <summary>
            Compare versions using the Version and Release
            </summary>
    </member>
    <member name="T:NuGet.Versioning.VersionRangeFormatter">
      <summary>
            VersionRange formatter
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.#ctor">
      <summary>
            Custom version range format provider.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.Format(System.String,System.Object,System.IFormatProvider)">
      <summary>
            Format a version range string.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.GetFormat(System.Type)">
      <summary>
            Format type.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.GetNormalizedString(NuGet.Versioning.VersionRange)">
      <summary>
            Builds a normalized string with no short hand
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.GetToString(NuGet.Versioning.VersionRange)">
      <summary>
            Builds a string to represent the VersionRange. This string can include short hand notations.
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.GetLegacyShortString(NuGet.Versioning.VersionRangeBase)">
      <summary>
            Creates a legacy short string that is compatible with NuGet 2.8.3
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.GetLegacyString(NuGet.Versioning.VersionRangeBase)">
      <summary>
            Creates a legacy string that is compatible with NuGet 2.8.3
            </summary>
    </member>
    <member name="M:NuGet.Versioning.VersionRangeFormatter.PrettyPrint(NuGet.Versioning.VersionRange)">
      <summary>
            A pretty print representation of the VersionRange.
            </summary>
    </member>
  </members>
<Signature xmlns="http://www.w3.org/2000/09/xmldsig#"><SignedInfo><CanonicalizationMethod Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" /><SignatureMethod Algorithm="http://www.w3.org/2000/09/xmldsig#rsa-sha1" /><Reference URI=""><Transforms><Transform Algorithm="http://www.w3.org/2000/09/xmldsig#enveloped-signature" /><Transform Algorithm="http://www.w3.org/TR/2001/REC-xml-c14n-20010315" /></Transforms><DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1" /><DigestValue>njMsYyW5osmR9NkFu/99uYKUYDo=</DigestValue></Reference></SignedInfo><SignatureValue>bTzEEVm56KY11fG3IKfWP6rtfzDiwDn+zpVj33e7nn7XFRJ1KAKj3mEgewzCqtfWTCNFDC44zx5bEg0pdui5fonCXljMiGrcnVjmRkPXQVQMzcgLUOtEYEAwHNTao4oGvX/uNHv4a2l5tuDvkd9u3gHh2PL5DRMnpzwS1ldnkD+0E+yifRxr1PHSPmh+ouqsaOYLT2gfIArd3sjDw1ummSw03iGqCRdVAsgsNLla4OVSHFoCgS7EuNBG1o2uylpIiF/4pJzaoW1thF1vsS0xkIPh+FuaPlMXBGkggPmru4KapjY4c+RrjxuYD8Vbl4MzUOqURLSWVXwbtu/cD1G2QQ==</SignatureValue><KeyInfo><KeyValue><RSAKeyValue><Modulus>qCn+1BDI/1UKnpkAA1KP3LC/+av4Uf5cjFTCJ85MK5br24Ecy4Yrecp1frhngyaGvdYvHD7HWKqPb5X7WvynxhvBw+hMF04iPbdbVlx/11r1Lbq7pgm/BnzumP5A+TC4a/5Ab3SzuNY4ScnQhwcvMd+2vE6j0J63YntWcHVPZ78FzKOuvgCSwhtQoWE7EAABsYbQKfNA9Q/Zow9Xq2MJqNypaudHQ6e+FcQ9J6ToVlKIz1mZoQCENpvQOdIqDS/mBOK/E5aIg6lRNxhBieL5hZ2OZRo9A2TMxd5QcF3yC4Wpj7FF6Hf/g50Ju3Lg5lYIlbkrgxKJMfznWHIdvfmDIw==</Modulus><Exponent>AQAB</Exponent></RSAKeyValue></KeyValue><X509Data><X509Certificate>MIIE7TCCA9WgAwIBAgITMwAAAXl8LldOUuHK1gABAAABeTANBgkqhkiG9w0BAQUFADB5MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSMwIQYDVQQDExpNaWNyb3NvZnQgQ29kZSBTaWduaW5nIFBDQTAeFw0xNzA4MTEyMDExMTVaFw0xODA4MTEyMDExMTVaMIGDMQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMQ0wCwYDVQQLEwRNT1BSMR4wHAYDVQQDExVNaWNyb3NvZnQgQ29ycG9yYXRpb24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCoKf7UEMj/VQqemQADUo/csL/5q/hR/lyMVMInzkwrluvbgRzLhit5ynV+uGeDJoa91i8cPsdYqo9vlfta/KfGG8HD6EwXTiI9t1tWXH/XWvUturumCb8GfO6Y/kD5MLhr/kBvdLO41jhJydCHBy8x37a8TqPQnrdie1ZwdU9nvwXMo66+AJLCG1ChYTsQAAGxhtAp80D1D9mjD1erYwmo3Klq50dDp74VxD0npOhWUojPWZmhAIQ2m9A50ioNL+YE4r8TloiDqVE3GEGJ4vmFnY5lGj0DZMzF3lBwXfILhamPsUXod/+DnQm7cuDmVgiVuSuDEokx/OdYch29+YMjAgMBAAGjggFhMIIBXTATBgNVHSUEDDAKBggrBgEFBQcDAzAdBgNVHQ4EFgQU+OR+jRxjfACqzHMAStPybTiqzYEwUgYDVR0RBEswSaRHMEUxDTALBgNVBAsTBE1PUFIxNDAyBgNVBAUTKzIyOTgwMysxYWJmOWU1Zi1jZWQwLTQyZTYtYTY1ZC1kOTM1MDk1OWZlMGUwHwYDVR0jBBgwFoAUyxHoytK0FlgByTcuMxYWuUyaCh8wVgYDVR0fBE8wTTBLoEmgR4ZFaHR0cDovL2NybC5taWNyb3NvZnQuY29tL3BraS9jcmwvcHJvZHVjdHMvTWljQ29kU2lnUENBXzA4LTMxLTIwMTAuY3JsMFoGCCsGAQUFBwEBBE4wTDBKBggrBgEFBQcwAoY+aHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3BraS9jZXJ0cy9NaWNDb2RTaWdQQ0FfMDgtMzEtMjAxMC5jcnQwDQYJKoZIhvcNAQEFBQADggEBAG9La36GDdgLJlBrOojIWqn2suoqmaflBjREAe9z+60v/e341YBqNRw0xxMMtV5kPHNrjPJv02m+zjsPm/kFcjwdRuHonD42sW81qaZQVH/h1Fc9Ox56XI8BP3c/XnMnV/qnMOfUcq+L33Ei/Yrg+uAt31/y3ndk39qwBgAJq0aQo/X+gYYskyt1xhEo1+WK4hwnq5eMmsTiBxnT8mQXsSvd8wh6eFCFBjIcOVCjzYtw3gjVe29MP5rodW3kyxNXHClZOF++Raummsr5KZ7NOM+5yAW6LPvEJb9oDd8Pe0IalcePvVprkAtR+te354+yszMocwNcf6NGgpyttjZ3doc=</X509Certificate><X509Certificate>MIIFvDCCA6SgAwIBAgIKYTMmGgAAAAAAMTANBgkqhkiG9w0BAQUFADBfMRMwEQYKCZImiZPyLGQBGRYDY29tMRkwFwYKCZImiZPyLGQBGRYJbWljcm9zb2Z0MS0wKwYDVQQDEyRNaWNyb3NvZnQgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcNMTAwODMxMjIxOTMyWhcNMjAwODMxMjIyOTMyWjB5MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSMwIQYDVQQDExpNaWNyb3NvZnQgQ29kZSBTaWduaW5nIFBDQTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALJyWVwZMGS/HZpgICBCmXZTbD4b1m/My/Hqa/6XFhDg3zp0gxq3L6Ay7P/ewkJOI9VyANs1VwqJyq4gSfTwaKxNS42lvXlLcZtHB9r9Jd+ddYjPqnNEf9eB2/O98jakyVxF3K+tPeAoaJcap6Vyc1bxF5Tk/TWUcqDWdl8ed0WDhTgW0HNbBbpnUo2lsmkv2hkL/pJ0KeJ2L1TdFDBZ+NKNYv3LyV9GMVC5JxPkQDDPcikQKCLHN049oDI9kM2hOAaFXE5WgigqBTK3S9dPY+fSLWLxRT3nrAgA9kahntFbjCZT6HqqSvJGzzc8OJ60d1ylF56NyxGPVjzBrAlfA9MCAwEAAaOCAV4wggFaMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFMsR6MrStBZYAck3LjMWFrlMmgofMAsGA1UdDwQEAwIBhjASBgkrBgEEAYI3FQEEBQIDAQABMCMGCSsGAQQBgjcVAgQWBBT90TFO0yaKleGYYDuoMW+mPLzYLTAZBgkrBgEEAYI3FAIEDB4KAFMAdQBiAEMAQTAfBgNVHSMEGDAWgBQOrIJgQFYnl+UlE/wq4QpTlVnkpDBQBgNVHR8ESTBHMEWgQ6BBhj9odHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL2NybC9wcm9kdWN0cy9taWNyb3NvZnRyb290Y2VydC5jcmwwVAYIKwYBBQUHAQEESDBGMEQGCCsGAQUFBzAChjhodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vcGtpL2NlcnRzL01pY3Jvc29mdFJvb3RDZXJ0LmNydDANBgkqhkiG9w0BAQUFAAOCAgEAWTk+fyZGr+tvQLEytWrrDi9uqEn361917Uw7LddDrQv+y+ktMaMjzHxQmIAhXaw9L0y6oqhWnONwu7i0+Hm1SXL3PupBf8rhDBdpy6WcIC36C1DEVs0t40rSvHDnqA2iA6VW4LiKS1fylUKc8fPv7uOGHzQ8uFaa8FMjhSqkghyT4pQHHfLiTviMocroE6WRTsgb0o9ylSpxbZsa+BzwU9ZnzCL/XB3Nooy9J7J5Y1ZEolHN+emjWFbdmwJFRC9f9Nqu1IIybvyklRPk62nnqaIsvsgrEA5ljpnb9aL6EiYJZTiU8XofSrvR4Vbo0HiWGFzJNRZf3ZMdSY4tvq00RBzuEBUaAF3dNVshzpjHCe6FDoxPbQ4TTj18KUicctHzbMrB7HCjV5JXfZSNoBtIA1r3z6NnCnSlNu0tLxfI5nI3EvRvsTxngvlSso0zFmUeDordEN5k9G/ORtTTF+l5xAS00/ss3x+KnqwK+xMnQK3k+eGpf0a7B2BHZWBATrBC7E7ts3Z52Ao0CW0cgDEf4g5U3eWh++VHEK1kmP9QFi58vwUheuKVQSdpw5OPlcmN2Jshrg1cnPCiroZogwxqLbt2awAdlq3yFnv2FoMkuYjPaqhHMS+a3ONxPdcAfmJH0c6IybgY+g5yjcGjPa8CQGr/aZuW4hCoELQ3UAjWwz0=</X509Certificate><X509Certificate>MIIFmTCCA4GgAwIBAgIQea0WoUqgpa1Mc1j0BxMuZTANBgkqhkiG9w0BAQUFADBfMRMwEQYKCZImiZPyLGQBGRYDY29tMRkwFwYKCZImiZPyLGQBGRYJbWljcm9zb2Z0MS0wKwYDVQQDEyRNaWNyb3NvZnQgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcNMDEwNTA5MjMxOTIyWhcNMjEwNTA5MjMyODEzWjBfMRMwEQYKCZImiZPyLGQBGRYDY29tMRkwFwYKCZImiZPyLGQBGRYJbWljcm9zb2Z0MS0wKwYDVQQDEyRNaWNyb3NvZnQgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDzXfqAZ9Rap6kMLJAg0DUIPHWEzbcHiZyJ2t7Ow2D6kWhanpRxKRh2fMLgyCV2lA5Y+gQ0Nubfr/eAuulYCyuT5Z0F43cikfc0ZDwikR1e4QmQvBT+/HVYGeF5tweSo66IWQjYnwfKA1j8aCltMtfSqMtL/OELSDJP5uu4rU/kXG8TlJnbldV126gat5SRtHdb9UgMj2p5fRRwBH1tr5D12nDYR7e/my9s5wW34RFgrHmRFHzF1qbk4X7Vw37lktI8ALU2gt554W3ztW74nzPJy1J9c5g224uha6KVl5uj3sJNJv8GlmclBsjnrOTuEjOVMZnINQhONMp5U9W1vmMyWUA2wKVOBE0921sHM+RYv+8/U2TYQlk1V/0PRXwkBE2e1jh0EZcikM5oRHSSb9VLb7CG48c2QqDQ/MHAWvmjYbkwR3GWChawkcBCle8Qfyhq4yofseTNAz93cQTHIPxJDx1FiKTXy36IrY4t7EXbxFEEySr87IaemhGXW97OU4jm4rf9rJXCKEDb7wSQ34EzOdmyRaUjhwalVYkxuwYtYA5BGH0fLrWXyxHrFdUkpZTvFRSJ/Utz+jJb/NEzAPlZYnAHMuouq0Ate8rdIWcbMJmPFqojqEHRsG4RmzbE3kB0nOFYZcFgHnpbOMiPuwQmfNQWQOW2a2yqhv0Av87BNQIDAQABo1EwTzALBgNVHQ8EBAMCAcYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUDqyCYEBWJ5flJRP8KuEKU5VZ5KQwEAYJKwYBBAGCNxUBBAMCAQAwDQYJKoZIhvcNAQEFBQADggIBAMURTQM6YN1dUhF3j7K7NsiyBb+0t6jYIJ1cEwO2HCL6BhM1tshj1JpHbyZX0lXxBLEmX9apUGigvNK4bszD6azfGc14rFl0rGY0NsQbPmw4TDMOMBINoyb+UVMA/69aToQNDx/kbQUuToVLjWwzb1TSZKu/UK99ejmgN+1jAw/8EwbOFjbUVDuVG1FiOuVNF9QFOZKaJ6hbqr3su77jIIlgcWxWs6UT0G0OI36VA+1oPfLYY7hrTbboMLXhypRL96KqXZkwsj2nwlFsKCABJCcrSwC3nRFrcL6yEIK8DJto0I07JIeqmShynTNfWZC99d6TnjpiWjQ54ohVHbkGsMGJay3XacMZEjaE0Mmg2v8vaXiy5Xra69cMwPe9Yxe4ORM4ojZbe/KFVmodZGLBOOKqv1FmopT1EpxmIhBr8rcwki3yKfA9OxRDaKLxnCk3y844ICVtfGfzfiQSJAMIgUfspZ6X9RjXz7vV73aW7/3O21adlaBC+ZdY4dcxItNfWeY+biIA6kOEtiXb2fMIVmjAZGsdfOy2k6JiV24u2OdYj8QxSSbd3ik1h/UwcXBbFDxpvYkSfesuo/7Yf56CWlIKK8FDK9kwiJ/IEPuJjeahhXUzfmye23MTZGJppS99ypZtn/gETTCSPW4hFCHJPeDD/YprnUr90aGdmUN3P7Da</X509Certificate></X509Data></KeyInfo><Object Id="ts-countersig"><X509Data><X509Certificate>MIIGBzCCA++gAwIBAgIKYRZoNAAAAAAAHDANBgkqhkiG9w0BAQUFADBfMRMwEQYKCZImiZPyLGQBGRYDY29tMRkwFwYKCZImiZPyLGQBGRYJbWljcm9zb2Z0MS0wKwYDVQQDEyRNaWNyb3NvZnQgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcNMDcwNDAzMTI1MzA5WhcNMjEwNDAzMTMwMzA5WjB3MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSEwHwYDVQQDExhNaWNyb3NvZnQgVGltZS1TdGFtcCBQQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCfoWyx39tIkip8ay4Z4b3i48WZUSNQrc7dGE4kD+7Rp9FMrXQwIBHrB9VUlRVJlBtCkq6YXDAm2gBr6Hu97IkHD/cOBJjwicwfyzMkh53y9GccLPx754gd6udOo6HBI1PKjfpFzwnQXq/QsEIEovmmbJNn1yjcRlOwhtDlKEYuJ6yGT1VSDOQDLPtqkJAwbofzWTCd+n7Wl7PoIZd++NIT8wi3U21StEWQn0gASkdmEScpZqiX5NMGgUqi+YSnEUcUCYKfhO1VeP4Bmh1QCIUAEDBG7bfeI0a7xC1Un68eeEExd8yb3zuDk6FhArUdDbH895uyAc4iS1T/+QXDwiALAgMBAAGjggGrMIIBpzAPBgNVHRMBAf8EBTADAQH/MB0GA1UdDgQWBBQjNPjZUkZwCu1A+3b7syuwwzWzDzALBgNVHQ8EBAMCAYYwEAYJKwYBBAGCNxUBBAMCAQAwgZgGA1UdIwSBkDCBjYAUDqyCYEBWJ5flJRP8KuEKU5VZ5KShY6RhMF8xEzARBgoJkiaJk/IsZAEZFgNjb20xGTAXBgoJkiaJk/IsZAEZFgltaWNyb3NvZnQxLTArBgNVBAMTJE1pY3Jvc29mdCBSb290IENlcnRpZmljYXRlIEF1dGhvcml0eYIQea0WoUqgpa1Mc1j0BxMuZTBQBgNVHR8ESTBHMEWgQ6BBhj9odHRwOi8vY3JsLm1pY3Jvc29mdC5jb20vcGtpL2NybC9wcm9kdWN0cy9taWNyb3NvZnRyb290Y2VydC5jcmwwVAYIKwYBBQUHAQEESDBGMEQGCCsGAQUFBzAChjhodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vcGtpL2NlcnRzL01pY3Jvc29mdFJvb3RDZXJ0LmNydDATBgNVHSUEDDAKBggrBgEFBQcDCDANBgkqhkiG9w0BAQUFAAOCAgEAEJeKw1wDRDbd6bStd9vOeVFNAbEudHFbbQwTq86+e4+4LtQSooxtYrhXAstOIBNQmd16QOJXu69YmhzhHQGGrLt48ovQ7DsB7uK+jwoFyI1I4vBTFd1Pq5Lk541q1YDB5pTyBi+FA+mRKiQicPv2/OR4mS4N9wficLwYTp2OawpylbihOZxnLcVRDupiXD8WmIsgP+IHGjL5zDFKdjE9K3ILyOpwPf+FChPfwgphjvDXuBfrTot/xTUrXqO/67x9C0J71FNyIe4wyrt4ZVxbARcKFA7S2hSY9Ty5ZlizLS/n+YWGzFFW6J1wlGysOUzU9nm/qhh6YinvopspNAZ3GmLJPR5tH4LwC8csu89Ds+X57H2146SodDW4TsVxIxImdgs8UoxxWkZDFLyzs7BNZ8ifQv+AeSGAnhUwZuhCEl4ayJ4iIdBD6Svpu/RIzCzU2DKATCYqSCRfWupW76bemZ3KOm+9gSd0BhHudiG/m4LBJ1S2sWo9iaF2YbRuoROmv6pH8BJv/YoybLL+31HIjCPJZr2dHYcSZAI9La9Zj7jkIeW1sMpjtHhUBdRBLlCslLCleKuzoJZ1GtmShxN1Ii8yqAhuoFuMJb+g74TKIdbrHk/Jmu5J4PcBZW+JC33Iacjmbuqnl84xKf8OxVtc2E0bodj6L54/LlUWa8kTo/0=</X509Certificate><X509Certificate>MIIEwjCCA6qgAwIBAgITMwAAALwLLhp7irHHkQAAAAAAvDANBgkqhkiG9w0BAQUFADB3MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSEwHwYDVQQDExhNaWNyb3NvZnQgVGltZS1TdGFtcCBQQ0EwHhcNMTYwOTA3MTc1ODQ3WhcNMTgwOTA3MTc1ODQ3WjCBsjELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEMMAoGA1UECxMDQU9DMScwJQYDVQQLEx5uQ2lwaGVyIERTRSBFU046MTJCNC0yRDVGLTg3RDQxJTAjBgNVBAMTHE1pY3Jvc29mdCBUaW1lLVN0YW1wIFNlcnZpY2UwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCrW5IBRZQaAQPTHTCSXDRgGi/lbqVTqt3Mp5XqqbEkIZowQp8M/Gyv+1TmRpbFaQIQ4oQ7AqZRsvd+PMGtZjo6vUBRyeLKpnHq1a9XYeiGkoGaJu/98Ued3Z+sFD45bhzi6tLzY6kq98KIYqK7XsI76kqVU3oIyiETzzoANwuXUNSnm9lAN3l/G8xgDm/3qBWMSjkBvg2GeZ573WqYP6fImkO9U0bRtuIr6mybzvXUUO+rg6hhdrEnLGI4QQ7frEWReYeyMlgjC7VRaJy2gomkh+sEmxxivphgOuJrtPgUhdIlyTkUTtyudNUd/6gTE4zt9TsmFf5wGCsxpbZqKFW3AgMBAAGjggEJMIIBBTAdBgNVHQ4EFgQUyHJk5pJfz0FWFyn1nlRJFHyq/vcwHwYDVR0jBBgwFoAUIzT42VJGcArtQPt2+7MrsMM1sw8wVAYDVR0fBE0wSzBJoEegRYZDaHR0cDovL2NybC5taWNyb3NvZnQuY29tL3BraS9jcmwvcHJvZHVjdHMvTWljcm9zb2Z0VGltZVN0YW1wUENBLmNybDBYBggrBgEFBQcBAQRMMEowSAYIKwYBBQUHMAKGPGh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2kvY2VydHMvTWljcm9zb2Z0VGltZVN0YW1wUENBLmNydDATBgNVHSUEDDAKBggrBgEFBQcDCDANBgkqhkiG9w0BAQUFAAOCAQEAPiS9UtetZjCdEkaanFlC+NU/Ti+PUD6O+P6yCASPI6+qK20tB16FXJg7rXRee3c/E2wcyWuxeL/0oLkj4LunxQoDDhoOjM9w9SnrWjki/kbkEdbgi1Pl4ebDSu+6Six3fdRrLowgkQwXxkCoUWwyFS9dL5BbC5lSzHlOiXiWVlc94vr39sMaoqsxl6A6Ud9YvbohYuiKJsdpSrLW97wXO66h+Cx289JckOmomW1Zum3ppfgp+5lJJBxySomU08S8G5QOOrvjO4KsQ55eHHVWJXhnGL+zhghaSf5TIQuDdohDOnNb+FImqnwn3++hmpbkAVWdFUNDNlJemia/hMH9vw==</X509Certificate></X509Data><CounterSignature ts-format="cms-timestamp-message" xmlns="http://schemas.microsoft.com/xmldsig/timestamp/2003">MIIRowYJKoZIhvcNAQcCoIIRlDCCEZACAQMxCzAJBgUrDgMCGgUAMIIBEwYJKoZIhvcNAQcBoIIBBASCAQBtPMQRWbnopjXV8bcgp9Y/qu1/MOLAOf7OlWPfd7ueftcVEnUoAqPeYSB7DMKq19ZMI0UMLjjPHlsSDSl26Ll+icJeWMyIatydWOZGQ9dBVAzNyAtQ60RgQDAc1Nqjiga9f+40e/hraXm24O+R327eAeHY8vkNEyenPBLWV2eQP7QT7KJ9HGvU8dI+aH6i6qxo5gtPaB8gCt3eyMPDW6aZLDTeIaoJF1UCyCw0uVrg5VIcWgKBLsS40EbWja7KWkiIX/iknNqhbW2EXW+xLTGQg+H4W5o+UxcEaSCA+au7gpqmNjhz5GuPG5gPxVuXgzNQ6pREtJZVfBu279wPUbZBoIIOTDCCBgcwggPvoAMCAQICCmEWaDQAAAAAABwwDQYJKoZIhvcNAQEFBQAwXzETMBEGCgmSJomT8ixkARkWA2NvbTEZMBcGCgmSJomT8ixkARkWCW1pY3Jvc29mdDEtMCsGA1UEAxMkTWljcm9zb2Z0IFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9yaXR5MB4XDTA3MDQwMzEyNTMwOVoXDTIxMDQwMzEzMDMwOVowdzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEhMB8GA1UEAxMYTWljcm9zb2Z0IFRpbWUtU3RhbXAgUENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAn6Fssd/bSJIqfGsuGeG94uPFmVEjUK3O3RhOJA/u0afRTK10MCAR6wfVVJUVSZQbQpKumFwwJtoAa+h7veyJBw/3DgSY8InMH8szJIed8vRnHCz8e+eIHernTqOhwSNTyo36Rc8J0F6v0LBCBKL5pmyTZ9co3EZTsIbQ5ShGLieshk9VUgzkAyz7apCQMG6H81kwnfp+1pez6CGXfvjSE/MIt1NtUrRFkJ9IAEpHZhEnKWaol+TTBoFKovmEpxFHFAmCn4TtVXj+AZodUAiFABAwRu233iNGu8QtVJ+vHnhBMXfMm987g5OhYQK1HQ2x/PebsgHOIktU//kFw8IgCwIDAQABo4IBqzCCAacwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUIzT42VJGcArtQPt2+7MrsMM1sw8wCwYDVR0PBAQDAgGGMBAGCSsGAQQBgjcVAQQDAgEAMIGYBgNVHSMEgZAwgY2AFA6sgmBAVieX5SUT/CrhClOVWeSkoWOkYTBfMRMwEQYKCZImiZPyLGQBGRYDY29tMRkwFwYKCZImiZPyLGQBGRYJbWljcm9zb2Z0MS0wKwYDVQQDEyRNaWNyb3NvZnQgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHmCEHmtFqFKoKWtTHNY9AcTLmUwUAYDVR0fBEkwRzBFoEOgQYY/aHR0cDovL2NybC5taWNyb3NvZnQuY29tL3BraS9jcmwvcHJvZHVjdHMvbWljcm9zb2Z0cm9vdGNlcnQuY3JsMFQGCCsGAQUFBwEBBEgwRjBEBggrBgEFBQcwAoY4aHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3BraS9jZXJ0cy9NaWNyb3NvZnRSb290Q2VydC5jcnQwEwYDVR0lBAwwCgYIKwYBBQUHAwgwDQYJKoZIhvcNAQEFBQADggIBABCXisNcA0Q23em0rXfbznlRTQGxLnRxW20ME6vOvnuPuC7UEqKMbWK4VwLLTiATUJndekDiV7uvWJoc4R0Bhqy7ePKL0Ow7Ae7ivo8KBciNSOLwUxXdT6uS5OeNatWAweaU8gYvhQPpkSokInD79vzkeJkuDfcH4nC8GE6djmsKcpW4oTmcZy3FUQ7qYlw/FpiLID/iBxoy+cwxSnYxPStyC8jqcD3/hQoT38IKYY7w17gX606Lf8U1K16jv+u8fQtCe9RTciHuMMq7eGVcWwEXChQO0toUmPU8uWZYsy0v5/mFhsxRVuidcJRsrDlM1PZ5v6oYemIp76KbKTQGdxpiyT0ebR+C8AvHLLvPQ7Pl+ex9teOkqHQ1uE7FcSMSJnYLPFKMcVpGQxS8s7OwTWfIn0L/gHkhgJ4VMGboQhJeGsieIiHQQ+kr6bv0SMws1NgygEwmKkgkX1rqVu+m3pmdyjpvvYEndAYR7nYhv5uCwSdUtrFqPYmhdmG0bqETpr+qR/ASb/2KMmyy/t9RyIwjyWa9nR2HEmQCPS2vWY+45CHltbDKY7R4VAXUQS5QrJSwpXirs6CWdRrZkocTdSIvMqgIbqBbjCW/oO+EyiHW6x5PyZruSeD3AWVviQt9yGnI5m7qp5fOMSn/DsVbXNhNG6HY+i+ePy5VFmvJE6P9MIIEwjCCA6qgAwIBAgITMwAAALwLLhp7irHHkQAAAAAAvDANBgkqhkiG9w0BAQUFADB3MQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMSEwHwYDVQQDExhNaWNyb3NvZnQgVGltZS1TdGFtcCBQQ0EwHhcNMTYwOTA3MTc1ODQ3WhcNMTgwOTA3MTc1ODQ3WjCBsjELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEMMAoGA1UECxMDQU9DMScwJQYDVQQLEx5uQ2lwaGVyIERTRSBFU046MTJCNC0yRDVGLTg3RDQxJTAjBgNVBAMTHE1pY3Jvc29mdCBUaW1lLVN0YW1wIFNlcnZpY2UwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCrW5IBRZQaAQPTHTCSXDRgGi/lbqVTqt3Mp5XqqbEkIZowQp8M/Gyv+1TmRpbFaQIQ4oQ7AqZRsvd+PMGtZjo6vUBRyeLKpnHq1a9XYeiGkoGaJu/98Ued3Z+sFD45bhzi6tLzY6kq98KIYqK7XsI76kqVU3oIyiETzzoANwuXUNSnm9lAN3l/G8xgDm/3qBWMSjkBvg2GeZ573WqYP6fImkO9U0bRtuIr6mybzvXUUO+rg6hhdrEnLGI4QQ7frEWReYeyMlgjC7VRaJy2gomkh+sEmxxivphgOuJrtPgUhdIlyTkUTtyudNUd/6gTE4zt9TsmFf5wGCsxpbZqKFW3AgMBAAGjggEJMIIBBTAdBgNVHQ4EFgQUyHJk5pJfz0FWFyn1nlRJFHyq/vcwHwYDVR0jBBgwFoAUIzT42VJGcArtQPt2+7MrsMM1sw8wVAYDVR0fBE0wSzBJoEegRYZDaHR0cDovL2NybC5taWNyb3NvZnQuY29tL3BraS9jcmwvcHJvZHVjdHMvTWljcm9zb2Z0VGltZVN0YW1wUENBLmNybDBYBggrBgEFBQcBAQRMMEowSAYIKwYBBQUHMAKGPGh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS9wa2kvY2VydHMvTWljcm9zb2Z0VGltZVN0YW1wUENBLmNydDATBgNVHSUEDDAKBggrBgEFBQcDCDANBgkqhkiG9w0BAQUFAAOCAQEAPiS9UtetZjCdEkaanFlC+NU/Ti+PUD6O+P6yCASPI6+qK20tB16FXJg7rXRee3c/E2wcyWuxeL/0oLkj4LunxQoDDhoOjM9w9SnrWjki/kbkEdbgi1Pl4ebDSu+6Six3fdRrLowgkQwXxkCoUWwyFS9dL5BbC5lSzHlOiXiWVlc94vr39sMaoqsxl6A6Ud9YvbohYuiKJsdpSrLW97wXO66h+Cx289JckOmomW1Zum3ppfgp+5lJJBxySomU08S8G5QOOrvjO4KsQ55eHHVWJXhnGL+zhghaSf5TIQuDdohDOnNb+FImqnwn3++hmpbkAVWdFUNDNlJemia/hMH9v6GCA3cwggJfAgEBMIHioYG4pIG1MIGyMQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4GA1UEBxMHUmVkbW9uZDEeMBwGA1UEChMVTWljcm9zb2Z0IENvcnBvcmF0aW9uMQwwCgYDVQQLEwNBT0MxJzAlBgNVBAsTHm5DaXBoZXIgRFNFIEVTTjoxMkI0LTJENUYtODdENDElMCMGA1UEAxMcTWljcm9zb2Z0IFRpbWUtU3RhbXAgU2VydmljZaIlCgEBMAkGBSsOAwIaBQADFQDN+WiWmGSTcpFro4rYbTjCjLJnRqCBwTCBvqSBuzCBuDELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1vbmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlvbjEMMAoGA1UECxMDQU9DMScwJQYDVQQLEx5uQ2lwaGVyIE5UUyBFU046MjY2NS00QzNGLUM1REUxKzApBgNVBAMTIk1pY3Jvc29mdCBUaW1lIFNvdXJjZSBNYXN0ZXIgQ2xvY2swDQYJKoZIhvcNAQEFBQACBQDfA217MCIYDzIwMTgwNzI1MjE0MzIzWhgPMjAxODA3MjYyMTQzMjNaMHcwPQYKKwYBBAGEWQoEATEvMC0wCgIFAN8DbXsCAQAwCgIBAAICBooCAf8wBwIBAAICGtgwCgIFAN8EvvsCAQAwNgYKKwYBBAGEWQoEAjEoMCYwDAYKKwYBBAGEWQoDAaAKMAgCAQACAxbjYKEKMAgCAQACAwehIDANBgkqhkiG9w0BAQUFAAOCAQEAeDHt1fS2z8fp9y6G6VFpuzEPFbRa6+sCxxCwu2/EoseEBVrezwNtL0zqjWnMqX1GHMM45h5iIvbpjpw3tn44g1ZWliNbNZU3g+VpT1a3l0MT/wFaukVxP3RU7aeaozJIL0TvUTdsR2sRPbbIgO5B0bbM12nUxirTw7TkeFTbFAEBmcdrAwLf+guG7NNGHZYwGRyJOdL28aTGbzAdEn2f2VMjZ0x6NxjWwn+c+VfNKZh66M6syCd7ASsN9MCaBtCRTy3sJtVrK7IzggjOCuQBVDQjF0Cy9pmtcXVWEzDX7QhDKf+hN2JcyleXVvwCVLHcfmwK/xJwpK/8SbAwer1OZTGCAhUwggIRAgEBMIGOMHcxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpXYXNoaW5ndG9uMRAwDgYDVQQHEwdSZWRtb25kMR4wHAYDVQQKExVNaWNyb3NvZnQgQ29ycG9yYXRpb24xITAfBgNVBAMTGE1pY3Jvc29mdCBUaW1lLVN0YW1wIFBDQQITMwAAALwLLhp7irHHkQAAAAAAvDAJBgUrDgMCGgUAoF0wGAYJKoZIhvcNAQkDMQsGCSqGSIb3DQEHATAcBgkqhkiG9w0BCQUxDxcNMTgwNzI1MjMyMjM3WjAjBgkqhkiG9w0BCQQxFgQU5/ReYszY1dCxtmpZWvil4S5JvO8wDQYJKoZIhvcNAQEFBQAEggEAmXnifwUfPUqs+BTi0ONoQL0jJYuzRt7WIleZtqt5X/VGJxz80CCSQGmyy6BXPT1ntikgJQQkX8LBqwr1IeCR+y89Rzmfi2WfqocKBrp/BDejpLywvOLsdi13aMmylEEAV/yuMQ+POmMRoby/80U/Q2chF7ywz+kJjrzO9Jpw30HWdEzhOJPiceorYcPkmdOGjvsE+sJBNUuqoojITQUFKokCD+d/bwRydQ0z4BFbfSc+hX+CAe3SGCXIWe28nNl6byB4QA0752R1+ZYLTEvVYROlzEshZzAsIGAPiyjkcgQ+YxsIfO1s5SCLF1oDDIjpiBvbqD3pAa0GG9oncmb7tw==</CounterSignature></Object></Signature></doc>