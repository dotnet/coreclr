# Standalone GC Eventing Design

Author: Sean Gillespie (@swgillespie) - 2017

This document aims to provide a specification for how a standalone GC fires
events that can be collected by trace collectors. Such a feature is highly desirable
for a standalone GC since it is the primary way that is used to reason about
GC performance. Since a standalone GC is not permitted to link against the rest of the runtime, all
communication betwene the runtime and the GC most pass through dynamically-dispatched interfaces.

## Definitions

* An **event** is some unit of information that the runtime can issue if requested. In general,
this is used for lightweight tracing. Managed code can issue events using
`System.Diagnostics.Tracing.EventSource`. Native code (i.e. the runtime) issues events by calling macros
that delegate the issuing of events to autogenerated code that is generated to interface with the
underlying event implementation. Events are only issued if they are turned on; the mechanism by which
events are turned on is not in the scope of this document
* The **payload** of an event is some amount of data that is delivered with the event itself. Its size
may be variable. Most events that are fired by the runtime have a schema (predefined layout), but it
is not a requirement.

## Goals

The goal of this document is to describe a system that allows for the efficient firing of
performance events by a standalone GC. This system must have two properties in order to be
acceptable:

1. It must be *efficient* to query whether or not a particular event is turned on. It is not acceptable
to perform an indirection (i.e. cross the GC/EE interface boundary) in order to get this information.
2. The cost of firing an event by a standalone GC should be comparable to the cost of firing an event
without using a standalone GC.

## Querying Whether Events Are Enabled

Since it is not acceptable to perform an indirection when querying whether or not a requested event
is enabled, it follows that the GC must maintain some state about what events are currently enabled.
Events are enabled through *keywords* an *levels*; a particular event is enabled if both the event's
keyword and thee event's level have been enabled on the provider to which the event belongs.

To accomplish this, the GC will contain a class with this signature:

```c++

struct GCEvent {
    /* opaque, but will contain information about what event this is,
       its keyword, and its level */
};

class GCEventStatus {
public:
    // Returns true if this event is currently enabled, false otherwise.
    static bool IsEventEnabled(const GCEvent& event);

    // Enables events with the given keyword.
    static void EnableKeyword(int keyword);

    // Disables events the given keyword.
    static void DisableKeyword(int keyword);

    // Enables events with the given level.
    static void EnableLevel(int level);

    // Disables events the given level.
    static void DisableLevel(int level);
};

```

The GC will use `GCEventStatus::IsEventEnabled` to query whether or not a particular event is enabled.
Whenever the EE observes a change in what keywords or levels are enabled, it must inform the GC of the
change so that it can update `GCEventStatus` using `EnableKeyword`, `DisableKeyword`, `EnableLevel`, and
`DisableLevel` to synchronize its state with the EE. Therefore, two functions are added to `IGCHeap` that
the EE will call in order to inform the GC of changes to the event state:

```c++

// Enables or disables events with the given keyword.
void IGCHeap::SetEventKeywordState(int keyword, bool enabled);

// Enables or disables events with the given level.
void IGCHeap::SetEventLevelState(int level, bool enabled);
```

These interface methods in turn will call `GCEventStatus::{Enable, Disable}{Keyword, Level}` in order
to enable or disable keywords or levels.

## Firing Events

In order to fire an event, the GC will need to communicate with the EE in some way. The EE is ultimately
responsible for routing the event to any appropriate subsystems (ETW, LTTNG, EventPipe) and the GC has
no knowledge of what it is going to do with events that we give it.

Given that we have validated that an event is enabled (through `GCEventStatus::IsEventEnabled`), we can
fire the event using this new method on `IGCToCLR`:

```c++
void IGCToCLR::FireEvent(int eventId, void* eventPayload, size_t eventPayloadSize);
```

It is up to the GC to format the event payload in such a way that the EE can decode it and forward the
event and its payload to the underlying event pipeline.
