# Standalone GC Eventing Design

Author: Sean Gillespie (@swgillespie) - 2017

This document aims to provide a specification for how a standalone GC fires
events that can be collected by trace collectors. Such a feature is highly desirable
for a standalone GC since it is the primary way that is used to reason about
GC performance. Since a standalone GC is not permitted to link against the rest of the runtime, all
communication betwene the runtime and the GC most pass through dynamically-dispatched interfaces.

## Definitions

* An **event** is some unit of information that the runtime can issue if requested. In general,
this is used for lightweight tracing. Managed code can issue events using
`System.Diagnostics.Tracing.EventSource`. Native code (i.e. the runtime) issues events by calling macros
that delegate the issuing of events to autogenerated code that is generated to interface with the
underlying event implementation. Events are only issued if they are turned on; the mechanism by which
events are turned on is not in the scope of this document
* The **payload** of an event is some amount of data that is delivered with the event itself. Its size
may be variable. Most events that are fired by the runtime have a schema (predefined layout), but it
is not a requirement.

## Goals

The goal of this document is to describe a system that allows for the efficient firing of
performance events by a standalone GC. This system must have two properties in order to be
acceptable:

1. It must be *efficient* to query whether or not a particular event is turned on. It is not acceptable
to perform an indirection (i.e. cross the GC/EE interface boundary) in order to get this information.
2. The cost of firing an event by a standalone GC should be comparable to the cost of firing an event
without using a standalone GC.

## Querying Whether Events Are Enabled

Tt is not acceptable to perform an indirection when querying whether or not a requested event
is enabled. Therefore, it follows that the GC must maintain some state about what events are currently 
enabled. Events are enabled through *keywords* and *levels*; a particular event is enabled if both the 
event's keyword and the event's level have been enabled on the provider to which the event belongs.

To accomplish this, the GC will contain a class with this signature:

```c++
// Constructed on GC startup for every event that the GC can fire.
struct GCEvent
{
    /* opaque, but will contain information about what event this is,
       its keyword, its level, and a handle to the EE's representation of this event */
    /* this structure is potentially auto-generated from an event manifest */
};

class GCEventStatus
{
public:
    // Returns true if this event is currently enabled, false otherwise.
    static bool IsEventEnabled(const GCEvent& event);

    // Enables events with the given keyword and level.
    static void Enable(int keyword, int level);

    // Disables events the given keyword and level.
    static void Disable(int keyword, int level);
};

```

The GC will use `GCEventStatus::IsEventEnabled` to query whether or not a particular event is enabled.
Whenever the EE observes a change in what keywords or levels are enabled, it must inform the GC of the
change so that it can update `GCEventStatus` using `Enable` and `Disable`. The exact mechanism by which
the EE observes a change in the event state is described further below. ("Getting Informed of Changes to 
Event State")

When the EE *does* observe a change, it informs the GC using these two new methods on `IGCHeap`:

```c++
void IGCHeap::EnableEvents(int keyword, int level)
void IGCHeap::DisableEvents(int keyword, int level)
```


These interface methods in turn will call `GCEventStatus::{Enable, Disable}` in order
to enable or disable keywords or levels. The currently enabled keywords and levels are encoded as
bit vectors so that querying whether an event is enabled is as fast as loading three globals, a pointer
dereference, and two bit tests, e.g. (hypothetically):

```c++
uint32_t enabledLevels;
uint32_t enabledKeywords;

bool GCEventStatus::IsEventEnabled(const GCEvent& event)
{
    return (enabledLevels & event.level) && (enabledKeywords & event.keyword);
}
```

## Firing Events

In order to fire an event, the GC will need to communicate with the EE in some way. The EE is ultimately
responsible for routing the event to any appropriate subsystems (ETW, LTTNG, EventPipe) and the GC has
no knowledge of what it is going to do with events that we give it.

Given that we have validated that an event is enabled (through `GCEventStatus::IsEventEnabled`), we can
fire the event using this new method on `IGCToCLR`:

```c++
void IGCToCLR::FireKnownEvent(
    /* IN */ void* eventHandle,
    /* IN */ void** eventData,
    /* IN */ uint32_t eventDataCount,
    /* IN */ const GUID* pActivityId = nullptr,
    /* IN */ const GUID* pRelatedActivityId = nullptr
);
```

The four arguments of this function are:
1. `eventHandle` - An opaque handle to the EE's representation of the event being fired.
2. `eventData` - An array of pointers that contains the payload of the event being fired.
Each `GCEventData` is a tuple of a data pointer and size, so it can be used to describe arbitrary data.
3. `eventDataCount` - The size of the `eventData` array.
4. `pActivityId` and `pRelatedActivityId` - If provided, passes the activity ID and related activity ID
verbatim to the underlying event implementation.

The EE will use this information to determine 1) if this event truly is enabled and, 2) if it is,
forwarding it to the apporopriate underlying event implementation, be it EventPipe, ETW, or LTTNG.
The passed-in eventHandle will be a handle to an object from which the EE can get information about
the version of the event and other useful metadata.

## Getting Informed of Changes to Event State

There are three mechanisms by which CoreCLR is able to log events: EventPipe, ETW, and LTTNG. When it
comes to changing the state of events, EventPipe and ETW both allow users to attach callbacks that are
invoked whenever events are enabled or disabled. For these two mechanisms, it is sufficient to use
this callback mechanism to call `IGCHeap::{Enable/Disable}Events` from within such a callback in order
to inform the GC of changes to tracing state.

LTTNG does not have such a mechanism. In order to observe changes in the eventing state, LTTNG must be
polled periodically. For this purpose, when tracing using LTTNG, a new thread will be spawned by the EE
whose responsibility is to periodically poll LTTNG and invoke the GC whenever it detects changes in the
eventing state.

## Adding New Events

It is useful for a standalone GC to be able to fire events that the EE was not previously aware of.
For example, it is useful for a GC developer to add some event-based instrumentation to the GC, especially
when testing new features and ensuring that they work as expected.

While it is possible for some eventing implementations to receive events that are created at runtime, not all
eventing implementations (particularly LTTNG) are not flexible enough for this. In order to accomodate new
events, another method is added to `IGCToCLR`:

```c++
void IGCToCLR::FireCustomEvent(
    /* IN */ const char* eventName,
    /* IN */ uint64_t eventId,
    /* IN */ void* payload,
    /* IN */ size_t payloadSize
);
```

This callback fires a "custom" event that the EE is not previously aware of. The four arguments of this
function are:

1. `eventName` - The name of this custom event.
2. `eventId` - A unique integer ID of this custom event that consumers can use to identify this event.
3. `payload` - A raw binary payload of the event, passed verbatim to the underlying event implementation.
4. `payloadSize` - The size of the binary payload.

A runtime implementing this callback will implement it by having a "catch-all" GC event whose schema is
an arbitrary sequence of bytes. Tools can parse the (deliberately unspecified) binary format provided by GC
events that use this mechanism in order to recover the data within the payload.

## Handling EE-specific arguments for GC events

A number of events that the GC fires rely on state that is maintained by the EE. Several examples of this
are:

* Tracing controllers can request specific GC sequence numbers for the `GcStart` event. Before firing `GcStart`,
the GC must first [obtain the requested sequence number](https://github.com/dotnet/coreclr/blob/46dc37a27abe79d5977a1942541b1665b61f7a17/src/vm/eventtrace.cpp#L894-L902).
* Almost all events get the CLR instance ID (`GetClrInstanceId()`) and pass it as an argument to the
event being fired.
* Some events gather metadata about objects that are only known to the EE. Some examples of this would be
[string representations of types](https://github.com/dotnet/coreclr/blob/46dc37a27abe79d5977a1942541b1665b61f7a17/src/gc/gcee.cpp#L468-L480) 
("type names") and [app domains](https://github.com/dotnet/coreclr/blob/46dc37a27abe79d5977a1942541b1665b61f7a17/src/gc/handletable.cpp#L620).

There are two concerns here that are at odds with one another. While we want to ensure that the API surface
area of `IGCToCLR` is as minimal as possible, we also want to allow for custom events to have the ability
to fire events whose payloads contain EE-known details. To this end I propose that we examine these bits
of EE state leakage on a case-by-case basis. For EE state that is likely to be something that a custom event
writer would use (for example - type names), callbacks on `IGCToCLR` are added to ensure that the GC has
access to these details. For EE state that is not likely to be something used in custom events, we can
"intercept" events as the flow from the GC to the EE but before they flow into the underlying event pipelines
and add the EE-specific data at that point.

To be more specific, the implementation of `IGCToCLR::FireKnownEvent` will look something like this:

```c++
void GCToEEInterface::FireKnownEvent(...)
{
    switch (eventId)
    {
        ...
        case GcStartEventId:
        {
            LONGLONG l64ClientSequenceNumberToLog = GetClientSequenceNumber();
            FireEtwGCStart_V2(..., l64ClientSequenceNumberToLog);
        }
    }
}
```

If a particular event needs access to EE details, the GC can fire the event with *incomplete arguments* and
the EE can fill them in before it actually fires the event.
