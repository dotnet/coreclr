// Adapted from an entry that appeared on David Broman's blog// All sample code for this topic is now also available on the MSDN Code Gallery [SigParse](http://code.msdn.microsoft.com/sigparse "SigParse") page.#include "SigParse.cpp"  // --------------------------------------------------------------------- // --------------------------------------------------------------------- // This file demonstrates how to use the general-purpose parser (SigParser) by // deriving a new class from it and overriding the virtuals. // // In this case we're simply printing the notifications to stdout as we receive // them, using pretty indenting. // // Look at PlugInToYourProfiler.cpp to see how to drive this. // --------------------------------------------------------------------- // ---------------------------------------------------------------------   #define dimensionof(a) (sizeof(a)/sizeof(\*(a))) #define MAKE\_CASE(\_\_elt) case \_\_elt: return #\_\_elt; #define MAKE\_CASE\_OR(\_\_elt) case \_\_elt: return #\_\_elt "|";  class SigFormat : public SigParser { private: UINT nIndentLevel;  public: SigFormat() {nIndentLevel = 0; } UINT GetIndentLevel() { return nIndentLevel;}  protected: LPCSTR SigIndexTypeToString(sig\_index\_type sit) { switch(sit) { default: DebugBreak(); return "unknown index type"; MAKE\_CASE(SIG\_INDEX\_TYPE\_TYPEDEF) MAKE\_CASE(SIG\_INDEX\_TYPE\_TYPEREF) MAKE\_CASE(SIG\_INDEX\_TYPE\_TYPESPEC) } }  LPCSTR SigMemberTypeOptionToString(sig\_elem\_type set) { switch(set & 0xf0) { default: DebugBreak(); return "unknown element type"; case 0: return "";  MAKE\_CASE\_OR(SIG\_GENERIC) MAKE\_CASE\_OR(SIG\_HASTHIS) MAKE\_CASE\_OR(SIG\_EXPLICITTHIS) } }  LPCSTR SigMemberTypeToString(sig\_elem\_type set) { switch(set & 0xf) { default: DebugBreak(); return "unknown element type"; MAKE\_CASE(SIG\_METHOD\_DEFAULT) MAKE\_CASE(SIG\_METHOD\_C) MAKE\_CASE(SIG\_METHOD\_STDCALL) MAKE\_CASE(SIG\_METHOD\_THISCALL) MAKE\_CASE(SIG\_METHOD\_FASTCALL) MAKE\_CASE(SIG\_METHOD\_VARARG) MAKE\_CASE(SIG\_FIELD) MAKE\_CASE(SIG\_LOCAL\_SIG) MAKE\_CASE(SIG\_PROPERTY) } }  LPCSTR SigElementTypeToString(sig\_elem\_type set) { switch(set) { default: DebugBreak(); return "unknown element type"; MAKE\_CASE(ELEMENT\_TYPE\_END) MAKE\_CASE(ELEMENT\_TYPE\_VOID) MAKE\_CASE(ELEMENT\_TYPE\_BOOLEAN) MAKE\_CASE(ELEMENT\_TYPE\_CHAR) MAKE\_CASE(ELEMENT\_TYPE\_I1) MAKE\_CASE(ELEMENT\_TYPE\_U1) MAKE\_CASE(ELEMENT\_TYPE\_I2) MAKE\_CASE(ELEMENT\_TYPE\_U2) MAKE\_CASE(ELEMENT\_TYPE\_I4) MAKE\_CASE(ELEMENT\_TYPE\_U4) MAKE\_CASE(ELEMENT\_TYPE\_I8) MAKE\_CASE(ELEMENT\_TYPE\_U8) MAKE\_CASE(ELEMENT\_TYPE\_R4) MAKE\_CASE(ELEMENT\_TYPE\_R8) MAKE\_CASE(ELEMENT\_TYPE\_STRING) MAKE\_CASE(ELEMENT\_TYPE\_PTR) MAKE\_CASE(ELEMENT\_TYPE\_BYREF) MAKE\_CASE(ELEMENT\_TYPE\_VALUETYPE) MAKE\_CASE(ELEMENT\_TYPE\_CLASS) MAKE\_CASE(ELEMENT\_TYPE\_VAR) MAKE\_CASE(ELEMENT\_TYPE\_ARRAY) MAKE\_CASE(ELEMENT\_TYPE\_GENERICINST) MAKE\_CASE(ELEMENT\_TYPE\_TYPEDBYREF) MAKE\_CASE(ELEMENT\_TYPE\_I) MAKE\_CASE(ELEMENT\_TYPE\_U) MAKE\_CASE(ELEMENT\_TYPE\_FNPTR) MAKE\_CASE(ELEMENT\_TYPE\_OBJECT) MAKE\_CASE(ELEMENT\_TYPE\_SZARRAY) MAKE\_CASE(ELEMENT\_TYPE\_MVAR) MAKE\_CASE(ELEMENT\_TYPE\_CMOD\_REQD) MAKE\_CASE(ELEMENT\_TYPE\_CMOD\_OPT) MAKE\_CASE(ELEMENT\_TYPE\_INTERNAL) MAKE\_CASE(ELEMENT\_TYPE\_MODIFIER) MAKE\_CASE(ELEMENT\_TYPE\_SENTINEL) MAKE\_CASE(ELEMENT\_TYPE\_PINNED) } }  void PrintIndent() { const char k\_szSpaces[] = " ";  // You should probably assert or throw an exception if nIndentLevel // is bigger than dimensionof(k\_szSpaces)-1. Error handling is minimized // in this sample for better readability.  printf(k\_szSpaces + ((dimensionof(k\_szSpaces)-1) - nIndentLevel)); }  void IncIndent() { nIndentLevel += 2; }  void DecIndent() { nIndentLevel -= 2; }  // Simple wrapper around printf that prints the indenting spaces for you void Print(const char\* format, ...) { va\_list argList; va\_start(argList, format); PrintIndent(); vprintf(format, argList); }  // a method with given elem\_type virtual void NotifyBeginMethod(sig\_elem\_type elem\_type) { Print("BEGIN METHOD\n"); IncIndent(); }  virtual void NotifyEndMethod() { DecIndent(); Print("END METHOD\n"); }  // total parameters for the method virtual void NotifyParamCount(sig\_count count) { Print("Param count = '%d'\n", count); }  // starting a return type virtual void NotifyBeginRetType() { Print("BEGIN RET TYPE\n"); IncIndent(); } virtual void NotifyEndRetType() { DecIndent(); Print("END RET TYPE\n"); }  // starting a parameter virtual void NotifyBeginParam() { Print("BEGIN PARAM\n"); IncIndent(); }  virtual void NotifyEndParam() { DecIndent(); Print("END PARAM\n"); }  // sentinel indication the location of the "..." in the method signature virtual void NotifySentinal() { Print("...\n"); }  // number of generic parameters in this method signature (if any) virtual void NotifyGenericParamCount(sig\_count count) { Print("Generic param count = '%d'\n", count); }  //----------------------------------------------------  // a field with given elem\_type virtual void NotifyBeginField(sig\_elem\_type elem\_type) { Print("BEGIN FIELD: '%s%s'\n", SigMemberTypeOptionToString(elem\_type), SigMemberTypeToString(elem\_type)); IncIndent(); }  virtual void NotifyEndField() { DecIndent(); Print("END FIELD\n"); }  //----------------------------------------------------  // a block of locals with given elem\_type (always just LOCAL\_SIG for now) virtual void NotifyBeginLocals(sig\_elem\_type elem\_type) { Print("BEGIN LOCALS: '%s%s'\n", SigMemberTypeOptionToString(elem\_type), SigMemberTypeToString(elem\_type)); IncIndent(); }  virtual void NotifyEndLocals() { DecIndent(); Print("END LOCALS\n"); }   // count of locals with a block virtual void NotifyLocalsCount(sig\_count count) { Print("Locals count: '%d'\n", count); }  // starting a new local within a local block virtual void NotifyBeginLocal() { Print("BEGIN LOCAL\n"); IncIndent(); }  virtual void NotifyEndLocal() { DecIndent(); Print("END LOCAL\n"); }   // the only constraint available to locals at the moment is ELEMENT\_TYPE\_PINNED virtual void NotifyConstraint(sig\_elem\_type elem\_type) { Print("Constraint: '%s%s'\n", SigMemberTypeOptionToString(elem\_type), SigMemberTypeToString(elem\_type)); }   //----------------------------------------------------  // a property with given element type virtual void NotifyBeginProperty(sig\_elem\_type elem\_type) { Print("BEGIN PROPERTY: '%s%s'\n", SigMemberTypeOptionToString(elem\_type), SigMemberTypeToString(elem\_type)); IncIndent(); }  virtual void NotifyEndProperty() { DecIndent(); Print("END PROPERTY\n"); }   //----------------------------------------------------  // starting array shape information for array types virtual void NotifyBeginArrayShape() { Print("BEGIN ARRAY SHAPE\n"); IncIndent(); }  virtual void NotifyEndArrayShape() { DecIndent(); Print("END ARRAY SHAPE\n"); }   // array rank (total number of dimensions) virtual void NotifyRank(sig\_count count) { Print("Rank: '%d'\n", count); }  // number of dimensions with specified sizes followed by the size of each virtual void NotifyNumSizes(sig\_count count) { Print("Num Sizes: '%d'\n", count); }  virtual void NotifySize(sig\_count count) { Print("Size: '%d'\n", count); }  // BUG BUG lower bounds can be negative, how can this be encoded? // number of dimensions with specified lower bounds followed by lower bound of each  virtual void NotifyNumLoBounds(sig\_count count) { Print("Num Low Bounds: '%d'\n", count); }  virtual void NotifyLoBound(sig\_count count) { Print("Low Bound: '%d'\n", count); }  //----------------------------------------------------   // starting a normal type (occurs in many contexts such as param, field, local, etc) virtual void NotifyBeginType() { Print("BEGIN TYPE\n"); IncIndent(); }  virtual void NotifyEndType() { DecIndent(); Print("END TYPE\n"); }  virtual void NotifyTypedByref() { Print("Typed byref\n"); }  // the type has the 'byref' modifier on it -- this normally proceeds the type definition in the context // the type is used, so for instance a parameter might have the byref modifier on it // so this happens before the BeginType in that context virtual void NotifyByref() { Print("Byref\n"); }  // the type is "VOID" (this has limited uses, function returns and void pointer) virtual void NotifyVoid() { Print("Void\n"); }  // the type has the indicated custom modifiers (which can be optional or required) virtual void NotifyCustomMod(sig\_elem\_type cmod, sig\_index\_type indexType, sig\_index index) { Print( "Custom modifers: '%s', index type: '%s', index: '0x%x'\n", SigElementTypeToString(cmod), SigIndexTypeToString(indexType), index); }  // the type is a simple type, the elem\_type defines it fully virtual void NotifyTypeSimple(sig\_elem\_type elem\_type) { Print("Type simple: '%s'\n", SigElementTypeToString(elem\_type)); }  // the type is specified by the given index of the given index type (normally a type index in the type metadata) // this callback is normally qualified by other ones such as NotifyTypeClass or NotifyTypeValueType virtual void NotifyTypeDefOrRef(sig\_index\_type indexType, int index) { Print("Type def or ref: '%s', index: '0x%x'\n", SigIndexTypeToString(indexType), index); }  // the type is an instance of a generic // elem\_type indicates value\_type or class // indexType and index indicate the metadata for the type in question // number indicates the number of type specifications for the generic types that will follow virtual void NotifyTypeGenericInst(sig\_elem\_type elem\_type, sig\_index\_type indexType, sig\_index index, sig\_mem\_number number) { Print( "Type generic instance: '%s', index type: '%s', index: '0x%x', member number: '%d'\n", SigElementTypeToString(elem\_type), SigIndexTypeToString(indexType), index, number); }  // the type is the type of the nth generic type parameter for the class virtual void NotifyTypeGenericTypeVariable(sig\_mem\_number number) { Print("Type generic type variable: number: '%d'\n", number); }  // the type is the type of the nth generic type parameter for the member virtual void NotifyTypeGenericMemberVariable(sig\_mem\_number number) { Print("Type generic member variable: number: '%d'\n", number); }  // the type will be a value type virtual void NotifyTypeValueType() { Print("Type value type\n"); }  // the type will be a class virtual void NotifyTypeClass() { Print("Type class\n"); }  // the type is a pointer to a type (nested type notifications follow) virtual void NotifyTypePointer() { Print("Type pointer\n"); }  // the type is a function pointer, followed by the type of the function virtual void NotifyTypeFunctionPointer() { Print("Type function pointer\n"); }  // the type is an array, this is followed by the array shape, see above, as well as modifiers and element type virtual void NotifyTypeArray() { Print("Type array\n"); }  // the type is a simple zero-based array, this has no shape but does have custom modifiers and element type virtual void NotifyTypeSzArray() { Print("Type sz array\n"); } };