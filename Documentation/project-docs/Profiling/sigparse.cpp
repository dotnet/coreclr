// Adapted from an entry that appeared on David Broman's blog////  All sample code for this topic is now also available on the MSDN Code Gallery page http://code.msdn.microsoft.com/sigparse. // Sig ::= MethodDefSig | MethodRefSig | StandAloneMethodSig | FieldSig | PropertySig | LocalVarSig// MethodDefSig ::= [[HASTHIS] [EXPLICITTHIS]] (DEFAULT|VARARG|GENERIC GenParamCount) ParamCount RetType Param\*// MethodRefSig ::= [[HASTHIS] [EXPLICITTHIS]] VARARG ParamCount RetType Param\* [SENTINEL Param+]// StandAloneMethodSig ::= [[HASTHIS] [EXPLICITTHIS]] (DEFAULT|VARARG|C|STDCALL|THISCALL|FASTCALL) // ParamCount RetType Param\* [SENTINEL Param+]// FieldSig ::= FIELD CustomMod\* Type// PropertySig ::= PROPERTY [HASTHIS] ParamCount CustomMod\* Type Param\*// LocalVarSig ::= LOCAL\_SIG Count (TYPEDBYREF | ([CustomMod] [Constraint])\* [BYREF] Type)+ // -------------// CustomMod ::= ( CMOD\_OPT | CMOD\_REQD ) ( TypeDefEncoded | TypeRefEncoded )// Constraint ::= #define ELEMENT\_TYPE\_PINNED// Param ::= CustomMod\* ( TYPEDBYREF | [BYREF] Type )// RetType ::= CustomMod\* ( VOID | TYPEDBYREF | [BYREF] Type )// Type ::= ( BOOLEAN | CHAR | I1 | U1 | U2 | U2 | I4 | U4 | I8 | U8 | R4 | R8 | I | U |// | VALUETYPE TypeDefOrRefEncoded// | CLASS TypeDefOrRefEncoded// | STRING // | OBJECT// | PTR CustomMod\* VOID// | PTR CustomMod\* Type// | FNPTR MethodDefSig// | FNPTR MethodRefSig// | ARRAY Type ArrayShape// | SZARRAY CustomMod\* Type// | GENERICINST (CLASS | VALUETYPE) TypeDefOrRefEncoded GenArgCount Type\*// | VAR Number// | MVAR Number// ArrayShape ::= Rank NumSizes Size\* NumLoBounds LoBound\*// TypeDefOrRefEncoded ::= TypeDefEncoded | TypeRefEncoded// TypeDefEncoded ::= 32-bit-3-part-encoding-for-typedefs-and-typerefs// TypeRefEncoded ::= 32-bit-3-part-encoding-for-typedefs-and-typerefs// ParamCount ::= 29-bit-encoded-integer// GenArgCount ::= 29-bit-encoded-integer// Count ::= 29-bit-encoded-integer// Rank ::= 29-bit-encoded-integer// NumSizes ::= 29-bit-encoded-integer// Size ::= 29-bit-encoded-integer// NumLoBounds ::= 29-bit-encoded-integer// LoBounds ::= 29-bit-encoded-integer// Number ::= 29-bit-encoded-integer    #define ELEMENT\_TYPE\_END 0x00 //Marks end of a list #define ELEMENT\_TYPE\_VOID 0x01 #define ELEMENT\_TYPE\_BOOLEAN 0x02 #define ELEMENT\_TYPE\_CHAR 0x03 #define ELEMENT\_TYPE\_I1 0x04 #define ELEMENT\_TYPE\_U1 0x05 #define ELEMENT\_TYPE\_I2 0x06 #define ELEMENT\_TYPE\_U2 0x07 #define ELEMENT\_TYPE\_I4 0x08 #define ELEMENT\_TYPE\_U4 0x09 #define ELEMENT\_TYPE\_I8 0x0a #define ELEMENT\_TYPE\_U8 0x0b #define ELEMENT\_TYPE\_R4 0x0c #define ELEMENT\_TYPE\_R8 0x0d #define ELEMENT\_TYPE\_STRING 0x0e #define ELEMENT\_TYPE\_PTR 0x0f // Followed by type #define ELEMENT\_TYPE\_BYREF 0x10 // Followed by type #define ELEMENT\_TYPE\_VALUETYPE 0x11 // Followed by TypeDef or TypeRef token #define ELEMENT\_TYPE\_CLASS 0x12 // Followed by TypeDef or TypeRef token #define ELEMENT\_TYPE\_VAR 0x13 // Generic parameter in a generic type definition, represented as number #define ELEMENT\_TYPE\_ARRAY 0x14 // type rank boundsCount bound1 … loCount lo1 … #define ELEMENT\_TYPE\_GENERICINST 0x15 // Generic type instantiation. Followed by type type-arg-count type-1 ... type-n #define ELEMENT\_TYPE\_TYPEDBYREF 0x16 #define ELEMENT\_TYPE\_I 0x18 // System.IntPtr #define ELEMENT\_TYPE\_U 0x19 // System.UIntPtr #define ELEMENT\_TYPE\_FNPTR 0x1b // Followed by full method signature #define ELEMENT\_TYPE\_OBJECT 0x1c // System.Object #define ELEMENT\_TYPE\_SZARRAY 0x1d // Single-dim array with 0 lower bound  #define ELEMENT\_TYPE\_MVAR 0x1e // Generic parameter in a generic method definition,represented as number #define ELEMENT\_TYPE\_CMOD\_REQD 0x1f // Required modifier : followed by a TypeDef or TypeRef token #define ELEMENT\_TYPE\_CMOD\_OPT 0x20 // Optional modifier : followed by a TypeDef or TypeRef token #define ELEMENT\_TYPE\_INTERNAL 0x21 // Implemented within the CLI #define ELEMENT\_TYPE\_MODIFIER 0x40 // Or’d with following element types #define ELEMENT\_TYPE\_SENTINEL 0x41 // Sentinel for vararg method signature #define ELEMENT\_TYPE\_PINNED 0x45 // Denotes a local variable that points at a pinned object  #define SIG\_METHOD\_DEFAULT 0x0 // default calling convention #define SIG\_METHOD\_C 0x1 // C calling convention #define SIG\_METHOD\_STDCALL 0x2 // Stdcall calling convention #define SIG\_METHOD\_THISCALL 0x3 // thiscall calling convention #define SIG\_METHOD\_FASTCALL 0x4 // fastcall calling convention #define SIG\_METHOD\_VARARG 0x5 // vararg calling convention #define SIG\_FIELD 0x6 // encodes a field #define SIG\_LOCAL\_SIG 0x7 // used for the .locals directive #define SIG\_PROPERTY 0x8 // used to encode a property   #define SIG\_GENERIC 0x10 // used to indicate that the method has one or more generic parameters. #define SIG\_HASTHIS 0x20 // used to encode the keyword instance in the calling convention #define SIG\_EXPLICITTHIS 0x40 // used to encode the keyword explicit in the calling convention  #define SIG\_INDEX\_TYPE\_TYPEDEF 0 // ParseTypeDefOrRefEncoded returns this as the out index type for typedefs #define SIG\_INDEX\_TYPE\_TYPEREF 1 // ParseTypeDefOrRefEncoded returns this as the out index type for typerefs #define SIG\_INDEX\_TYPE\_TYPESPEC 2 // ParseTypeDefOrRefEncoded returns this as the out index type for typespecs   typedef unsigned char sig\_byte; typedef unsigned char sig\_elem\_type; typedef unsigned char sig\_index\_type; typedef unsigned int sig\_index; typedef unsigned int sig\_count; typedef unsigned int sig\_mem\_number;  class SigParser { private: sig\_byte \*pbBase; sig\_byte \*pbCur; sig\_byte \*pbEnd;  public:  bool Parse(sig\_byte \*blob, sig\_count len);  private: bool ParseByte(sig\_byte \*pbOut); bool ParseNumber(sig\_count \*pOut); bool ParseTypeDefOrRefEncoded(sig\_index\_type \*pOutIndexType, sig\_index \*pOutIndex);  bool ParseMethod(sig\_elem\_type); bool ParseField(sig\_elem\_type); bool ParseProperty(sig\_elem\_type); bool ParseLocals(sig\_elem\_type); bool ParseLocal(); bool ParseOptionalCustomMods(); bool ParseOptionalCustomModsOrConstraint(); bool ParseCustomMod(); bool ParseRetType(); bool ParseType(); bool ParseParam(); bool ParseArrayShape();  protected:  // subtype these methods to create your parser side-effects  //----------------------------------------------------  // a method with given elem\_type virtual void NotifyBeginMethod(sig\_elem\_type elem\_type) {} virtual void NotifyEndMethod() {}  // total parameters for the method virtual void NotifyParamCount(sig\_count) {}  // starting a return type virtual void NotifyBeginRetType() {} virtual void NotifyEndRetType() {}  // starting a parameter virtual void NotifyBeginParam() {} virtual void NotifyEndParam() {}  // sentinel indication the location of the "..." in the method signature virtual void NotifySentinal() {}  // number of generic parameters in this method signature (if any) virtual void NotifyGenericParamCount(sig\_count) {}  //----------------------------------------------------  // a field with given elem\_type virtual void NotifyBeginField(sig\_elem\_type elem\_type) {} virtual void NotifyEndField() {}  //----------------------------------------------------  // a block of locals with given elem\_type (always just LOCAL\_SIG for now) virtual void NotifyBeginLocals(sig\_elem\_type elem\_type) {} virtual void NotifyEndLocals() {}  // count of locals with a block virtual void NotifyLocalsCount(sig\_count) {}  // starting a new local within a local block virtual void NotifyBeginLocal() {} virtual void NotifyEndLocal() {}  // the only constraint available to locals at the moment is ELEMENT\_TYPE\_PINNED virtual void NotifyConstraint(sig\_elem\_type elem\_type) {}   //----------------------------------------------------  // a property with given element type virtual void NotifyBeginProperty(sig\_elem\_type elem\_type) {} virtual void NotifyEndProperty() {}  //----------------------------------------------------  // starting array shape information for array types virtual void NotifyBeginArrayShape() {} virtual void NotifyEndArrayShape() {}  // array rank (total number of dimensions) virtual void NotifyRank(sig\_count) {}  // number of dimensions with specified sizes followed by the size of each virtual void NotifyNumSizes(sig\_count) {} virtual void NotifySize(sig\_count) {}  // BUG BUG lower bounds can be negative, how can this be encoded? // number of dimensions with specified lower bounds followed by lower bound of each  virtual void NotifyNumLoBounds(sig\_count) {}  virtual void NotifyLoBound(sig\_count) {}  //----------------------------------------------------   // starting a normal type (occurs in many contexts such as param, field, local, etc) virtual void NotifyBeginType() {}; virtual void NotifyEndType() {};  virtual void NotifyTypedByref() {}  // the type has the 'byref' modifier on it -- this normally proceeds the type definition in the context // the type is used, so for instance a parameter might have the byref modifier on it // so this happens before the BeginType in that context virtual void NotifyByref() {}  // the type is "VOID" (this has limited uses, function returns and void pointer) virtual void NotifyVoid() {}  // the type has the indicated custom modifiers (which can be optional or required) virtual void NotifyCustomMod(sig\_elem\_type cmod, sig\_index\_type indexType, sig\_index index) {}  // the type is a simple type, the elem\_type defines it fully virtual void NotifyTypeSimple(sig\_elem\_type elem\_type) {}  // the type is specified by the given index of the given index type (normally a type index in the type metadata) // this callback is normally qualified by other ones such as NotifyTypeClass or NotifyTypeValueType virtual void NotifyTypeDefOrRef(sig\_index\_type indexType, int index) {}  // the type is an instance of a generic // elem\_type indicates value\_type or class // indexType and index indicate the metadata for the type in question // number indicates the number of type specifications for the generic types that will follow virtual void NotifyTypeGenericInst(sig\_elem\_type elem\_type, sig\_index\_type indexType, sig\_index index, sig\_mem\_number number) {}  // the type is the type of the nth generic type parameter for the class virtual void NotifyTypeGenericTypeVariable(sig\_mem\_number number) {}   // the type is the type of the nth generic type parameter for the member virtual void NotifyTypeGenericMemberVariable(sig\_mem\_number number) {}   // the type will be a value type virtual void NotifyTypeValueType() {}  // the type will be a class virtual void NotifyTypeClass() {}  // the type is a pointer to a type (nested type notifications follow) virtual void NotifyTypePointer() {}  // the type is a function pointer, followed by the type of the function virtual void NotifyTypeFunctionPointer() {}  // the type is an array, this is followed by the array shape, see above, as well as modifiers and element type virtual void NotifyTypeArray() {}  // the type is a simple zero-based array, this has no shape but does have custom modifiers and element type virtual void NotifyTypeSzArray() {} };  //----------------------------------------------------   bool SigParser::Parse(sig\_byte \*pb, sig\_count cbBuffer) { pbBase = pb; pbCur = pb; pbEnd = pbBase + cbBuffer;  sig\_elem\_type elem\_type;  if (!ParseByte(&elem\_type)) return false;  switch (elem\_type & 0xf) { case SIG\_METHOD\_DEFAULT: // default calling convention case SIG\_METHOD\_C: // C calling convention case SIG\_METHOD\_STDCALL: // Stdcall calling convention case SIG\_METHOD\_THISCALL: // thiscall calling convention case SIG\_METHOD\_FASTCALL: // fastcall calling convention case SIG\_METHOD\_VARARG: // vararg calling convention return ParseMethod(elem\_type); break;  case SIG\_FIELD: // encodes a field return ParseField(elem\_type); break;  case SIG\_LOCAL\_SIG: // used for the .locals directive return ParseLocals(elem\_type); break;  case SIG\_PROPERTY: // used to encode a property return ParseProperty(elem\_type); break;  default: // unknown signature break; }  return false; }   bool SigParser::ParseByte(sig\_byte \*pbOut) { if (pbCur \< pbEnd) { \*pbOut = \*pbCur; pbCur++; return true; }  return false; }   bool SigParser::ParseMethod(sig\_elem\_type elem\_type) { // MethodDefSig ::= [[HASTHIS] [EXPLICITTHIS]] (DEFAULT|VARARG|GENERIC GenParamCount) // ParamCount RetType Param\* [SENTINEL Param+]  NotifyBeginMethod(elem\_type);  sig\_count gen\_param\_count; sig\_count param\_count;  if (elem\_type & SIG\_GENERIC) { if (!ParseNumber(&gen\_param\_count)) return false;  NotifyGenericParamCount(gen\_param\_count);  }  if (!ParseNumber(¶m\_count)) return false;  NotifyParamCount(param\_count);  if (!ParseRetType()) return false;  bool fEncounteredSentinal = false;  for (sig\_count i = 0; i \< param\_count; i++) { if (pbCur \>= pbEnd) return false;  if (\*pbCur == ELEMENT\_TYPE\_SENTINEL) { if (fEncounteredSentinal) return false;  fEncounteredSentinal = true; NotifySentinal(); pbCur++; }  if (!ParseParam()) return false; }  NotifyEndMethod();  return true; }   bool SigParser::ParseField(sig\_elem\_type elem\_type) { // FieldSig ::= FIELD CustomMod\* Type  NotifyBeginField(elem\_type);  if (!ParseOptionalCustomMods()) return false;  if (!ParseType()) return false;  NotifyEndField();  return true; }   bool SigParser::ParseProperty(sig\_elem\_type elem\_type) { // PropertySig ::= PROPERTY [HASTHIS] ParamCount CustomMod\* Type Param\*  NotifyBeginProperty(elem\_type);  sig\_count param\_count;      if (!ParseNumber(&param\_count)) return false;  NotifyParamCount(param\_count);  if (!ParseOptionalCustomMods()) return false;  if (!ParseType()) return false;  for (sig\_count i = 0; i \< param\_count; i++) { if (!ParseParam()) return false; }  NotifyEndProperty();  return true; }   bool SigParser::ParseLocals(sig\_elem\_type elem\_type) { // LocalVarSig ::= LOCAL\_SIG Count (TYPEDBYREF | ([CustomMod] [Constraint])\* [BYREF] Type)+   NotifyBeginLocals(elem\_type);  sig\_count local\_count;  if (!ParseNumber(&local\_count)) return false;  NotifyLocalsCount(local\_count);  for (sig\_count i = 0; i \< local\_count; i++) { if (!ParseLocal()) return false; }  NotifyEndLocals();  return true; }   bool SigParser::ParseLocal() { //TYPEDBYREF | ([CustomMod] [Constraint])\* [BYREF] Type NotifyBeginLocal();  if (pbCur \>= pbEnd) return false;  if (\*pbCur == ELEMENT\_TYPE\_TYPEDBYREF) { NotifyTypedByref(); pbCur++; goto Success; }  if (!ParseOptionalCustomModsOrConstraint()) return false;  if (pbCur \>= pbEnd) return false;  if (\*pbCur == ELEMENT\_TYPE\_BYREF) { NotifyByref(); pbCur++; }  if (!ParseType()) return false;  Success: NotifyEndLocal(); return true; }   bool SigParser::ParseOptionalCustomModsOrConstraint() {  for (;;) { if (pbCur \>= pbEnd) return true;  switch (\*pbCur) { case ELEMENT\_TYPE\_CMOD\_OPT: case ELEMENT\_TYPE\_CMOD\_REQD: if (!ParseCustomMod()) return false; break;  case ELEMENT\_TYPE\_PINNED: NotifyConstraint(\*pbCur); pbCur++; break;  default: return true; } }  return false; }   bool SigParser::ParseOptionalCustomMods() { for (;;) { if (pbCur \>= pbEnd) return true;  switch (\*pbCur) { case ELEMENT\_TYPE\_CMOD\_OPT: case ELEMENT\_TYPE\_CMOD\_REQD: if (!ParseCustomMod()) return false; break;   default: return true; } }  return false; }    bool SigParser::ParseCustomMod() { sig\_elem\_type cmod = 0; sig\_index index; sig\_index\_type indexType;  if (!ParseByte(&cmod)) return false;  if (cmod == ELEMENT\_TYPE\_CMOD\_OPT || cmod == ELEMENT\_TYPE\_CMOD\_REQD) { if (!ParseTypeDefOrRefEncoded(&indexType, &index)) return false;  NotifyCustomMod(cmod, indexType, index); return true; }  return false; }   bool SigParser::ParseParam() { // Param ::= CustomMod\* ( TYPEDBYREF | [BYREF] Type )  NotifyBeginParam();  if (!ParseOptionalCustomMods()) return false;  if (pbCur \>= pbEnd) return false;  if (\*pbCur == ELEMENT\_TYPE\_TYPEDBYREF) { NotifyTypedByref(); pbCur++; goto Success; }  if (\*pbCur == ELEMENT\_TYPE\_BYREF) { NotifyByref(); pbCur++; }  if (!ParseType()) return false;  Success: NotifyEndParam(); return true; }   bool SigParser::ParseRetType() { // RetType ::= CustomMod\* ( VOID | TYPEDBYREF | [BYREF] Type )  NotifyBeginRetType();  if (!ParseOptionalCustomMods()) return false;  if (pbCur \>= pbEnd) return false;  if (\*pbCur == ELEMENT\_TYPE\_TYPEDBYREF) { NotifyTypedByref(); pbCur++; goto Success; }  if (\*pbCur == ELEMENT\_TYPE\_VOID) { NotifyVoid(); pbCur++; goto Success; }  if (\*pbCur == ELEMENT\_TYPE\_BYREF) { NotifyByref(); pbCur++; }  if (!ParseType()) return false;  Success:  NotifyEndRetType(); return true; }  bool SigParser::ParseArrayShape() { sig\_count rank; sig\_count numsizes; sig\_count size;  // ArrayShape ::= Rank NumSizes Size\* NumLoBounds LoBound\* NotifyBeginArrayShape(); if (!ParseNumber(&rank)) return false;  NotifyRank(rank);  if (!ParseNumber(&numsizes)) return false;  NotifyNumSizes(numsizes);  for (sig\_count i = 0; i \< numsizes; i++) { if (!ParseNumber(&size)) return false;  NotifySize(size); }  if (!ParseNumber(&numsizes)) return false;  NotifyNumLoBounds(numsizes);  for (sig\_count i = 0; i \< numsizes; i++) { if (!ParseNumber(&size)) return false;  NotifyLoBound(size); }  NotifyEndArrayShape(); return true;  }  bool SigParser::ParseType() { /\* Type ::= ( BOOLEAN | CHAR | I1 | U1 | U2 | U2 | I4 | U4 | I8 | U8 | R4 | R8 | I | U | | VALUETYPE TypeDefOrRefEncoded | CLASS TypeDefOrRefEncoded | STRING  | OBJECT | PTR CustomMod\* VOID | PTR CustomMod\* Type | FNPTR MethodDefSig | FNPTR MethodRefSig | ARRAY Type ArrayShape | SZARRAY CustomMod\* Type | GENERICINST (CLASS | VALUETYPE) TypeDefOrRefEncoded GenArgCount Type \* | VAR Number | MVAR Number  \*/  NotifyBeginType();  sig\_elem\_type elem\_type; sig\_index index; sig\_mem\_number number; sig\_index\_type indexType;  if (!ParseByte(&elem\_type)) return false;  switch (elem\_type) { case ELEMENT\_TYPE\_BOOLEAN: case ELEMENT\_TYPE\_CHAR: case ELEMENT\_TYPE\_I1: case ELEMENT\_TYPE\_U1:  case ELEMENT\_TYPE\_U2:  case ELEMENT\_TYPE\_I2:  case ELEMENT\_TYPE\_I4:  case ELEMENT\_TYPE\_U4:  case ELEMENT\_TYPE\_I8:  case ELEMENT\_TYPE\_U8:  case ELEMENT\_TYPE\_R4:  case ELEMENT\_TYPE\_R8:  case ELEMENT\_TYPE\_I: case ELEMENT\_TYPE\_U: case ELEMENT\_TYPE\_STRING: case ELEMENT\_TYPE\_OBJECT: // simple types NotifyTypeSimple(elem\_type); break;  case ELEMENT\_TYPE\_PTR: // PTR CustomMod\* VOID // PTR CustomMod\* Type  NotifyTypePointer();  if (!ParseOptionalCustomMods()) return false;  if (pbCur \>= pbEnd) return false;  if (\*pbCur == ELEMENT\_TYPE\_VOID) { pbCur++; NotifyVoid(); break; }  if (!ParseType()) return false;  break;  case ELEMENT\_TYPE\_CLASS:  // CLASS TypeDefOrRefEncoded NotifyTypeClass();  if (!ParseTypeDefOrRefEncoded(&indexType, &index)) return false;  NotifyTypeDefOrRef(indexType, index);  break;  case ELEMENT\_TYPE\_VALUETYPE:  //VALUETYPE TypeDefOrRefEncoded NotifyTypeValueType();  if (!ParseTypeDefOrRefEncoded(&indexType, &index)) return false;  NotifyTypeDefOrRef(indexType, index);  break;  case ELEMENT\_TYPE\_FNPTR: // FNPTR MethodDefSig // FNPTR MethodRefSig NotifyTypeFunctionPointer();  if (!ParseByte(&elem\_type)) return false;  if (!ParseMethod(elem\_type)) return false;  break;  case ELEMENT\_TYPE\_ARRAY: // ARRAY Type ArrayShape NotifyTypeArray();  if (!ParseType()) return false;  if (!ParseArrayShape()) return false; break;  case ELEMENT\_TYPE\_SZARRAY: // SZARRAY CustomMod\* Type  NotifyTypeSzArray();  if (!ParseOptionalCustomMods()) return false;  if (!ParseType()) return false;  break;  case ELEMENT\_TYPE\_GENERICINST: // GENERICINST (CLASS | VALUETYPE) TypeDefOrRefEncoded GenArgCount Type \*  if (!ParseByte(&elem\_type)) return false;  if (elem\_type != ELEMENT\_TYPE\_CLASS && elem\_type != ELEMENT\_TYPE\_VALUETYPE) return false;  if (!ParseTypeDefOrRefEncoded(&indexType, &index)) return false;  if (!ParseNumber(&number)) return false;  NotifyTypeGenericInst(elem\_type, indexType, index, number);  { for (sig\_mem\_number i=0; i \< number; i++) { if (!ParseType()) return false; } }  break;  case ELEMENT\_TYPE\_VAR: // VAR Number if (!ParseNumber(&number)) return false; NotifyTypeGenericTypeVariable(number); break;  case ELEMENT\_TYPE\_MVAR: // MVAR Number if (!ParseNumber(&number)) return false; NotifyTypeGenericMemberVariable(number); break; }  NotifyEndType();  return true; }  bool SigParser::ParseTypeDefOrRefEncoded(sig\_index\_type \*pIndexTypeOut, sig\_index \*pIndexOut) { // parse an encoded typedef or typeref  sig\_count encoded = 0;  if (!ParseNumber(&encoded)) return false;  \*pIndexTypeOut = (sig\_index\_type) (encoded & 0x3); \*pIndexOut = (encoded \>\> 2); return true; }  bool SigParser::ParseNumber(sig\_count \*pOut) { // parse the variable length number format (0-4 bytes)  sig\_byte b1 = 0, b2 = 0, b3 = 0, b4 = 0;  // at least one byte in the encoding, read that  if (!ParseByte(&b1)) return false;  if (b1 == 0xff) { // special encoding of 'NULL' // not sure what this means as a number, don't expect to see it except for string lengths // which we don't encounter anyway so calling it an error return false; }  // early out on 1 byte encoding if ( (b1 & 0x80) == 0) { \*pOut = (int)b1; return true; }  // now at least 2 bytes in the encoding, read 2nd byte if (!ParseByte(&b2)) return false;  // early out on 2 byte encoding if ( (b1 & 0x40) == 0) { \*pOut = (((b1 & 0x3f) \<\< 8) | b2); return true; }  // must be a 4 byte encoding  if ( (b1 & 0x20) != 0)  { // 4 byte encoding has this bit clear -- error if not return false; }   if (!ParseByte(&b3)) return false;  if (!ParseByte(&b4)) return false;  \*pOut = ((b1 & 0x1f)\<\<24) | (b2\<\<16) | (b3\<\<8) | b4; return true; }