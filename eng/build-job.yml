parameters:
  buildConfig: ''
  archType: ''
  osGroup: ''
  osIdentifier: ''
  container: ''
  crossrootfsDir: ''
  timeoutInMinutes: ''

### Product build
jobs:
- template: xplat-job.yml
  parameters:
    buildConfig: ${{ parameters.buildConfig }}
    archType: ${{ parameters.archType }}
    osGroup: ${{ parameters.osGroup }}
    osIdentifier: ${{ parameters.osIdentifier }}
    helixType: 'build/product/'
    enableMicrobuild: true

    # Compute job name from template parameters
    name: ${{ format('build_{0}_{1}_{2}', parameters.osIdentifier, parameters.archType, parameters.buildConfig) }}
    displayName: ${{ format('{0} {1} {2}', parameters.osIdentifier, parameters.archType, parameters.buildConfig) }}

    # Run all steps in the container.
    # Note that the containers are defined in platform-matrix.yml
    container: ${{ parameters.container }}

    timeoutInMinutes: ${{ parameters.timeoutInMinutes }}

    crossrootfsDir: ${{ parameters.crossrootfsDir }}

    gatherAssetManifests: true
    variables:
    - name: osIdentifier
      value: ${{ parameters.osIdentifier }}
    - name: stripSymbolsArg
      value: ''
    # Strip symbols only on the release build
    - ${{ if eq(parameters.buildConfig, 'Release') }}:
      - name: stripSymbolsArg
        value: '-stripsymbols'
    - name: portableBuildArg
      value: ''
    # Ensure that we produce os-specific packages for the following distros:
    - ${{ if in(parameters.osIdentifier, 'Linux_rhel6') }}:
      - name: portableBuildArg
        value: '-portablebuild=false'
    - name: clangArg
      value: ''
    # Our FreeBSD doesn't yet detect available clang versions, so pass it explicitly.
    - ${{ if eq(parameters.osGroup, 'FreeBSD') }}:
      - name: clangArg
        value: '-clang6.0'
    - ${{ if eq(parameters.archType, 'arm64') }}:
      - name: clangArg
        value: '-clang5.0'

    steps:

    # Install native dependencies
    # Linux builds use docker images with dependencies preinstalled,
    # and FreeBSD builds use a build agent with dependencies
    # preinstalled, so we only need this step for OSX and Windows.
    - ${{ if eq(parameters.osGroup, 'OSX') }}:
      - script: sh eng/install-native-dependencies.sh $(osGroup)
        displayName: Install native dependencies
    - ${{ if eq(parameters.osGroup, 'Windows_NT') }}:
      # Necessary to install python
      - script: eng\common\init-tools-native.cmd -InstallDirectory $(Build.SourcesDirectory)\native-tools -Force
        displayName: Install native dependencies

    # Install internal tools on official builds
    # Since our internal tools are behind an authenticated feed,
    # we need to use the DotNetCli AzDO task to restore from the feed using a service connection.
    # We can't do this from within the build, so we need to do this as a separate step.
    - ${{ if and(and(eq(variables['System.TeamProject'], 'internal'), ne(variables['Build.Reason'], 'PullRequest')), eq(parameters.osGroup, 'Windows_NT')) }}:
        - task: DotNetCoreInstaller@0
          inputs:
            packageType: 'sdk'
            version: '2.1.503'
        - task: DotNetCoreCLI@2
          displayName: Restore internal tools
          inputs:
            command: restore
            feedsToUse: config
            projects: '$(Build.SourcesDirectory)/eng/common/internal/Tools.csproj'
            nugetConfigPath: 'eng/internal/NuGet.config'
            restoreDirectory: '$(Build.SourcesDirectory)\.packages'
            verbosityRestore: 'normal'
            externalFeedCredentials: 'dotnet-core-internal-tooling'

    # Build
    - ${{ if ne(parameters.osGroup, 'Windows_NT') }}:
      - script: ./build.sh $(buildConfig) $(archType) $(crossArg) -skiptests -skipnuget $(clangArg) $(stripSymbolsArg) $(officialBuildIdArg) /p:ContinuousIntegrationBuild=true
        displayName: Build product
    - ${{ if eq(parameters.osGroup, 'Windows_NT') }}:
      - script: set __TestIntermediateDir=int&&build.cmd $(buildConfig) $(archType) -skiptests -skipbuildpackages $(officialBuildIdArg) $(ibcOptimizeArg) $(enforcePgoArg) /p:ContinuousIntegrationBuild=true
        displayName: Build product

    # Build packages
    - ${{ if ne(parameters.osGroup, 'Windows_NT') }}:
      - script: ./build-packages.sh -BuildArch=$(archType) -BuildType=$(_BuildConfig) $(crossPackagesArg) $(officialBuildIdArg) $(portableBuildArg) -ci
        displayName: Build packages
    - ${{ if eq(parameters.osGroup, 'Windows_NT') }}:
      - script: build-packages.cmd -BuildArch=$(archType) -BuildType=$(_BuildConfig) $(officialBuildIdArg) -ci
        displayName: Build packages