<Project InitialTargets="BuildHelixWorkItems" DefaultTargets="RunInParallelForEachScenario">

  <!-- This project uses the helix SDK, documented at
       https://github.com/dotnet/arcade/tree/master/src/Microsoft.DotNet.Helix/Sdk,
       to send test jobs to helix. -->

  <Import Sdk="Microsoft.DotNet.Helix.Sdk" Project="Sdk.props" Condition=" '$(UsesHelixSdk)' == 'true' " />

  <!-- Import Microsoft.DotNet.Build.Tasks.Feed.targets for `ParseBuildManifest` -->
  <Import Project="..\dir.props" Condition=" '$(NuGetPackageRoot)'=='' "/>
  <Import Project="$(NuGetPackageRoot)microsoft.dotnet.build.tasks.feed\$(MicrosoftDotNetBuildTasksFeedVersion)\build\Microsoft.DotNet.Build.Tasks.Feed.targets" />  

  <!-- This project is copies much logic from helixpublishwitharcade.proj, used to send coreclr tests to Helix. -->

  <Target Name="RunInParallelForEachScenario">
    <PropertyGroup>
      <!-- This specifies what properties are needed to be passed down as global properties to a child project. -->

      <_PropertiesToPass>
        __BuildArch=$(__BuildArch);
        __BuildOS=$(__BuildOS);
        __BuildType=$(__BuildType);
        Creator=$(_Creator);
        HelixAccessToken=$(_HelixAccessToken);
        HelixBuild=$(_HelixBuild);
        HelixSource=$(_HelixSource);
        HelixTargetQueues=$(_HelixTargetQueues);
        HelixType=$(_HelixType);
        PublishTestResults=$(_PublishTestResults);
        RunCrossGen=$(_RunCrossGen);
        TimeoutPerTestCollectionInMinutes=$(_TimeoutPerTestCollectionInMinutes);
        TimeoutPerTestInMinutes=$(_TimeoutPerTestInMinutes)
      </_PropertiesToPass>
    </PropertyGroup>

    <MSBuild Projects="$(MSBuildProjectFile)" Targets="PrepareCorrelationPayloadDirectory" />
    <MSBuild Projects="$(MSBuildProjectFile)" Targets="CreateAllTestEnvFiles" Properties="Scenarios=$(_Scenarios)" StopOnFirstFailure="true" />

    <ItemGroup>
      <_Scenarios Include="$(_Scenarios.Split(','))" />

      <!-- MSBuild creates a new instance of the project for each %(_Scenarios.Identity) and can build them in parallel. -->
      <_ProjectsToBuild Include="$(MSBuildProjectFile)">
        <AdditionalProperties>$(_PropertiesToPass);Scenario=%(_Scenarios.Identity)</AdditionalProperties>
      </_ProjectsToBuild>
    </ItemGroup>

    <PropertyGroup>
      <_BuildInParallel>false</_BuildInParallel>
      <_BuildInParallel Condition=" '@(_ProjectsToBuild->Count())' &gt; '1' ">true</_BuildInParallel>
    </PropertyGroup>

    <MSBuild Projects="@(_ProjectsToBuild)" Targets="Test" BuildInParallel="$(_BuildInParallel)" StopOnFirstFailure="false" Properties="UsesHelixSdk=true" />
    <!-- <MSBuild Projects="@(_ProjectsToBuild)" Targets="FakeTest" BuildInParallel="false" StopOnFirstFailure="false" Properties="UsesHelixSdk=true" /> -->
  </Target>

  <PropertyGroup>
    <!-- Set the TargetFramework just to make the SDK happy -->
    <!-- NEEDED? <TargetFramework>netstandard2.0</TargetFramework> -->
  </PropertyGroup>

  <PropertyGroup>
    <Creator>$(_Creator)</Creator>
    <HelixAccessToken>$(_HelixAccessToken)</HelixAccessToken>
    <HelixBuild>$(_HelixBuild)</HelixBuild>
    <HelixSource>$(_HelixSource)</HelixSource>
    <HelixTargetQueues>$(_HelixTargetQueues)</HelixTargetQueues>
    <HelixType>$(_HelixType)</HelixType>
    <HelixArchitecture>$(__BuildArch)</HelixArchitecture>
    <HelixConfiguration>$(__BuildType)</HelixConfiguration>

    <!--
      TODO: ProjectDir, RootBinDir, TestWorkingDir, and TargetsWindows are global properties set in dir.props, remove the property assignment here when we port to arcade.
     -->
    <ProjectDir Condition="'$(__ProjectDir)'==''">$(MSBuildThisFileDirectory)..\</ProjectDir>
    <RootBinDir Condition="'$(__RootBinDir)'==''">$(ProjectDir)bin\</RootBinDir>
    <TestWorkingDir Condition="'$(__TestWorkingDir)'==''">$(RootBinDir)tests\$(__BuildOS).$(__BuildArch).$(__BuildType)\</TestWorkingDir>
    <TargetsWindows Condition="'$(__BuildOS)' == 'Windows_NT'">true</TargetsWindows>

    <TestHostRootPath>$(TestWorkingDir)testhost\</TestHostRootPath>
    <TestArchiveRuntimeRoot>$(TestWorkingDir)helix\</TestArchiveRuntimeRoot>
    <TestArchiveRuntimeFile>$(TestArchiveRuntimeRoot)testhost-runtime.zip</TestArchiveRuntimeFile>

    <EnableAzurePipelinesReporter>$(_PublishTestResults)</EnableAzurePipelinesReporter>
    <EnableAzurePipelinesReporter Condition=" '$(EnableAzurePipelinesReporter)' == '' ">false</EnableAzurePipelinesReporter>
    <EnableXUnitReporter>true</EnableXUnitReporter>
    <FailOnMissionControlTestFailure>true</FailOnMissionControlTestFailure>
    <FailOnWorkItemFailure>true</FailOnWorkItemFailure>

    <TimeoutInSeconds Condition="'$(TimeoutInSeconds)' == ''">600</TimeoutInSeconds>
    <CommandTimeoutSpan>$([System.TimeSpan]::FromSeconds($(TimeoutInSeconds)))</CommandTimeoutSpan>
    <MaxRetryCount Condition="'$(MaxRetryCount)' == ''">4</MaxRetryCount>
    <WaitForWorkItemCompletion>true</WaitForWorkItemCompletion>
  </PropertyGroup>

  <PropertyGroup>
    <!--
      For Windows we need to use "call", since the command is going to be called from a batch script created by Helix.
      We "exit /b" at the end of RunTests.cmd. Helix runs some other commands after ours within the batch script,
      so if we don't use call, then we cause the parent script to exit, and anything after will not be executed.
      The arguments passed in to the run script in order are the runtime directory, the dotnet root directory (for
      helix submissions same as the runtime directory) and the global tools directory.
    -->
    <HelixCommand Condition="'$(TargetsWindows)' == 'true'">call RunTests.cmd -r %HELIX_CORRELATION_PAYLOAD% -d %HELIX_CORRELATION_PAYLOAD% -g %HELIX_CORRELATION_PAYLOAD%\tools --rsp-file %HELIX_CORRELATION_PAYLOAD%\CoreFX.issues.rsp </HelixCommand>
    <HelixCommand Condition="'$(TargetsWindows)' != 'true'">./RunTests.sh -r $HELIX_CORRELATION_PAYLOAD -d $HELIX_CORRELATION_PAYLOAD -g $HELIX_CORRELATION_PAYLOAD/tools --rsp-file $HELIX_CORRELATION_PAYLOAD/CoreFX.issues.rsp </HelixCommand>
  </PropertyGroup>

  <ItemGroup>
    <TestArchiveRuntimeInputs Include="$(TestHostRootPath)**/*" />
  </ItemGroup>

  <Target Name="CopyRSPFile">
    <Copy
      SourceFiles="$(ProjectDir)\tests\CoreFX\CoreFX.issues.rsp"
      DestinationFolder="$(TestHostRootPath)" />
  </Target>

  <PropertyGroup>
    <TestEnvFileName Condition=" '$(TargetsWindows)' == 'true' ">SetStressModes_$(Scenario).cmd</TestEnvFileName>
    <TestEnvFileName Condition=" '$(TargetsWindows)' != 'true' ">SetStressModes_$(Scenario).sh</TestEnvFileName>
  </PropertyGroup>

  <Target Name="CreateTestEnvFiles">
    <!-- This target creates one __TestEnv file for the $(Scenario). -->

    <ItemGroup>
      <_ProjectsToBuild Include="..\tests\testenvironment.proj">
        <Properties>Scenario=$(Scenario);TestEnvFileName=$(TestHostRootPath)\$(TestEnvFileName);TargetsWindows=$(TargetsWindows)</Properties>
      </_ProjectsToBuild>
    </ItemGroup>

    <MSBuild Projects="@(_ProjectsToBuild)" Targets="CreateTestEnvFile" StopOnFirstFailure="true" />
  </Target>

  <Target Name="CreateAllTestEnvFiles">
    <!-- This target creates one __TestEnv file for each of the $(Scenarios). -->

    <ItemGroup>
      <_Scenario Include="$(Scenarios.Split(','))" />
      <_ProjectsToBuild Include="$(MSBuildProjectFile)">
        <AdditionalProperties>Scenario=%(_Scenario.Identity)</AdditionalProperties>
      </_ProjectsToBuild>
    </ItemGroup>

    <MSBuild Projects="@(_ProjectsToBuild)" Targets="CreateTestEnvFiles" StopOnFirstFailure="true" />
  </Target>

  <Target Name="CompressRuntimeDirectory"
          Inputs="@(TestArchiveRuntimeInputs)"
          Outputs="$(TestArchiveRuntimeFile)"
          DependsOnTargets="CopyRSPFile" >

    <MakeDir Directories="$(TestArchiveRuntimeRoot)" />

    <ZipDirectory
        SourceDirectory="$(TestHostRootPath)"
        DestinationFile="$(TestArchiveRuntimeFile)"
        Overwrite="true" />

    <Message Importance="High" Text="Zipped correlation payload into $(TestArchiveRuntimeFile)" />
  </Target>

  <PropertyGroup>
    <TestAssetBlobFeedUrl>https://dotnetfeed.blob.core.windows.net/dotnet-core</TestAssetBlobFeedUrl>
  </PropertyGroup>

  <!-- WARNING: HelixPreCommand ItemGroup is intentionally minimal and should be kept that way. -->

  <ItemGroup Condition=" '$(TargetsWindows)' == 'true' ">
    <HelixPreCommand Include="set __TestEnv=%HELIX_CORRELATION_PAYLOAD%\$(TestEnvFileName)" />
    <HelixPreCommand Include="type %__TestEnv%" />
    <HelixPreCommand Include="call %__TestEnv%" />
  </ItemGroup>

  <ItemGroup Condition=" '$(TargetsWindows)' != 'true' ">
    <HelixPreCommand Include="export __TestEnv=$HELIX_CORRELATION_PAYLOAD/$(TestEnvFileName)" />
    <HelixPreCommand Include="cat $__TestEnv" />
    <HelixPreCommand Include="source $__TestEnv" />
  </ItemGroup>

  <PropertyGroup>
    <HelixPreCommands>@(HelixPreCommand)</HelixPreCommands>
  </PropertyGroup>

  <Target Name="PrepareCorrelationPayloadDirectory"
          DependsOnTargets="CompressRuntimeDirectory">
  </Target>

  <Target Name="GetTestAssetManifest" Condition=" '$(UsesHelixSdk)' == 'true' " >

    <!--
       Parse the test asset manifest at, e.g.,
           https://dotnetfeed.blob.core.windows.net/dotnet-core/corefx-tests/4.6.0-preview6.19264.9/Linux.arm64/netcoreapp/corefx-test-assets.xml
       to figure out the tests to run. This manifest is created by the corefx official build, for use in the coreclr repo.
     -->

    <PropertyGroup>
      <_TargetGroup>netcoreapp</_TargetGroup>
      <_AssetManifestPath>$(TestAssetBlobFeedUrl)/corefx-tests/$(MicrosoftPrivateCoreFxNETCoreAppVersion)/$(__BuildOS).$(__BuildArch)/$(_TargetGroup)/corefx-test-assets.xml</_AssetManifestPath>
    </PropertyGroup>

    <ParseBuildManifest AssetManifestPath="$(_AssetManifestPath)">
      <Output TaskParameter="BlobInfos" ItemName="TestAssetBlobInfos" />
    </ParseBuildManifest>

    <!-- <Message Importance="High" Text="%(TestAssetBlobInfos.Identity): %(FileName)" /> -->

  </Target>

  <Target Name="BuildHelixWorkItems" DependsOnTargets="GetTestAssetManifest" Condition=" '$(UsesHelixSdk)' == 'true' " >

    <ItemGroup Condition=" '$(UsesHelixSdk)' == 'true' ">
      <HelixCorrelationPayload 
        Include="$(TestArchiveRuntimeFile)" />

      <HelixWorkItem Include="@(TestAssetBlobInfos -> '%(FileName)')">
        <PayloadUri>$(TestAssetBlobFeedUrl)/%(Identity)</PayloadUri>
        <Command>$(HelixCommand)</Command>
        <Timeout>$(CommandTimeoutSpan)</Timeout>
      </HelixWorkItem>
    </ItemGroup>

  </Target>

  <!-- for testing! -->
  <Target Name="FakeTest" Condition=" '$(UsesHelixSdk)' == 'true' " >
    <Message Importance="High" Text="Starting FakeTest" />  
    <Message Importance="High" Text="Scenario = $(Scenario)" />  
    <Message Importance="High" Text="TestHostRootPath = $(TestHostRootPath)" />  
    <Message Importance="High" Text="TestArchiveRuntimeFile = $(TestArchiveRuntimeFile)" />  
    <Message Importance="High" Text="BuildInParallel = $(BuildInParallel)" />  
    <Message Importance="High" Text="UsesHelixSdk = $(UsesHelixSdk)" />  
    <Message Importance="High" Text="%(HelixWorkItem.Identity): %(Command)" />  
    <Message Importance="High" Text="Pre commands: $(HelixPreCommands)" />  
    <Message Importance="High" Text="Ending FakeTest" />  
  </Target>

  <Import Sdk="Microsoft.DotNet.Helix.Sdk" Project="Sdk.targets" Condition=" '$(UsesHelixSdk)' == 'true' " />

</Project>
