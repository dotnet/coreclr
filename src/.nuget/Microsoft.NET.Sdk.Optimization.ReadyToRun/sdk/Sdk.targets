<!--
***********************************************************************************************
Sdk.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- Remaining Work:
    1) Inject CreateReadyToRunImages at correct entrypoint in the build. Related to https://github.com/dotnet/sdk/issues/2583
  -->
  <PropertyGroup>
    <_IntermediateReadyToRunDirName Condition=" '$(_IntermediateReadyToRunDirName)' == '' ">ReadyToRun</_IntermediateReadyToRunDirName>
    <_IntermediateReadyToRunDir Condition=" '$(_IntermediateReadyToRunDir)' == '' ">$(IntermediateOutputPath)$(_IntermediateReadyToRunDirName)</_IntermediateReadyToRunDir>
    <_IntermediateReadyToRunDir>$([System.IO.Path]::GetFullPath($(_IntermediateReadyToRunDir)))</_IntermediateReadyToRunDir>

    <_ReadyToRunOutputDir>$([System.IO.Path]::Combine($(_IntermediateReadyToRunDir),"Output"))</_ReadyToRunOutputDir>
  </PropertyGroup>

  <Target Name="CreateReadyToRunImages"
          BeforeTargets="ComputeFilesToPublish"
          DependsOnTargets="_CheckForUnsupportedReadyToRunCompilation;
                            _InitializeReadyToRunCompilerProps;
                            _ComputeReadyToRunInputsAndOutputs;
                            _RunReadyToRunCompiler;
                            _PublishReadyToRunOutputs"
          Condition="'$(ReadyToRun)' == 'true'">
  </Target>

  <Target Name="_CheckForUnsupportedReadyToRunCompilation"
          Condition="'$(ReadyToRun)' == 'true'">

    <!-- TODO: Add this message as a resource string to the NET SDK so it can be localized -->
    <NETSdkError Condition="'3.0' > '$(_TargetFrameworkVersionWithoutV)'"
        FormattedText="Creating ReadyToRun images is only supported for .NET Core 3.0 and above" />

    <NETSdkError Condition="'$(RuntimeIdentifier)' ==''"
                 ResourceName="RuntimeIdentifierWasNotSpecified"/>

    <NETSdkError Condition="'$(TargetFramework)' ==''"
                 ResourceName="AtLeastOneTargetFrameworkMustBeSpecified"/>

    <!-- Determine whether the host OS platform-architecture supports compilation to the desired RuntimeIdentifier -->
    <PropertyGroup>
      <_TargetArchitecture>$(PlatformTarget)</_TargetArchitecture>
      <_TargetArchitecture Condition="$(RuntimeIdentifier.EndsWith('arm64'))">arm64</_TargetArchitecture>

      <_OSPlatform Condition="$([MSBuild]::IsOSPlatform('windows'))">win</_OSPlatform>
      <_OSPlatform Condition="$([MSBuild]::IsOSPlatform('osx'))">osx</_OSPlatform>
      <_OSPlatform Condition="$([MSBuild]::IsOSPlatform('linux'))">linux</_OSPlatform>
      <_OSArchitecture>$([System.Runtime.InteropServices.RuntimeInformation]::OSArchitecture)</_OSArchitecture>

      <_UnsupportedReadyToRunCompilation>false</_UnsupportedReadyToRunCompilation>

      <!-- First check that the host and target OS are the same -->
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSPlatform)' == 'win' and !$(RuntimeIdentifier.StartsWith('win'))">true</_UnsupportedReadyToRunCompilation>
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSPlatform)' == 'osx' and !$(RuntimeIdentifier.StartsWith('osx'))">true</_UnsupportedReadyToRunCompilation>

      <!-- TODO: Allow cross-compilation to work for Crossgen in supported scenarios -->
      <!-- Next check that the host can compile for the target OS architecture -->
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSArchitecture)' == 'x86' and ('$(_TargetArchitecture)' != 'x86' and '$(_TargetArchitecture)' != 'arm')">true</_UnsupportedReadyToRunCompilation>
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSArchitecture)' == 'arm' and '$(_TargetArchitecture)' != 'arm'">true</_UnsupportedReadyToRunCompilation>
      <!-- TODO insert arm64 capabilities. Specifically, can we always assume arm64 architectures can emulate arm? What about x86? -->
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSArchitecture)' == 'arm64' and '$(_TargetArchitecture)' != 'arm64'">true</_UnsupportedReadyToRunCompilation>
    </PropertyGroup>

    <!-- TODO: Add this message as a resource string to the NET SDK so it can be localized -->
    <NETSdkError Condition="'$(_UnsupportedReadyToRunCompilation)' == 'true'"
        FormattedText="Creating ReadyToRun images is not supported for the RuntimeIdentifier $(RuntimeIdentifier) on the host OS $(_OSPlatform)-$(_OSArchitecture.ToLower())" />
  </Target>

  <Target Name="_InitializeReadyToRunCompilerProps"
          Condition="'$(ReadyToRun)' == 'true'">
    <!-- Get the coreclr path -->
    <ItemGroup>
      <!-- TODO: Switch to using %(ResolvedTargetingPack) to find the targeting pack-->
      <_CoreclrResolvedPath Include="@(ResolvedAssembliesToPublish)"
                                             Condition="'%(ResolvedAssembliesToPublish.Filename)'=='coreclr'" />
      <_CoreclrResolvedPath Include="@(ResolvedAssembliesToPublish)"
                                             Condition="'%(ResolvedAssembliesToPublish.Filename)'=='libcoreclr'" />
      <_JitFilenameItem Include="@(ResolvedAssembliesToPublish->'%(Filename)%(Extension)')"
                                             Condition="'%(ResolvedAssembliesToPublish.Filename)'=='clrjit'" />
      <_JitFilenameItem Include="@(ResolvedAssembliesToPublish->'%(Filename)%(Extension)')"
                                             Condition="'%(ResolvedAssembliesToPublish.Filename)'=='libclrjit'" />
    </ItemGroup>

    <!-- Get the individual paths for the Jit, DiaSymReader, and Crossgen -->
    <PropertyGroup>
      <_CoreclrPath>@(_CoreclrResolvedPath)</_CoreclrPath>
      <_CoreclrDir>$([System.IO.Path]::GetDirectoryName($(_CoreclrPath)))</_CoreclrDir>
      <_CoreclrPkgDir>$([System.IO.Path]::Combine($(_CoreclrDir),"..\..\..\"))</_CoreclrPkgDir>

      <_JitDir>$(_CoreclrDir)</_JitDir>
      <_JitFilename>@(_JitFilenameItem)</_JitFilename>
      <_JitDir Condition="'$(_TargetArchitecture)' == 'arm' and '$(_OSArchitecture)'!='arm' and '$(_OSPlatform)' == 'win'">$([System.IO.Path]::Combine($(_CoreclrPkgDir),"runtimes","x86_arm","native"))</_JitDir>
      <_JitDir Condition="'$(_TargetArchitecture)' == 'arm' and '$(_OSArchitecture)'!='arm' and '$(_OSPlatform)' != 'win'">$([System.IO.Path]::Combine($(_CoreclrPkgDir),"runtimes","$(_OSArchitecture)_arm","native"))</_JitDir>
      <_JitDir Condition="'$(_TargetArchitecture)' == 'arm64' and '$(_OSArchitecture)'!='arm64'">$([System.IO.Path]::Combine($(_CoreclrPkgDir),"runtimes","x64_arm64","native"))</_JitDir>
      <JitPath>$([System.IO.Path]::Combine($(_JitDir),$(_JitFilename)))</JitPath>

      <DiaSymReaderArch>$(_TargetArchitecture)</DiaSymReaderArch>
      <DiaSymReaderArch Condition="'$(_TargetArchitecture)' == 'x64'">amd64</DiaSymReaderArch>
      <DiaSymReaderArch Condition="'$(_TargetArchitecture)' == 'arm' and '$(_OSArchitecture)'!='arm' and '$(_OSPlatform)' == 'win'">x86</DiaSymReaderArch>
      <DiaSymReaderFilename>Microsoft.DiaSymReader.Native.$(DiaSymReaderArch).dll</DiaSymReaderFilename>
      <DiaSymReaderPath>$([System.IO.Path]::Combine($(_CoreclrDir),$(DiaSymReaderFilename)))</DiaSymReaderPath>

      <DiaSymReaderExistsForTargetArchitecture>true</DiaSymReaderExistsForTargetArchitecture>
      <DiaSymReaderExistsForTargetArchitecture Condition="'$(_OSPlatform)' != 'win'">false</DiaSymReaderExistsForTargetArchitecture>
      <!-- Remove the arm64 check when https://github.com/dotnet/coreclr/issues/7360 is resolved -->
      <DiaSymReaderExistsForTargetArchitecture Condition="'$(_TargetArchitecture)'=='arm64'">false</DiaSymReaderExistsForTargetArchitecture>

      <CrossgenDir>$([System.IO.Path]::Combine($(_CoreclrPkgDir),"tools"))</CrossgenDir>
      <CrossgenDir Condition="'$(_TargetArchitecture)' == 'arm' and '$(_OSArchitecture)'!='arm' and '$(_OSPlatform)' == 'win'">$([System.IO.Path]::Combine($(CrossgenDir),"x86_arm"))</CrossgenDir>
      <CrossgenDir Condition="'$(_TargetArchitecture)' == 'arm' and '$(_OSArchitecture)'!='arm' and '$(_OSPlatform)' != 'win'">$([System.IO.Path]::Combine($(CrossgenDir),"$(_OSArchitecture)_arm"))</CrossgenDir>
      <CrossgenDir Condition="'$(_TargetArchitecture)' == 'arm64' and '$(_OSArchitecture)'!='arm64'">$([System.IO.Path]::Combine($(CrossgenDir),"x64_arm64"))</CrossgenDir>
      <Crossgen>$([System.IO.Path]::Combine($(CrossgenDir),"crossgen"))</Crossgen>
      <Crossgen Condition="'$(OS)' == 'Windows_NT'">$([System.IO.Path]::Combine($(CrossgenDir),"crossgen.exe"))</Crossgen>
    </PropertyGroup>

    <!-- Check that there is one unique assembly for several sensitive assemblies -->
    <NETSdkError Condition="'$(DiaSymReaderExistsForTargetArchitecture)' == 'true' and !Exists($(DiaSymReaderPath))"
                 ResourceName="UnableToFindResolvedPath"
                 FormatArguments="$(DiaSymReaderPath)" />

    <NETSdkError Condition="!Exists($(JitPath))"
                 ResourceName="UnableToFindResolvedPath"
                 FormatArguments="$(JitPath)" />

    <NETSdkError Condition="!Exists($(Crossgen))"
                 ResourceName="UnableToFindResolvedPath"
                 FormatArguments="$(Crossgen)" />
  </Target>

  <UsingTask TaskName="FilterManagedAssemblies" AssemblyFile="$(MicrosoftNETBuildTasksAssembly)" />
  <Target Name="_ComputeReadyToRunInputsAndOutputs"
          Condition="'$(ReadyToRun)' == 'true'">
    <PropertyGroup>
      <_RuntimePackageName Condition="'%(ResolvedAssembliesToPublish.FileName)%(ResolvedAssembliesToPublish.Extension)' == 'System.Private.CoreLib.dll'">%(ResolvedAssembliesToPublish.PackageName)</_RuntimePackageName>
    </PropertyGroup>

    <!-- Initialize the list of input assemblies -->
    <ItemGroup>
      <_CrossgenInputIntermediateAssembly Include="@(IntermediateAssembly)" />

      <_CrossgenUnfilteredInputAssemblies Include="@(_CrossgenInputIntermediateAssembly)" />
      <_CrossgenUnfilteredInputAssemblies Include="@(ResolvedAssembliesToPublish)" Condition="'$(ReadyToRunAllPublishRuntimeAssets)' == 'true' and '%(ResolvedAssembliesToPublish.AssetType)' == 'runtime'" />
      <_CrossgenUnfilteredInputAssemblies Remove="@(_CrossgenUnfilteredInputAssemblies)" Condition="'%(_CrossgenUnfilteredInputAssemblies.PackageName)' == '$(_RuntimePackageName)'" />

      <_CrossgenReferenceAssemblies Include="@(ResolvedAssembliesToPublish)" /> 
    </ItemGroup>

    <!-- Filter the input assemblies to only those that are managed and IL ONLY -->
    <FilterManagedAssemblies Assemblies="@(_CrossgenUnfilteredInputAssemblies)"
                             RestrictToILOnlyAssemblies="true">
      <Output TaskParameter="ManagedAssemblies" ItemName="_CrossgenInputAssemblies"/>
    </FilterManagedAssemblies>

    <!-- Set the final list of expected output assemblies -->
    <ItemGroup>
      <_CrossgenOutputIntermediateAssembly Include="@(_CrossgenInputIntermediateAssembly->'$(_ReadyToRunOutputDir)/%(FileName)%(Extension)')" />
      <_CrossgenOutputAssemblies Include="@(_CrossgenInputAssemblies->'$(_ReadyToRunOutputDir)/%(FileName)%(Extension)')" />
    </ItemGroup>
  </Target>

  <Target Name="_RunReadyToRunCompiler"
          Inputs="@(_CrossgenInputAssemblies);"
          Outputs="@(_CrossgenOutputAssemblies)"
          Condition="'$(ReadyToRun)' == 'true'">
    <ItemGroup>
      <_CrossgenPlatformAssembliesPathsWithDuplicates Include="@(_CrossgenReferenceAssemblies->'%(RootDir)%(Directory)')" /> 
      <_CrossgenPlatformAssembliesPaths Include="@(_CrossgenPlatformAssembliesPathsWithDuplicates->Distinct())" />
    </ItemGroup>

    <!-- Specific work for the Exec invocations -->
    <PropertyGroup>
      <_PathSeparator>$([System.IO.Path]::PathSeparator)</_PathSeparator>
      <_DirectorySeparatorChar>$([System.IO.Path]::DirectorySeparatorChar)</_DirectorySeparatorChar>
      <_CrossgenPlatformAssembliesPathsProperty>@(_CrossgenPlatformAssembliesPaths, '$(_PathSeparator)')</_CrossgenPlatformAssembliesPathsProperty>
      <!-- Remove the trailing slash so it does not get misinterpreted by Exec -->
      <_CrossgenPlatformAssembliesPathsProperty>$(_CrossgenPlatformAssembliesPathsProperty.TrimEnd('\'))</_CrossgenPlatformAssembliesPathsProperty>
    </PropertyGroup>

    <PropertyGroup>
      <CrossgenCommand>$(Crossgen) -nologo -readytorun -jitpath &quot;$(JitPath)&quot; -platform_assemblies_paths &quot;$(_CrossgenPlatformAssembliesPathsProperty)&quot;</CrossgenCommand>
      <CrossgenCreatePdbCommand>$(Crossgen) -nologo -createpdb &quot;$(_ReadyToRunOutputDir)&quot; -diasymreaderpath &quot;$(DiaSymReaderPath)&quot; -platform_assemblies_paths &quot;$(_CrossgenPlatformAssembliesPathsProperty)&quot;</CrossgenCreatePdbCommand>
    </PropertyGroup>

    <MakeDir Directories="$(_ReadyToRunOutputDir)"/>

    <Message Text="$(CrossgenCommand) -in &quot;%(_CrossgenInputAssemblies.Identity)&quot; -out &quot;$(_ReadyToRunOutputDir)/%(FileName)%(Extension)&quot;" />
    <Exec Command="$(CrossgenCommand) -in &quot;%(_CrossgenInputAssemblies.Identity)&quot; -out &quot;$(_ReadyToRunOutputDir)/%(FileName)%(Extension)&quot;" />

    <Message Text="$(CrossgenCreatePdbCommand) &quot;$(_ReadyToRunOutputDir)$(_DirectorySeparatorChar)%(_CrossgenInputAssemblies.FileName)%(_CrossgenInputAssemblies.Extension)&quot;" Condition="'$(DiaSymReaderExistsForTargetArchitecture)'=='true'" />
    <Exec Command="$(CrossgenCreatePdbCommand) &quot;$(_ReadyToRunOutputDir)$(_DirectorySeparatorChar)%(_CrossgenInputAssemblies.FileName)%(_CrossgenInputAssemblies.Extension)&quot;" Condition="'$(DiaSymReaderExistsForTargetArchitecture)'=='true'" />

    <ItemGroup>
      <FileWrites Include="@(_CrossgenOutputAssemblies)" />
      <FileWrites Include="$(_ReadyToRunOutputDir)/%(_CrossgenInputAssemblies.FileName).ni.pdb" Condition="'$(DiaSymReaderExistsForTargetArchitecture)'=='true'" />
    </ItemGroup>
  </Target>

  <Target Name="_PublishReadyToRunOutputs"
          Condition="'$(ReadyToRun)' == 'true'">
    <!-- Rewrite ResolvedAssembliesToPublish to capture any newly-crossgened ResolvedAssembliesToPublish files, preserving metadata. -->
    <ItemGroup>
      <ResolvedAssembliesToPublish Remove="@(_CrossgenInputAssemblies)" />
      <ResolvedAssembliesToPublish Include="@(_CrossgenOutputAssemblies)" />
      <ResolvedAssembliesToPublish Remove="@(_CrossgenOutputIntermediateAssembly)" />
    </ItemGroup>

    <!-- Rewrite IntermediateAssembly to capture the newly-crossgened IntermediateAssembly, preserving metadata. -->
    <ItemGroup>
      <IntermediateAssembly Remove="@(_CrossgenInputIntermediateAssembly)" />
      <IntermediateAssembly Include="@(_CrossgenOutputIntermediateAssembly)" />
    </ItemGroup>
  </Target>
</Project>