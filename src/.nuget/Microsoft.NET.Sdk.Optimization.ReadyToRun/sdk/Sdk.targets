<!--
***********************************************************************************************
Sdk.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
<!-- USER CODE -->
 <!-- Remaining Work:
    1) Inject CreateReadyToRunImages at correct entrypoint in the build. Related to https://github.com/dotnet/sdk/issues/2583
    2)  -->

  <!-- Proposed SDK changes -->
  <!--
There exist several dependencies from Microsoft.NET.CrossGen.targets on Microsoft.NET.ComposeStore.targets
  - _RestoreCrossgen (crossgen.targets) depends on PrepforRestoreForComposeStore (composestore.targets)
    - This unnecessarily sets $(StoreWorkerWorkingDir)
    - This unnecessarily sets $(BaseIntermediateOutputPath)
    - This unnecessarily sets $(ProjectAssetsFile)
  - Implicit dependency where ComposeStore targets call PrepareForComposeStore
    - This sets $(_TFM)
    - This sets $(ComposeWorkingDir)
  -->
  <Target Name="CreateReadyToRunImages"
          BeforeTargets="ComputeFilesToPublish"
          DependsOnTargets="CheckForUnsupportedReadyToRunCompilation;
                            PrepareForReadyToRun;
                            _ComputeCrossGenInputs;
                            _Custom_PrepOptimizer;
                            _RunCrossgenOnInputs;
                            _PublishCrossgenOutputs"
          Condition="'$(ShouldCreateReadyToRunImages)' == 'true'">
  </Target>

  <Target Name="CheckForUnsupportedReadyToRunCompilation"
          Condition="'$(ShouldCreateReadyToRunImages)' == 'true'">

    <!-- TODO: Add this message as a resource string to the NET SDK so it can be localized -->
    <NETSdkError Condition="'3.0' > '$(_TargetFrameworkVersionWithoutV)'"
        FormattedText="Creating ReadyToRun images is only supported for .NET Core 3.0 and above" />

    <NETSdkError Condition="'$(RuntimeIdentifier)' ==''"
                 ResourceName="RuntimeIdentifierWasNotSpecified"/>

    <NETSdkError Condition="'$(TargetFramework)' ==''"
                 ResourceName="AtLeastOneTargetFrameworkMustBeSpecified"/>

    <!-- Determine the host OS platform|architecture -->
    <PropertyGroup>
      <_OSPlatform Condition="$([MSBuild]::IsOSPlatform('windows'))">win</_OSPlatform>
      <_OSPlatform Condition="$([MSBuild]::IsOSPlatform('osx'))">osx</_OSPlatform>
      <_OSPlatform Condition="$([MSBuild]::IsOSPlatform('linux'))">linux</_OSPlatform>
      <_OSArchitecture>$([System.Runtime.InteropServices.RuntimeInformation]::OSArchitecture)</_OSArchitecture>

      <_UnsupportedReadyToRunCompilation>false</_UnsupportedReadyToRunCompilation>
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSPlatform)' == 'win' and !$(RuntimeIdentifier.StartsWith('win'))">true</_UnsupportedReadyToRunCompilation>
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSPlatform)' == 'osx' and !$(RuntimeIdentifier.StartsWith('osx'))">true</_UnsupportedReadyToRunCompilation>
      <!-- TODO: Allow cross-compilation to work for CrossGen in supported scenarios -->
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSArchitecture)' != '$(PlatformTarget)'">true</_UnsupportedReadyToRunCompilation>
    </PropertyGroup>

    <!-- TODO: Add this message as a resource string to the NET SDK so it can be localized -->
    <NETSdkError Condition="'$(_UnsupportedReadyToRunCompilation)' == 'true'"
        FormattedText="Creating ReadyToRun images is not supported for the RuntimeIdentifier $(RuntimeIdentifier) on the host OS $(_OSPlatform)-$(_OSArchitecture.ToLower())" />
  </Target>

  <Target Name="PrepareForReadyToRun"
          Condition="'$(ShouldCreateReadyToRunImages)' == 'true'">
    <PropertyGroup>
      <_TFM Condition="'$(_TFM)' == ''">$(TargetFramework)</_TFM>

      <IntermediateOptimizedDirName Condition=" '$(IntermediateOptimizedDirName)' == '' ">optimized</IntermediateOptimizedDirName>
      <IntermediateOptimizedDir Condition=" '$(IntermediateOptimizedDir)' == '' ">$(IntermediateOutputPath)$(IntermediateOptimizedDirName)</IntermediateOptimizedDir>
      <IntermediateCrossGenDirName Condition=" '$(IntermediateCrossGenDirName)' == '' ">readytorun</IntermediateCrossGenDirName>
      <IntermediateCrossGenDir Condition=" '$(IntermediateCrossGenDir)' == '' ">$(IntermediateOutputPath)$(IntermediateCrossGenDirName)</IntermediateCrossGenDir>

      <ComposeWorkingDir Condition="'$(ComposeWorkingDir)' == ''">$(IntermediateCrossGenDir)</ComposeWorkingDir>
      <ComposeWorkingDir>$([System.IO.Path]::GetFullPath($(ComposeWorkingDir)))</ComposeWorkingDir>
    </PropertyGroup>

    <!-- Properties originally set by PrepforRestoreForComposeStore -->
    <PropertyGroup>
      <StorePackageVersionForFolderName>$(StorePackageVersion.Replace('*','-'))</StorePackageVersionForFolderName>
      <StoreWorkerWorkingDir>$([System.IO.Path]::Combine($(ComposeWorkingDir),"$(StorePackageName)_$(StorePackageVersionForFolderName)"))</StoreWorkerWorkingDir>
    </PropertyGroup>

    <PropertyGroup>
      <SelfContained Condition="'$(SelfContained)' == ''">true</SelfContained>
    </PropertyGroup>
  </Target>

  <Target Name="_ComputeCrossGenInputs">
    <ItemGroup>
      <_CrossGenInputAssemblies Include="@(IntermediateAssembly)" />
      <!-- If we want to crossgen other IL assemblies, we must filter out the native assemblies -->
      <!-- <_CrossGenInputAssemblies Include="@(ResolvedAssembliesToPublish)" Condition="'%(ResolvedAssembliesToPublish.AssetType)' == 'runtime'" /> -->

      <_CrossGenReferenceAssemblies Include="@(IntermediateAssembly)" />
      <_CrossGenReferenceAssemblies Include="@(ResolvedAssembliesToPublish)" />
    </ItemGroup>
  </Target>

  <Target Name="_RunCrossgenOnInputs">
    <PropertyGroup>
      <_CrossGenPlatformAssemblies>@(_CrossGenReferenceAssemblies)</_CrossGenPlatformAssemblies>
    </PropertyGroup>

    <ItemGroup>
      <CrossGenInvocations Include="$(MSBuildProjectFullPath)">
        <Properties>
          CrossgenExe=$(Crossgen);
          CrossgenInput=%(_CrossGenInputAssemblies.FullPath);
          CrossgenOutput=$(_RuntimeOptimizedDir)/%(FileName)%(Extension);
          CrossGenPlatformAssemblies=$(_CrossGenPlatformAssemblies);
        </Properties>
      </CrossGenInvocations>
    </ItemGroup>

    <MSBuild Projects="@(CrossGenInvocations)"
             Targets="InvokeCrossGenForReadyToRun" />
  </Target>

  <Target Name="InvokeCrossGenForReadyToRun"
          Inputs="$(CrossGenInput);$(CrossGenPlatformAssemblies)"
          Outputs="$(CrossGenOutput)">
    <ItemGroup>
      <_CrossGenPlatformAssemblies Include="$(CrossGenPlatformAssemblies)" />
      <__CrossGenPlatformAssembliesPaths Include="@(_CrossGenPlatformAssemblies->'%(RootDir)%(Directory)')" /> 
      <_CrossGenPlatformAssembliesPaths Include="@(__CrossGenPlatformAssembliesPaths->Distinct())" />
    </ItemGroup>

    <PropertyGroup>
      <_PathSeparator>$([System.IO.Path]::PathSeparator)</_PathSeparator>
      <_CrossGenPlatformAssembliesPathsProperty>@(_CrossGenPlatformAssembliesPaths, '$(_PathSeparator)')</_CrossGenPlatformAssembliesPathsProperty>
    </PropertyGroup>

    <PropertyGroup>
      <CrossGenCommand>$(CrossGenExe) -readytorun -in $(CrossGenInput) -out $(CrossGenOutput) -platform_assemblies_paths &quot;$(_CrossGenPlatformAssembliesPathsProperty)&quot;</CrossGenCommand> 
    </PropertyGroup>

    <Message Text="$(CrossGenCommand)" />
    <Exec Command="$(CrossGenCommand)" />
  </Target>

  <Target Name="_PublishCrossgenOutputs">
    <!-- Rewrite ResolvedAssembliesToPublish to capture any newly-crossgened ResolvedAssembliesToPublish files, preserving metadata. -->
    <ItemGroup>
      <_CrossGenResolvedAssembliesToPublishCandidates Include="@(ResolvedAssembliesToPublish->'$(_RuntimeOptimizedDir)/%(Filename)%(Extension)')" />
      <_CrossGenResolvedAssembliesToPublish Include="@(_CrossGenResolvedAssembliesToPublishCandidates)" Condition="Exists('%(Identity)')" />

      <ResolvedAssembliesToPublish Remove="@(_CrossGenInputAssemblies)" />
      <ResolvedAssembliesToPublish Include="@(_CrossGenResolvedAssembliesToPublish)" />
    </ItemGroup>

    <!-- Rewrite IntermediateAssembly to capture the newly-crossgened IntermediateAssembly, preserving metadata. -->
    <ItemGroup>
      <_CrossGenIntermediateAssemblyCandidates Include="@(IntermediateAssembly->'$(_RuntimeOptimizedDir)/%(Filename)%(Extension)')" />
      <_CrossGenIntermediateAssembly Include="@(_CrossGenIntermediateAssemblyCandidates)" Condition="Exists('%(Identity)')" />

      <IntermediateAssembly Remove="@(_CrossGenInputAssemblies)" />
      <IntermediateAssembly Include="@(_CrossGenIntermediateAssembly)" />
    </ItemGroup>
  </Target>

<!-- SDK code -->
  <Target Name="_Custom_PrepOptimizer"
          DependsOnTargets="_Custom_RestoreCrossgen;">
    <!-- Get the coreclr path -->
    <ItemGroup>
      <_CoreclrResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)"
                                             Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='coreclr'" />
      <!-- Copied from CrossGen.targets. Do we use libcoreclr? -->
      <_CoreclrResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)"
                                             Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='libcoreclr'" />
      <_JitResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)"
                                             Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='clrjit'" />
      <!-- Copied from CrossGen.targets. Do we use libclrjit? -->
      <_JitResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)"
                                             Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='libclrjit'" />
      <_SystemPrivateCoreLibResolvedPath Include="@(CrossgenResolvedAssembliesToPublish)"
                                             Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='System.Private.CoreLib'" />
      <!-- TODO: Copy over Microsoft.DiaSymReader.Native when I figure out the right condition-->
      <!--<_MicrosoftDiaSymReaderNativePaths Include="@(CrossgenResolvedAssembliesToPublish)"
                                             Condition="'%(CrossgenResolvedAssembliesToPublish.Filename)'=='Microsoft.DiaSymReader.Native'" />-->
    </ItemGroup>

    <NETSdkError Condition="'@(_CoreclrResolvedPath->Count())' &gt; 1"
                 ResourceName="MultipleFilesResolved"
                 FormatArguments="coreclr" />

    <NETSdkError Condition="'@(_CoreclrResolvedPath)'== ''"
                 ResourceName="UnableToFindResolvedPath"
                 FormatArguments="coreclr" />

    <NETSdkError Condition="'@(_JitResolvedPath->Count())' &gt; 1"
                 ResourceName="MultipleFilesResolved"
                 FormatArguments="jit" />

    <NETSdkError Condition="'@(_JitResolvedPath)'== ''"
                 ResourceName="UnableToFindResolvedPath"
                 FormatArguments="jit" />

    <NETSdkError Condition="'@(_SystemPrivateCoreLibResolvedPath->Count())' &gt; 1"
                 ResourceName="MultipleFilesResolved"
                 FormatArguments="System.Private.CoreLib" />

    <NETSdkError Condition="'@(_SystemPrivateCoreLibResolvedPath)'== ''"
                 ResourceName="UnableToFindResolvedPath"
                 FormatArguments="System.Private.CoreLib" />

    <!-- Get the crossgen and jit path-->
    <PropertyGroup>
      <_CoreclrPath>@(_CoreclrResolvedPath)</_CoreclrPath>
      <JitPath>@(_JitResolvedPath)</JitPath>
      <SystemPrivateCoreLibPath>@(_SystemPrivateCoreLibResolvedPath)</SystemPrivateCoreLibPath>
      <!--<MicrosoftDiaSymReaderNativePaths>@()</MicrosoftDiaSymReaderNativePaths>-->
      <_CoreclrDir>$([System.IO.Path]::GetDirectoryName($(_CoreclrPath)))</_CoreclrDir>
      <_CoreclrPkgDir>$([System.IO.Path]::Combine($(_CoreclrDir),"..\..\..\"))</_CoreclrPkgDir>
      <CrossgenDir>$([System.IO.Path]::Combine($(_CoreclrPkgDir),"tools"))</CrossgenDir>
      <!-- TODO override with rid specific tools path for x-arch -->
      <Crossgen>$([System.IO.Path]::Combine($(CrossgenDir),"crossgen"))</Crossgen>
      <Crossgen Condition="'$(OS)' == 'Windows_NT'">$([System.IO.Path]::Combine($(CrossgenDir),"crossgen.exe"))</Crossgen>
    </PropertyGroup>

    <NETSdkError Condition="!Exists($(Crossgen))"
                 ResourceName="UnableToFindResolvedPath"
                 FormatArguments="$(Crossgen)" />

    <!-- Copy crossgen into the netcoreapp folder to ensure it can load Microsoft.DiaSymReader.Native when creating PDBs -->
    <!-- Copy crossgen.exe and the necessary files side-by-side:
           - clrjit.dll
           - System.Private.CoreLib.dll
           - Microsoft.DiaSymReader.Native.*.dll (TODO)
    -->
    <Copy SourceFiles="$(Crossgen);$(JitPath);$(SystemPrivateCoreLibPath);"
          DestinationFolder="$(_NetCoreRefDir)"
          OverwriteReadOnlyFiles="$(OverwriteReadOnlyFiles)"
          Retries="$(CopyRetryCount)"
          RetryDelayMilliseconds="$(CopyRetryDelayMilliseconds)"
          UseHardlinksIfPossible="$(CreateHardLinksForPublishFilesIfPossible)"
          UseSymboliclinksIfPossible="$(CreateSymbolicLinksForPublishFilesIfPossible)">
      <Output TaskParameter="DestinationFiles" ItemName="FileWrites"/>
    </Copy>
    
    <PropertyGroup>
      <Crossgen>$([System.IO.Path]::GetFullPath($([System.IO.Path]::Combine($(_NetCoreRefDir), $([System.IO.Path]::GetFileName($(Crossgen)))))))</Crossgen>
    </PropertyGroup>
  </Target>

  <!-- TODO: Remove this restore task. We should already have restored the runtime package. However, we'll need to obtain a path to that package somehow -->
  <Target Name="_Custom_RestoreCrossgen"
          DependsOnTargets="ApplyImplicitVersions">
    <PropertyGroup>
      <_CrossProjFileDir>$([System.IO.Path]::Combine($(ComposeWorkingDir),"Optimize"))</_CrossProjFileDir>
      <_NetCoreRefDir>$([System.IO.Path]::Combine($(_CrossProjFileDir), "netcoreapp"))</_NetCoreRefDir>              <!-- flat netcore app assemblies-->
      <_RuntimeOptimizedDir>$([System.IO.Path]::Combine($(StoreWorkerWorkingDir), "runtimopt"))</_RuntimeOptimizedDir>      <!-- optimized app managed assemblies in nuget cache layout -->
    </PropertyGroup>

    <MakeDir Directories="$(_CrossProjFileDir)"/>
    <MakeDir Directories="$(_RuntimeOptimizedDir)"/>

    <PropertyGroup>
      <_CrossProjAssetsFile>$([System.IO.Path]::Combine($(_CrossProjFileDir),  project.assets.json))</_CrossProjAssetsFile>
    </PropertyGroup>

    <ItemGroup>
      <!-- Filter package references to the one for the platform library, in order to find the right version -->
      <PackageReferenceForCrossGen Include="@(PackageReference)" Condition="'%(Identity)' == '$(MicrosoftNETPlatformLibrary)'" />
    </ItemGroup>

    <MSBuild Projects="$(MSBuildProjectFullPath)"
                 Targets="Restore"
                 Properties="RestoreGraphProjectInput=$(MSBuildProjectFullPath);
                             DisableImplicitFrameworkReferences=true;
                             RestoreOutputPath=$(_CrossProjFileDir);
                             StorePackageName=$(MicrosoftNETPlatformLibrary);
                             StorePackageVersion=%(PackageReferenceForCrossGen.Version);"/>

    <ResolvePublishAssemblies ProjectPath="$(MSBuildProjectFullPath)"
                              AssetsFilePath="$(_CrossProjAssetsFile)"
                              TargetFramework="$(_TFM)"
                              RuntimeIdentifier="$(RuntimeIdentifier)"
                              PlatformLibraryName="$(MicrosoftNETPlatformLibrary)"
                              RuntimeFrameworks="@(RuntimeFramework)"
                              ExcludeFromPublishPackageReferences="@(_ExcludeFromPublishPackageReference)"
                              IsSelfContained="$(SelfContained)"
                              PreserveStoreLayout="false">

      <Output TaskParameter="AssembliesToPublish" ItemName="CrossgenResolvedAssembliesToPublish" />
    </ResolvePublishAssemblies>
  </Target>
</Project>