<!--
***********************************************************************************************
Sdk.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
          created a backup copy.  Incorrect changes to this file will make it
          impossible to load or build your projects from the command-line or the IDE.

Copyright (c) .NET Foundation. All rights reserved.
***********************************************************************************************
-->
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- Remaining Work:
    1) Inject CreateReadyToRunImages at correct entrypoint in the build. Related to https://github.com/dotnet/sdk/issues/2583
  -->
  <PropertyGroup>
    <_IntermediateReadyToRunDirName Condition=" '$(_IntermediateReadyToRunDirName)' == '' ">ReadyToRun</_IntermediateReadyToRunDirName>
    <_IntermediateReadyToRunDir Condition=" '$(_IntermediateReadyToRunDir)' == '' ">$(IntermediateOutputPath)$(_IntermediateReadyToRunDirName)</_IntermediateReadyToRunDir>
    <_IntermediateReadyToRunDir>$([System.IO.Path]::GetFullPath($(_IntermediateReadyToRunDir)))</_IntermediateReadyToRunDir>

    <_ReadyToRunOutputDir>$([System.IO.Path]::Combine($(_IntermediateReadyToRunDir),"Output"))</_ReadyToRunOutputDir>
  </PropertyGroup>

  <Target Name="CreateReadyToRunImages"
          BeforeTargets="ComputeFilesToPublish"
          DependsOnTargets="_CheckForUnsupportedReadyToRunCompilation;
                            _InitializeReadyToRunCompilerProps;
                            _ComputeReadyToRunInputs;
                            _RunReadyToRunCompiler;
                            _PublishReadyToRunOutputs"
          Condition="'$(ReadyToRun)' == 'true'">
  </Target>

  <Target Name="_CheckForUnsupportedReadyToRunCompilation"
          Condition="'$(ReadyToRun)' == 'true'">

    <!-- TODO: Add this message as a resource string to the NET SDK so it can be localized -->
    <NETSdkError Condition="'3.0' > '$(_TargetFrameworkVersionWithoutV)'"
        FormattedText="Creating ReadyToRun images is only supported for .NET Core 3.0 and above" />

    <NETSdkError Condition="'$(RuntimeIdentifier)' ==''"
                 ResourceName="RuntimeIdentifierWasNotSpecified"/>

    <NETSdkError Condition="'$(TargetFramework)' ==''"
                 ResourceName="AtLeastOneTargetFrameworkMustBeSpecified"/>

    <!-- Determine whether the host OS platform-architecture supports compilation to the desired RuntimeIdentifier -->
    <PropertyGroup>
      <_TargetArchitecture>$(PlatformTarget)</_TargetArchitecture>
      <_TargetArchitecture Condition="$(RuntimeIdentifier.EndsWith('arm64'))">arm64</_TargetArchitecture>

      <_OSPlatform Condition="$([MSBuild]::IsOSPlatform('windows'))">win</_OSPlatform>
      <_OSPlatform Condition="$([MSBuild]::IsOSPlatform('osx'))">osx</_OSPlatform>
      <_OSPlatform Condition="$([MSBuild]::IsOSPlatform('linux'))">linux</_OSPlatform>
      <_OSArchitecture>$([System.Runtime.InteropServices.RuntimeInformation]::OSArchitecture)</_OSArchitecture>

      <_UnsupportedReadyToRunCompilation>false</_UnsupportedReadyToRunCompilation>

      <!-- First check that the host and target OS are the same -->
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSPlatform)' == 'win' and !$(RuntimeIdentifier.StartsWith('win'))">true</_UnsupportedReadyToRunCompilation>
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSPlatform)' == 'osx' and !$(RuntimeIdentifier.StartsWith('osx'))">true</_UnsupportedReadyToRunCompilation>

      <!-- TODO: Allow cross-compilation to work for Crossgen in supported scenarios -->
      <!-- Next check that the host can compile for the target OS architecture -->
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSArchitecture)' == 'x86' and ('$(_TargetArchitecture)' != 'x86' and '$(_TargetArchitecture)' != 'arm')">true</_UnsupportedReadyToRunCompilation>
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSArchitecture)' == 'arm' and '$(_TargetArchitecture)' != 'arm'">true</_UnsupportedReadyToRunCompilation>
      <!-- TODO insert arm64 capabilities. Specifically, can we always assume arm64 architectures can emulate arm? What about x86? -->
      <_UnsupportedReadyToRunCompilation Condition="'$(_OSArchitecture)' == 'arm64' and '$(_TargetArchitecture)' != 'arm64'">true</_UnsupportedReadyToRunCompilation>
    </PropertyGroup>

    <!-- TODO: Add this message as a resource string to the NET SDK so it can be localized -->
    <NETSdkError Condition="'$(_UnsupportedReadyToRunCompilation)' == 'true'"
        FormattedText="Creating ReadyToRun images is not supported for the RuntimeIdentifier $(RuntimeIdentifier) on the host OS $(_OSPlatform)-$(_OSArchitecture.ToLower())" />
  </Target>

  <Target Name="_ComputeReadyToRunInputs">
    <ItemGroup>
      <_CrossgenInputIntermediateAssembly Include="@(IntermediateAssembly)" />
      <_CrossgenInputAssemblies Include="@(_CrossgenInputIntermediateAssembly)" />
      <!-- If we want to crossgen other IL assemblies, we must filter out the native assemblies -->
      <!-- <_CrossgenInputAssemblies Include="@(ResolvedAssembliesToPublish)" Condition="'%(ResolvedAssembliesToPublish.AssetType)' == 'runtime'" /> -->

      <_CrossgenReferenceAssemblies Include="@(ResolvedAssembliesToPublish)" />
    </ItemGroup>
  </Target>

  <Target Name="_InitializeReadyToRunCompilerProps">
    <!-- Set the Microsoft.DiaSymReader filename which changes based on the host architecture -->
    <PropertyGroup>
      <DiaSymReaderArch>$(_TargetArchitecture)</DiaSymReaderArch>
      <DiaSymReaderArch Condition="'$(_TargetArchitecture)' == 'x64'">amd64</DiaSymReaderArch>
      <DiaSymReaderArch Condition="'$(_TargetArchitecture)' == 'arm' and '$(_OSArchitecture)'!='arm' and '$(_OSPlatform)' == 'win'">x86</DiaSymReaderArch>
      <DiaSymReaderFilename>Microsoft.DiaSymReader.Native.$(DiaSymReaderArch)</DiaSymReaderFilename>
    </PropertyGroup>

    <!-- Get the coreclr path -->
    <ItemGroup>
      <!-- TODO: Switch to using %(ResolvedTargetingPack) to find the targeting pack-->
      <_CoreclrResolvedPath Include="@(ResolvedAssembliesToPublish)"
                                             Condition="'%(ResolvedAssembliesToPublish.Filename)'=='coreclr'" />
      <_CoreclrResolvedPath Include="@(ResolvedAssembliesToPublish)"
                                             Condition="'%(ResolvedAssembliesToPublish.Filename)'=='libcoreclr'" />
      <_JitResolvedPath Include="@(ResolvedAssembliesToPublish)"
                                             Condition="'%(ResolvedAssembliesToPublish.Filename)'=='clrjit'" />
      <_JitResolvedPath Include="@(ResolvedAssembliesToPublish)"
                                             Condition="'%(ResolvedAssembliesToPublish.Filename)'=='libclrjit'" />
      <_MicrosoftDiaSymReaderNativePath Include="@(ResolvedAssembliesToPublish)"
                                             Condition="'%(ResolvedAssembliesToPublish.Filename)'=='$(DiaSymReaderFilename)'" />
    </ItemGroup>

    <!-- Get the crossgen and jit path-->
    <PropertyGroup>
      <_CoreclrPath>@(_CoreclrResolvedPath)</_CoreclrPath>
      <_CoreclrDir>$([System.IO.Path]::GetDirectoryName($(_CoreclrPath)))</_CoreclrDir>
      <_CoreclrPkgDir>$([System.IO.Path]::Combine($(_CoreclrDir),"..\..\..\"))</_CoreclrPkgDir>

      <_JitFilename>@(_JitResolvedPath->'%(Filename)')@(_JitResolvedPath->'%(Extension)')</_JitFilename>
      <_JitCrossArchFilePath Condition="'$(_TargetArchitecture)' == 'arm' and '$(_OSArchitecture)'!='arm' and '$(_OSPlatform)' == 'win'">$([System.IO.Path]::Combine($(_CoreclrPkgDir),"runtimes","x86_arm","native",$(_JitFilename)))</_JitCrossArchFilePath>
      <_JitCrossArchFilePath Condition="'$(_TargetArchitecture)' == 'arm' and '$(_OSArchitecture)'!='arm' and '$(_OSPlatform)' != 'win'">$([System.IO.Path]::Combine($(_CoreclrPkgDir),"runtimes","$(_OSArchitecture)_arm","native",$(_JitFilename)))</_JitCrossArchFilePath>
      <_JitCrossArchFilePath Condition="'$(_TargetArchitecture)' == 'arm64' and '$(_OSArchitecture)'!='arm64'">$([System.IO.Path]::Combine($(_CoreclrPkgDir),"runtimes","x64_arm64","native",$(_JitFilename)))</_JitCrossArchFilePath>

      <DiaSymReaderPath>@(_MicrosoftDiaSymReaderNativePath)</DiaSymReaderPath>
      <DiaSymReaderExistsForTargetArchitecture>true</DiaSymReaderExistsForTargetArchitecture>
      <DiaSymReaderExistsForTargetArchitecture Condition="'$(_OSPlatform)' != 'win'">false</DiaSymReaderExistsForTargetArchitecture>
      <!-- Remove the arm64 check when https://github.com/dotnet/coreclr/issues/7360 is resolved -->
      <DiaSymReaderExistsForTargetArchitecture Condition="'$(_TargetArchitecture)'=='arm64'">false</DiaSymReaderExistsForTargetArchitecture>

      <CrossgenDir>$([System.IO.Path]::Combine($(_CoreclrPkgDir),"tools"))</CrossgenDir>
      <CrossgenDir Condition="'$(_TargetArchitecture)' == 'arm' and '$(_OSArchitecture)'!='arm' and '$(_OSPlatform)' == 'win'">$([System.IO.Path]::Combine($(CrossgenDir),"x86_arm"))</CrossgenDir>
      <CrossgenDir Condition="'$(_TargetArchitecture)' == 'arm' and '$(_OSArchitecture)'!='arm' and '$(_OSPlatform)' != 'win'">$([System.IO.Path]::Combine($(CrossgenDir),"$(_OSArchitecture)_arm"))</CrossgenDir>
      <CrossgenDir Condition="'$(_TargetArchitecture)' == 'arm64' and '$(_OSArchitecture)'!='arm64'">$([System.IO.Path]::Combine($(CrossgenDir),"x64_arm64"))</CrossgenDir>

      <Crossgen>$([System.IO.Path]::Combine($(CrossgenDir),"crossgen"))</Crossgen>
      <Crossgen Condition="'$(OS)' == 'Windows_NT'">$([System.IO.Path]::Combine($(CrossgenDir),"crossgen.exe"))</Crossgen>
    </PropertyGroup>

    <!-- Handle the Jit special case if the target is arm or arm64, which can be hosted on a different architecture -->
    <ItemGroup Condition="'$(_JitCrossArchFilePath)'!=''">
      <_JitResolvedPath Remove="@(_JitResolvedPath)" />
      <_JitResolvedPath Include="$(_JitCrossArchFilePath)" />
    </ItemGroup>
    <PropertyGroup>
      <JitPath>@(_JitResolvedPath)</JitPath>
    </PropertyGroup>

    <!-- Check that there is one unique assembly for several sensitive assemblies -->
    <NETSdkError Condition="'@(_CoreclrResolvedPath->Count())' &gt; 1"
                 ResourceName="MultipleFilesResolved"
                 FormatArguments="coreclr" />

    <NETSdkError Condition="'@(_CoreclrResolvedPath)'== ''"
                 ResourceName="UnableToFindResolvedPath"
                 FormatArguments="coreclr" />

    <NETSdkError Condition="'@(_JitResolvedPath->Count())' &gt; 1"
                 ResourceName="MultipleFilesResolved"
                 FormatArguments="jit" />

    <NETSdkError Condition="'@(_JitResolvedPath)'== ''"
                 ResourceName="UnableToFindResolvedPath"
                 FormatArguments="jit" />

    <NETSdkError Condition="'@(_MicrosoftDiaSymReaderNativePath->Count())' &gt; 1"
                 ResourceName="MultipleFilesResolved"
                 FormatArguments="Microsoft.DiaSymReader.Native" />

    <NETSdkError Condition="'@(_MicrosoftDiaSymReaderNativePath)'== '' and '$(DiaSymReaderExistsForTargetArchitecture)'=='true'"
                 ResourceName="UnableToFindResolvedPath"
                 FormatArguments="Microsoft.DiaSymReader.Native" />

    <NETSdkError Condition="!Exists($(Crossgen))"
                 ResourceName="UnableToFindResolvedPath"
                 FormatArguments="$(Crossgen)" />
  </Target>

  <Target Name="_RunReadyToRunCompiler">
    <PropertyGroup>
      <_CrossgenPlatformAssemblies>@(_CrossgenReferenceAssemblies)</_CrossgenPlatformAssemblies>
    </PropertyGroup>

    <MakeDir Directories="$(_ReadyToRunOutputDir)"/>

    <ItemGroup>
      <CrossgenInvocations Include="$(MSBuildProjectFullPath)">
        <Properties>
          CrossgenExe=$(Crossgen);
          CrossgenInput=%(_CrossgenInputAssemblies.FullPath);
          CrossgenOutput=$(_ReadyToRunOutputDir)/%(FileName)%(Extension);
          CrossgenOutputDirectory=$(_ReadyToRunOutputDir);
          JitPath=$(JitPath);
          DiaSymReaderPath=$(DiaSymReaderPath);
          DiaSymReaderExistsForTargetArchitecture=$(DiaSymReaderExistsForTargetArchitecture);
          CrossgenPlatformAssemblies=$(_CrossgenPlatformAssemblies);
          InputAssemblyName=%(FileName)%(Extension)
        </Properties>
      </CrossgenInvocations>
    </ItemGroup>

    <MSBuild Projects="@(CrossgenInvocations)"
             Targets="InvokeCrossgenForReadyToRun" />
  </Target>

  <Target Name="InvokeCrossgenForReadyToRun"
          Inputs="$(CrossgenInput);$(CrossgenPlatformAssemblies)"
          Outputs="$(CrossgenOutput)">
    <ItemGroup>
      <_CrossgenPlatformAssemblies Include="$(CrossgenPlatformAssemblies)" />
      <__CrossgenPlatformAssembliesPaths Include="@(_CrossgenPlatformAssemblies->'%(RootDir)%(Directory)')" /> 
      <_CrossgenPlatformAssembliesPaths Include="@(__CrossgenPlatformAssembliesPaths->Distinct())" />
    </ItemGroup>

    <PropertyGroup>
      <_PathSeparator>$([System.IO.Path]::PathSeparator)</_PathSeparator>
      <_DirectorySeparatorChar>$([System.IO.Path]::DirectorySeparatorChar)</_DirectorySeparatorChar>
      <_CrossgenPlatformAssembliesPathsProperty>@(_CrossgenPlatformAssembliesPaths, '$(_PathSeparator)')</_CrossgenPlatformAssembliesPathsProperty>
      <!-- Remove the trailing slash so it does not get misinterpreted by Exec -->
      <_CrossgenPlatformAssembliesPathsProperty>$(_CrossgenPlatformAssembliesPathsProperty.TrimEnd('\'))</_CrossgenPlatformAssembliesPathsProperty>

      <CrossgenCommand>$(CrossgenExe) -nologo -readytorun -in $(CrossgenInput) -out $(CrossgenOutput) -jitpath $(JitPath) -platform_assemblies_paths &quot;$(_CrossgenPlatformAssembliesPathsProperty)&quot;</CrossgenCommand>
      <CrossgenCreatePdbCommand>$(CrossgenExe) -nologo -createpdb $(CrossgenOutputDirectory) -diasymreaderpath $(DiaSymReaderPath) -platform_assemblies_paths &quot;$(_CrossgenPlatformAssembliesPathsProperty)&quot; $(CrossgenOutputDirectory)$(_DirectorySeparatorChar)$(InputAssemblyName)</CrossgenCreatePdbCommand>
    </PropertyGroup>

    <Message Text="$(CrossgenCommand)" />
    <Exec Command="$(CrossgenCommand)" />

    <Message Text="$(CrossgenCreatePdbCommand)" Condition="'$(DiaSymReaderExistsForTargetArchitecture)'=='true'" />
    <Exec Command="$(CrossgenCreatePdbCommand)" Condition="'$(DiaSymReaderExistsForTargetArchitecture)'=='true'" />
  </Target>

  <Target Name="_PublishReadyToRunOutputs">
    <!-- Rewrite ResolvedAssembliesToPublish to capture any newly-crossgened ResolvedAssembliesToPublish files, preserving metadata. -->
    <ItemGroup>
      <_CrossgenResolvedAssembliesToPublishCandidates Include="@(ResolvedAssembliesToPublish->'$(_ReadyToRunOutputDir)/%(Filename)%(Extension)')" />
      <_CrossgenResolvedAssembliesToPublish Include="@(_CrossgenResolvedAssembliesToPublishCandidates)" Condition="Exists('%(Identity)')" />

      <ResolvedAssembliesToPublish Remove="@(_CrossgenInputAssemblies)" />
      <ResolvedAssembliesToPublish Include="@(_CrossgenResolvedAssembliesToPublish)" />
    </ItemGroup>

    <!-- Rewrite IntermediateAssembly to capture the newly-crossgened IntermediateAssembly, preserving metadata. -->
    <ItemGroup>
      <_CrossgenIntermediateAssemblyCandidates Include="@(IntermediateAssembly->'$(_ReadyToRunOutputDir)/%(Filename)%(Extension)')" />
      <_CrossgenOutputIntermediateAssembly Include="@(_CrossgenIntermediateAssemblyCandidates)" Condition="Exists('%(Identity)')" />

      <IntermediateAssembly Remove="@(_CrossgenInputIntermediateAssembly)" />
      <IntermediateAssembly Include="@(_CrossgenOutputIntermediateAssembly)" />
    </ItemGroup>
  </Target>
</Project>