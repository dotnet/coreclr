<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <Import Project="..\dir.props"/>
  <Import Project="..\dir.targets" />

  <PropertyGroup>
    <NuGetPackageRoot>$(MSBuildThisFileDirectory)..\.packages\</NuGetPackageRoot>
  </PropertyGroup>
  <Import Project="$(NuGetPackageRoot)\microsoft.dotnet.signtool\$(MicrosoftDotNetSignToolVersion)\build\Microsoft.DotNet.SignTool.props" />

  <ItemGroup>
    <!--
      This is intended to hold information about the certificates used for signing.
      For now the only information required is whether or not the certificate can be
      used for signing already signed files - DualSigningAllowed==true.
    -->
    <CertificatesSignInfo Include="3PartyDual" DualSigningAllowed="true" />
    <CertificatesSignInfo Include="3PartySHA2" DualSigningAllowed="true" />
    <!-- Default certificate/strong-name to be used for all files with PKT=="31bf3856ad364e35". -->
    <StrongNameSignInfo Include="MsSharedLib72" PublicKeyToken="31bf3856ad364e35" CertificateName="Microsoft401" />
    <StrongNameSignInfo Include="SilverlightCert121" PublicKeyToken="7cec85d7bea7798e" CertificateName="Microsoft401" />
    <StrongNameSignInfo Include="StrongName" PublicKeyToken="b77a5c561934e089" CertificateName="Microsoft401" />
    <StrongNameSignInfo Include="StrongName" PublicKeyToken="b03f5f7f11d50a3a" CertificateName="Microsoft401" />
    <!-- <StrongNameSignInfo Include="$(MSBuildThisFileDirectory)snk\Open.snk" PublicKeyToken="cc7b13ffcd2ddd51" CertificateName="Microsoft400" /> -->

    <!--
      Map of file extensions to default certificate name. Files with these extensions are
      signed with the specified certificate. Particularly useful for files that don't have
      a public key token.
      The certificate can be overriden using the StrongNameSignInfo or the FileSignInfo item group.
    -->
    <FileExtensionSignInfo Include=".jar" CertificateName="MicrosoftJAR" />
    <FileExtensionSignInfo Include=".js;.ps1;.psd1;.psm1;.psc1;.py" CertificateName="Microsoft400" />
    <FileExtensionSignInfo Include=".dll;.exe" CertificateName="Microsoft401" />
    <FileExtensionSignInfo Include=".nupkg" CertificateName="NuGet" />
    <FileExtensionSignInfo Include=".vsix" CertificateName="VsixSHA2" />
    <FileExtensionSignInfo Include=".zip" CertificateName="None" />
  </ItemGroup>

  <PropertyGroup>
    <!-- The SignFiles target needs OutDir to be defined -->
    <OutDir>$(BinDir)</OutDir>
  </PropertyGroup>

  <UsingTask AssemblyFile="$(BuildToolsTaskDir)Microsoft.DotNet.Build.Tasks.dll" TaskName="ReadSigningRequired" />

  <ItemGroup>
    <WindowsNativeLocation Include="$(BinDir)*.dll" />
    <WindowsNativeLocation Include="$(BinDir)*.exe" />
  </ItemGroup>

  <ItemGroup Condition="'$(BuildArch)' == 'x86'">
    <!-- Sign api-ms-win-core-xstate-l2-1-0 binary as it is only catalog signed in the current SDK. -->
    <WindowsNativeLocation Condition="'$(BuildType)'=='Release'" Include="$(BinDir)Redist\ucrt\DLLs\$(BuildArch)\api-ms-win-core-xstate-l2-1-0.dll" />
  </ItemGroup>

  <!-- sign the cross targeted files as well -->
  <ItemGroup Condition="'$(CrossTargetComponentFolder)' != ''">
    <WindowsNativeLocation Include="$(BinDir)$(CrossTargetComponentFolder)/*.dll" />
    <WindowsNativeLocation Include="$(BinDir)$(CrossTargetComponentFolder)/*.exe" />
  </ItemGroup>

  <Target Name="GenerateSignForWindowsNative">
    <!--
      Managed assemblies should already have a requires_signing file dropped so only generate
      a requires_signing file for ones that don't exist which should leave just native assembies
    -->
    <WriteSigningRequired AuthenticodeSig="$(AuthenticodeSig)"
                          MarkerFile="%(WindowsNativeLocation.Identity).requires_signing"
                          Condition="!Exists('%(WindowsNativeLocation.Identity).requires_signing')" />
  </Target>

  <!-- populates item group ItemsToSign with the list of files to sign -->
  <Target Name="GetFilesToSignItems"
          DependsOnTargets="GenerateSignForWindowsNative">
    <!-- read all of the marker files and populate the ItemsToSign item group -->
    <ItemGroup>
      <SignMarkerFile Include="$(OutDir)**\*.requires_signing" />
    </ItemGroup>
    <ReadSigningRequired MarkerFiles="@(SignMarkerFile)">
      <Output TaskParameter="SigningMetadata" ItemName="ItemsToSign" />
    </ReadSigningRequired>

    <Message Importance="High" Text="Attempting to sign %(ItemsToSign.Identity) with authenticode='%(ItemsToSign.Authenticode)' and strongname='%(ItemsToSign.StrongName)'" />

  </Target>

  <!-- No-op target to make the arcade build script happy -->
  <Target Name="Restore" />

  <Target Name="Build"
          Condition="'$(SkipSigning)' != 'true'"
          DependsOnTargets="GetFilesToSignItems">

    <PropertyGroup>
      <_DryRun>true</_DryRun>
      <_DryRun Condition="'$(OfficialBuild)' == 'true'">false</_DryRun>

      <_TestSign>false</_TestSign>
      <_TestSign Condition="'$(_SignType)' == 'test'">true</_TestSign>

      <_DesktopMSBuildRequired>false</_DesktopMSBuildRequired>
      <_DesktopMSBuildRequired Condition="'$(_DryRun)' != 'true' and '$(MSBuildRuntimeType)' == 'Core'">true</_DesktopMSBuildRequired>
    </PropertyGroup>

    <!-- We only need this if we are going to use the executable version. -->
    <Exec Command='"$(MSBuildProgramFiles32)\Microsoft Visual Studio\Installer\vswhere.exe" -latest -prerelease -property installationPath -requires Microsoft.Component.MSBuild'
          ConsoleToMsBuild="true"
          StandardErrorImportance="high"
          Condition="$(_DesktopMSBuildRequired)">
      <Output TaskParameter="ConsoleOutput" PropertyName="_VSInstallDir" />
    </Exec>

    <PropertyGroup>
      <_DesktopMSBuildPath Condition="$(_DesktopMSBuildRequired)">$(_VSInstallDir)\MSBuild\15.0\Bin\msbuild.exe</_DesktopMSBuildPath>
    </PropertyGroup>

    <Microsoft.DotNet.SignTool.SignToolTask
            DryRun="$(_DryRun)"
            TestSign="$(_TestSign)"
            CertificatesSignInfo="$(CertificatesSignInfo)"
            ItemsToSign="@(ItemsToSign)"
            StrongNameSignInfo="@(StrongNameSignInfo)"
            FileSignInfo="@(FileSignInfo)"
            FileExtensionSignInfo="@(FileExtensionSignInfo)"
            TempDir="$(IntermediateOutputRootPath)"
            LogDir="$(IntermediateOutputRootPath)"
            MSBuildPath="$(_DesktopMSBuildPath)"
            SNBinaryPath="$(NuGetPackageRoot)sn\$(SNVersion)\sn.exe"
            MicroBuildCorePath="$(NuGetPackageRoot)microbuild.core\$(MicroBuildCoreVersion)"/>
    <!-- now that the files have been signed delete the marker files -->
    <Delete Files="@(SignMarkerFile)" />
  </Target>

</Project>
