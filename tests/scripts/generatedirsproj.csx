using System.IO;
using Microsoft.Build.Construction;
using Microsoft.Build.Evaluation;
using Microsoft.Build.Framework;
using Microsoft.Build.Tasks;
using Microsoft.Build.Utilities;

var start = DateTime.UtcNow;
var projectTemplateName = "dirs.proj.xml";
var outputProjectPath = "..\\src\\dirs.proj";

Console.WriteLine();
Console.WriteLine($" Starting generation of {Path.GetFullPath(outputProjectPath)} project");
Console.WriteLine();

// Prepare and run CreateItem task to glob project files
var projTempl = ProjectRootElement.Open(projectTemplateName);
CreateItem task = new CreateItem();

task.Include = new ITaskItem[]
{
    new TaskItem(@"..\src\**\*.csproj"),
    new TaskItem(@"..\src\**\*.ilproj")
};

ProjectTargetElement disabledTarget = null; 
foreach(var target in projTempl.Targets)
{
    if (target.Name == "ResolveDisabledProjects")
    {
        disabledTarget = target;
        break;
    }
}

Dictionary<string, string> conditionalExcludes = new Dictionary<string, string>();
if (disabledTarget != null)
{
    foreach(var itemsGroup in disabledTarget.ItemGroups)
    {
        if (itemsGroup.Label == "DisabledProjectsItemGroup")
        {
            List<ProjectItemElement> items = new List<ProjectItemElement>(itemsGroup.Items);
            for(int i = 0; i < items.Count; )
            {
                if (!String.IsNullOrEmpty(items[i].Condition))
                {
                    conditionalExcludes.Add(items[i].Include, items[i].Condition);
                    items.RemoveAt(i);
                    continue;
                }
                i++;
            }
        }
    }
}

task.Exclude = new ITaskItem[]
{
      new TaskItem(@"..\src\TestWrappers*\**\*.csproj"),
      new TaskItem(@"..\src\**\cs_template.csproj"),
      new TaskItem(@"..\src\Common\test_runtime\test_runtime.csproj"),
      new TaskItem(@"..\src\Common\test_dependencies\test_dependencies.csproj"),
      new TaskItem(@"..\src\Common\build_against_pkg_dependencies\build_against_pkg_dependencies.csproj"),
      new TaskItem(@"..\src\Common\targeting_pack_ref\targeting_pack_ref.csproj"),
      new TaskItem(@"..\src\Common\external\external.csproj"),
      new TaskItem(@"..\src\Common\PerfHarness\PerfHarness.csproj"),
      new TaskItem(@"..\src\GC\Performance\Framework\GCPerfTestFramework.csproj"),
      new TaskItem(@"..\src\JIT\config\**"),
      new TaskItem(@"..\src\Performance\performance.csproj"),
      new TaskItem(@"..\src\Performance\Scenario\JitBench\unofficial_dotnet\JitBench.csproj"),
      new TaskItem(@"..\src\Loader\classloader\generics\regressions\DD117522\Test.csproj"),
      new TaskItem(@"..\src\Loader\classloader\generics\GenericMethods\VSW491668.csproj"),
};

var result = task.Execute();
Console.WriteLine($" Task CreateItem success: {result}");
if (!result) return 1;

List<string> innerLoopProjList = new List<string>(3200);
List<string> outerLoopProjList = new List<string>(task.Include.Length);
foreach(ITaskItem include in task.Include)
{
    var path = include.GetMetadata("FullPath");
    ProjectRootElement projRoot = ProjectRootElement.Open(path);
    ProjectPropertyElement priorityElement = null;
    foreach(var projProperty in projRoot.Properties)
    {
        if (projProperty.Name == "CLRTestPriority")
        {
            priorityElement = projProperty;
            break;
        }
    }
    
    if (priorityElement == null || priorityElement.Value == "0")
    {
        innerLoopProjList.Add(path);
        outerLoopProjList.Add(path);
    }
    else if (priorityElement.Value == "1")
    {
        outerLoopProjList.Add(path);
    }
}

innerLoopProjList.Sort();
outerLoopProjList.Sort();

Console.WriteLine();
Console.WriteLine($" Number of included outer loop projects:      {outerLoopProjList.Count}");
Console.WriteLine($" Number of included inner loop projects:      {innerLoopProjList.Count}");
Console.WriteLine($" Number of conditionally excluded projects:   {conditionalExcludes.Count}");
Console.WriteLine($" Number of unconditionally excluded projects: {task.Exclude.Length}");
Console.WriteLine();

using (var reader = new StreamReader(projectTemplateName))
using (var writer = new StreamWriter(outputProjectPath, false, Encoding.UTF8))
{
    string line = null;
    do
    {
        line = reader.ReadLine();
        writer.WriteLine(line);
    } while (!line.StartsWith("************"));

    writer.WriteLine();
    writer.WriteLine("WARNING This file is generated by running coreclr/tests/scripts/generatedirsproj.cmd script.");
    writer.WriteLine("        Do not modify this file directly as the changes will be overwritten by code generator.");
    writer.WriteLine("        To change it's content modify coreclr/tests/scripts/dirs.proj.xml template");
    writer.WriteLine("        or coreclr/tests/scripts/generatedirsproj.csx C# script and run generatedirsproj.cmd script");
    writer.WriteLine();
    writer.WriteLine("ADDING NEW TEST PROJECT");
    writer.WriteLine();
    writer.WriteLine("        Create ilproj or csproj under coreclr/tests/src directory tree and regenerate dirs.proj");
    writer.WriteLine("        project file by running generatedirsproj.cmd from coreclr/tests/scripts/ directory using");
    writer.WriteLine("        Visual Studio 2017 developer command prompt.");
    writer.WriteLine(line);

    do
    {
        line = reader.ReadLine();
    } while (!line.StartsWith("-->"));
    
    writer.WriteLine(line);   

    line = reader.ReadLine();
    while(!line.StartsWith("<!--{{{TestGroupProjects}}}-->"))
    {
        writer.WriteLine(line);
        line = reader.ReadLine();
    }

    int innerSliceSize = (innerLoopProjList.Count + (innerLoopProjList.Count % 3)) / 3;
    Console.WriteLine($" Genereting inner loop slices with size:      {innerSliceSize}");
    for (int i = 0, j = 1; i < innerLoopProjList.Count; i += innerSliceSize, j++)
    {
        writer.WriteLine($"    <ItemGroup Condition=\"$(__BuildOS) == 'Windows_NT' And $(__TestGroupToBuild) == '1' And $(TestBuildSlice) == '{j}'\">");
        for(int k = i; k < (i + innerSliceSize) && k < innerLoopProjList.Count; k++)
        {
            string key = innerLoopProjList[k].Split(new []{"tests\\src\\"}, 2, StringSplitOptions.None)[1];
            if (conditionalExcludes.ContainsKey(key))
            {
                writer.WriteLine($"      <Project Condition=\"{conditionalExcludes[key]}\" Include=\"{key}\" >");    
            }
            else
            {
                writer.WriteLine($"      <Project Include=\"{key}\" >");
            }
            writer.WriteLine($"        <AdditionalProperties>OSGroup=$(OSGroup)</AdditionalProperties>");
            writer.WriteLine($"      </Project>");            
        }
        writer.WriteLine($"    </ItemGroup>\n");
    }

    int outerSliceSize = (outerLoopProjList.Count + (outerLoopProjList.Count % 16)) / 16;
    Console.WriteLine($" Genereting outer loop slices with size:      {outerSliceSize}");
    for (int i = 0, j = 1; i < outerLoopProjList.Count; i += outerSliceSize, j++)
    {
        writer.WriteLine($"    <ItemGroup Condition=\"$(__BuildOS) == 'Windows_NT' And $(__TestGroupToBuild) == '2' And $(TestBuildSlice) == '{j}'\">");
        for(int k = i; k < (i + outerSliceSize) && k < outerLoopProjList.Count; k++)
        {
            string key = outerLoopProjList[k].Split(new string[]{"tests\\src\\"}, 2, StringSplitOptions.None)[1];
            if (conditionalExcludes.ContainsKey(key))
            {
                writer.WriteLine($"      <Project Condition=\"{conditionalExcludes[key]}\" Include=\"{key}\" >");    
            }
            else
            {
                writer.WriteLine($"      <Project Include=\"{key}\" >");
            }            
            writer.WriteLine($"        <AdditionalProperties>OSGroup=$(OSGroup)</AdditionalProperties>");
            writer.WriteLine($"      </Project>");
        }
        writer.WriteLine($"    </ItemGroup>");
    }

    line = reader.ReadLine();
    while(line != null)
    {
        writer.WriteLine(line);
        line = reader.ReadLine();
    }
}

Console.WriteLine();
Console.WriteLine($" Finished generating of {Path.GetFullPath(outputProjectPath)} project");
Console.WriteLine($" Time Elapsed {DateTime.UtcNow.Subtract(start)}");
