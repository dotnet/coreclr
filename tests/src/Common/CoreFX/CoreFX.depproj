<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
      <RestoreOutputPath>$(SourceDir)Common\CoreFX\obj</RestoreOutputPath>
      <Language>C#</Language>
      <TargetFramework>netcoreapp5.0</TargetFramework>
      <CLRTestKind>SharedLibrary</CLRTestKind>
      <IsTestProject>false</IsTestProject>
      <MicrosoftDiagnosticsRuntimePackageVersion>1.0.5</MicrosoftDiagnosticsRuntimePackageVersion>
      <DisableImplicitFrameworkReferences>true</DisableImplicitFrameworkReferences>
      <OutputType>Exe</OutputType>
      <ProjectDepsFileName>Microsoft.NETCore.App.deps.json</ProjectDepsFileName>
  </PropertyGroup>

  <ItemGroup>
    <Compile Include="Program.cs" />
  </ItemGroup>

  <!-- Switch RuntimeIdentifier according to currently targeted OSGroup -->
  <PropertyGroup>
      <RuntimeIdentifier Condition="'$(OSGroup)' == 'Windows_NT'">win-$(Platform)</RuntimeIdentifier>
      <RuntimeIdentifier Condition="'$(OSGroup)' == 'Linux'">linux-$(Platform)</RuntimeIdentifier>
      <RuntimeIdentifier Condition="'$(OSGroup)' == 'OSX'">osx-$(Platform)</RuntimeIdentifier>
      <NugetRuntimeIdentifier>$(RuntimeIdentifier)</NugetRuntimeIdentifier>

      <!-- Set AdditionalRestoreArgs so the _DnuRestoreCommandFull in Tools\packageresolve.targets
           passes these on to 'dotnet restore'. This is needed so all the various dirs.props files
           set up the target architecture correctly, so $(Platform) above gets set correctly, among
           other things. (Note that _DnuRestoreCommandFull doesn't properly set
           TargetGroup/ConfigurationGroup/ArchGroup, and even if they are set, it isn't used by
           the various dirs.props files.)
      -->
      <AdditionalRestoreArgs>/p:__BuildOS=$(__BuildOS) /p:__BuildType=$(__BuildType) /p:__BuildArch=$(__BuildArch)</AdditionalRestoreArgs>
  </PropertyGroup>

  <ItemGroup>
    <FrameworkReference Include="Microsoft.NETCore.App" IsImplicitlyDefined="true" Pack="false" PrivateAssets="All" Condition="('$(_TargetFrameworkVersionWithoutV)' != '') And ('$(_TargetFrameworkVersionWithoutV)' &gt;= '3.0')"
                        Version="$(MicrosoftNETCoreAppVersion)" />
    <!-- Microsoft.Private.CoreFx.OOB is a meta-package that contains references to most of what we need -->
    <PackageReference Include="Microsoft.Private.CoreFx.OOB" Version="$(MicrosoftPrivateCoreFxNETCoreAppVersion)" />

    <!-- dotnet.exe -->
    <PackageReference Include="Microsoft.NETCore.DotNetHost" Version="$(MicrosoftNETCoreAppVersion)" />

    <!-- hostfxr.dll -->
    <PackageReference Include="Microsoft.NETCore.DotNetHostResolver" Version="$(MicrosoftNETCoreAppVersion)" />

    <!-- hostpolicy.dll -->
    <PackageReference Include="Microsoft.NETCore.DotNetHostPolicy" Version="$(MicrosoftNETCoreAppVersion)" />

  </ItemGroup>

  <!-- Target SetupTestingHost needs to run after "AfterResolveReferences" so @(ReferenceCopyLocalPaths) is
       set up, and before "BeforeCompile" because @(ReferenceCopyLocalPaths) is cleared out during the
       compile phase.
  -->

  <Target Name="CreateManifestResourceNames" />
  <Target Name="CoreCompile" />

  <Target Name="SetupTestingHost" DependsOnTargets="ResolveAssemblyReferences">
    <MSBuild Projects="@(MSBuildProjectFile)"
             Targets="Publish"
             Properties="RuntimeIdentifier=$(RuntimeIdentifier);PublishDir=$(NETCoreAppTestSharedFrameworkPath)" />

    <Error Condition="'$(CORE_ROOT)' == ''"
           Text="CORE_ROOT variable is not set." />

    <PropertyGroup Condition="'$(OSGroup)'=='Windows_NT'">
      <HostFxrFileName>hostfxr</HostFxrFileName>
      <HostFxrFileExtension>dll</HostFxrFileExtension>
      <DotnetExecutableName>dotnet.exe</DotnetExecutableName>
      <HostPolicyFileName>hostpolicy</HostPolicyFileName>
      <HostPolicyExtension>dll</HostPolicyExtension>
    </PropertyGroup>

    <PropertyGroup Condition="'$(OSGroup)'!='Windows_NT'">
      <HostFxrFileName>libhostfxr</HostFxrFileName>
      <HostFxrFileExtension Condition="'$(OSGroup)' == 'Linux' Or '$(OSGroup)' == 'FreeBSD'">so</HostFxrFileExtension>
      <HostFxrFileExtension Condition="$(OSGroup) =='OSX'">dylib</HostFxrFileExtension>
      <HostPolicyFileName>libhostpolicy</HostPolicyFileName>
      <HostPolicyExtension>$(HostFxrFileExtension)</HostPolicyExtension>
      <DotnetExecutableName>dotnet</DotnetExecutableName>
      <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
    </PropertyGroup>

    <ItemGroup>
      <!-- Workaround for packages on which Microsoft.NetCoreApp expresses a dependency
           The <PackageToInclude> element doesn't allow a version to be specified and we end up with clashing assembly versions in Core_Root
      -->
      <!--
      <NetCoreAppPackagedAssemblies Include="System.Text.Encoding.CodePages.dll"/>
      -->

      <!-- Use xunit dependencies defined in CoreFX.depproj instead of conflicting versions from test dependencies. -->
      <TestDependenciesToExclude Include="$(CORE_ROOT)\**\xunit*"/>

      <!-- Exclude subdirectories that contain cross-architecture (possibly cross-bitness) crossgen/JIT -->
      <TestDependenciesToExclude Include="$(CORE_ROOT)\**\x64\*"/>

      <!-- Don't include all the nuget files -->
      <TestDependenciesToExclude Include="$(CORE_ROOT)\.nuget\**\*"/>

      <!-- Don't include internal crossgen2 dependencies -->
      <TestDependenciesToExclude Include="$(CORE_ROOT)\crossgen2\**\*"/>

      <CoreCLRBinariesToExclude Include="@(NetCoreAppPackagedAssemblies);@(TestDependenciesToExclude -> '%(Identity)')" />
    </ItemGroup>

    <ItemGroup>
      <!-- REVIEW: do we need to copy recursively (and flatten the structure into a single destination folder)? Can we just copy
           the top level? Or, should we preserve the hierarchy?
      -->
      <CoreCLRBinaries Include="$(CORE_ROOT)\**\*.*" Exclude="$(CORE_ROOT)\**\@(CoreCLRBinariesToExclude -> '%(Identity)' )" />
    </ItemGroup>

    <ItemGroup>
      <HostFxFile Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Filename)' == '$(HostFxrFileName)'" />
      <DotnetExe Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Filename)' == 'dotnet'" />
      <HostPolicyFile Include="@(ReferenceCopyLocalPaths)" Condition="'%(ReferenceCopyLocalPaths.Filename)' == '$(HostPolicyFileName)'" />
    </ItemGroup>


    <Copy SourceFiles="@(HostFxFile)"
          DestinationFolder="$(NETCoreAppTestHostFxrPath)"
          SkipUnchangedFiles="true"
          UseHardlinksIfPossible="true" />

    <Copy SourceFiles="@(HostPolicyFile)"
          DestinationFolder="$(NETCoreAppTestSharedFrameworkPath)"
          SkipUnchangedFiles="true"
          UseHardlinksIfPossible="true" />

    <Copy SourceFiles="@(DotnetExe)"
          DestinationFolder="$(TestHostRootPath)"
          SkipUnchangedFiles="true"
          UseHardlinksIfPossible="true"  />

    <Copy SourceFiles="@(CoreCLRBinaries)"
          DestinationFolder="$(NETCoreAppTestSharedFrameworkPath)"
          SkipUnchangedFiles="true" />

    <Exec Command="chmod +x $(TestHostRootPath)%(DotnetExe.Filename)%(DotnetExe.Extension)" Condition="'$(OSGroup)' != 'Windows_NT'"/>
  </Target>

  <PropertyGroup>
    <ProjectAssetsFile>$(SourceDir)Common\CoreFX\obj\project.assets.json</ProjectAssetsFile>
  </PropertyGroup>
</Project>
